/*
 CanvasJS HTML5 & JavaScript Charts - v2.3.1 GA - https://canvasjs.com/
 Copyright 2018 fenopix

  --------------------- License Information --------------------
 CanvasJS is a commercial product which requires purchase of license. Without a commercial license you can use it for evaluation purposes for upto 30 days. Please refer to the following link for further details.
     https://canvasjs.com/license/

*/
/*eslint-disable*/
/*jshint ignore:start*/
! function() {
    function t(t, e) {
        t.prototype = function(t) {
            function e() {}
            return e.prototype = t, new e
        }(e.prototype), t.prototype.constructor = t, t.base = e.prototype
    }

    function e(t, e, i) {
        return "millisecond" === i ? t.setMilliseconds(t.getMilliseconds() + 1 * e) : "second" === i ? t.setSeconds(t.getSeconds() + 1 * e) : "minute" === i ? t.setMinutes(t.getMinutes() + 1 * e) : "hour" === i ? t.setHours(t.getHours() + 1 * e) : "day" === i ? t.setDate(t.getDate() + 1 * e) : "week" === i ? t.setDate(t.getDate() + 7 * e) : "month" === i ? t.setMonth(t.getMonth() + 1 * e) : "year" === i && t.setFullYear(t.getFullYear() + 1 * e), t
    }

    function i(t, e) {
        var i = !1;
        for (0 > t && (i = !0, t *= -1), t = "" + t, e = e || 1; t.length < e;) t = "0" + t;
        return i ? "-" + t : t
    }

    function a(t) {
        if (!t) return t;
        for (var e = /\s/, i = (t = t.replace(/^\s\s*/, "")).length; e.test(t.charAt(--i)););
        return t.slice(0, i + 1)
    }

    function s(t) {
        t.roundRect = function(t, e, i, a, s, n, o, l) {
            o && (this.fillStyle = o), l && (this.strokeStyle = l), void 0 === s && (s = 5), this.lineWidth = n, this.beginPath(), this.moveTo(t + s, e), this.lineTo(t + i - s, e), this.quadraticCurveTo(t + i, e, t + i, e + s), this.lineTo(t + i, e + a - s), this.quadraticCurveTo(t + i, e + a, t + i - s, e + a), this.lineTo(t + s, e + a), this.quadraticCurveTo(t, e + a, t, e + a - s), this.lineTo(t, e + s), this.quadraticCurveTo(t, e, t + s, e), this.closePath(), o && this.fill(), l && 0 < n && this.stroke()
        }
    }

    function n(t, e) {
        return t - e
    }

    function o(t, e) {}

    function l(t) {
        return null == t
    }

    function r(t) {
        return t.indexOf || (t.indexOf = o), t
    }

    function h(t, e, i) {
        var a = t + "_" + e + "_" + (i = i || "normal"),
            s = q[a];
        if (isNaN(s)) {
            try {
                if (t = "position:absolute; left:0px; top:-20000px; padding:0px;margin:0px;border:none;white-space:pre;line-height:normal;font-family:" + t + "; font-size:" + e + "px; font-weight:" + i + ";", !J) {
                    var n = document.body;
                    (J = document.createElement("span")).innerHTML = "";
                    var o = document.createTextNode("Mpgyi");
                    J.appendChild(o), n.appendChild(J)
                }
                J.style.display = "", J.setAttribute("style", t), s = Math.round(J.offsetHeight), J.style.display = "none"
            } catch (t) {
                s = Math.ceil(1.1 * e)
            }
            s = Math.max(s, e), q[a] = s
        }
        return s
    }

    function d(t, e) {
        var i = [];
        if (i = {
                solid: [],
                shortDash: [3, 1],
                shortDot: [1, 1],
                shortDashDot: [3, 1, 1, 1],
                shortDashDotDot: [3, 1, 1, 1, 1, 1],
                dot: [1, 2],
                dash: [4, 2],
                dashDot: [4, 2, 1, 2],
                longDash: [8, 2],
                longDashDot: [8, 2, 1, 2],
                longDashDotDot: [8, 2, 1, 2, 1, 2]
            }[t || "solid"])
            for (var a = 0; a < i.length; a++) i[a] *= e;
        else i = [];
        return i
    }

    function x(t, e, i, a, s) {
        return s = s || !1, (a = a || []).push([t, e, i, s]), t.addEventListener ? (t.addEventListener(e, i, s), i) : !!t.attachEvent && (a = function(e) {
            (e = e || window.event).preventDefault = e.preventDefault || function() {
                e.returnValue = !1
            }, e.stopPropagation = e.stopPropagation || function() {
                e.cancelBubble = !0
            }, i.call(t, e)
        }, t.attachEvent("on" + e, a), a)
    }

    function c(t, e, i) {
        for (t *= at, e *= at, t = i.getImageData(t, e, 2, 2).data, e = !0, i = 0; 4 > i; i++)
            if (t[i] !== t[i + 4] | t[i] !== t[i + 8] | t[i] !== t[i + 12]) {
                e = !1;
                break
            }
        return e ? t[0] << 16 | t[1] << 8 | t[2] : 0
    }

    function p(t, e, i) {
        return t in e ? e[t] : i[t]
    }

    function u(t, e, i) {
        if (D && tt) {
            var a = t.getContext("2d");
            it = a.webkitBackingStorePixelRatio || a.mozBackingStorePixelRatio || a.msBackingStorePixelRatio || a.oBackingStorePixelRatio || a.backingStorePixelRatio || 1, at = et / it, t.width = e * at, t.height = i * at, et !== it && (t.style.width = e + "px", t.style.height = i + "px", a.scale(at, at))
        } else t.width = e, t.height = i
    }

    function m(t, e) {
        I && (this.canvasCount |= 0, window.console.log(++this.canvasCount));
        var i = document.createElement("canvas");
        return i.setAttribute("class", "canvasjs-chart-canvas"), u(i, t, e), D || "undefined" == typeof G_vmlCanvasManager || G_vmlCanvasManager.initElement(i), i
    }

    function g(t, e, i) {
        for (var a in i) e.style[a] = i[a]
    }

    function b(t, e, i) {
        e.getAttribute("state") || (e.style.backgroundColor = t.toolbar.backgroundColor, e.style.color = t.toolbar.fontColor, e.style.border = "none", g(0, e, {
            WebkitUserSelect: "none",
            MozUserSelect: "none",
            msUserSelect: "none",
            userSelect: "none"
        }))
    }

    function y() {
        for (var t = null, e = 0; e < arguments.length; e++)(t = arguments[e]).style && (t.style.display = "inline")
    }

    function v() {
        for (var t = null, e = 0; e < arguments.length; e++)(t = arguments[e]) && t.style && (t.style.display = "none")
    }

    function f(t, e, i, a, s) {
        this._defaultsKey = t, this._themeOptionsKey = e, this._index = a, this.parent = s, this._eventListeners = [], t = {}, this.theme && l(e) && l(a) ? t = l(j[this.theme]) ? j.light1 : j[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[e] && (null === a ? t = this.parent.themeOptions[e] : 0 < this.parent.themeOptions[e].length && (a = Math.min(this.parent.themeOptions[e].length - 1, a), t = this.parent.themeOptions[e][a])), this.themeOptions = t, this.options = i || {
            _isPlaceholder: !0
        }, this.setOptions(this.options, t)
    }

    function k(t, e, i, a, s) {
        void 0 === s && (s = 0), this._padding = s, this._x1 = t, this._y1 = e, this._x2 = i, this._y2 = a, this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
    }

    function M(t, e) {
        M.base.constructor.call(this, "TextBlock", null, e, null, null), this.ctx = t, this._isDirty = !0, this._wrappedText = null, this._initialize()
    }

    function T(t, e) {}

    function P(t, e) {}

    function w(t, e, i) {
        w.base.constructor.call(this, "Subtitle", "subtitles", e, i, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.optionsName = "subtitles", this.isOptionsInArray = !0, void 0 === this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.height = this.width = null, this.bounds = {
            x1: null,
            y1: null,
            x2: null,
            y2: null
        }
    }

    function C() {
        this.pool = []
    }

    function S(t) {}
    var _, B, F, A, L, I = !1,
        V = {},
        D = !!document.createElement("canvas").getContext,
        W = {
            Chart: {
                width: 500,
                height: 400,
                zoomEnabled: !1,
                zoomType: "x",
                backgroundColor: "white",
                theme: "light1",
                animationEnabled: !1,
                animationDuration: 500,
                dataPointWidth: null,
                dataPointMinWidth: null,
                dataPointMaxWidth: null,
                colorSet: "colorSet1",
                culture: "en",
                creditHref: "",
                creditText: " ",
                interactivityEnabled: !0,
                exportEnabled: !1,
                exportFileName: "Chart",
                rangeChanging: null,
                rangeChanged: null,
                publicProperties: {
                    title: "readWrite",
                    subtitles: "readWrite",
                    toolbar: "readWrite",
                    toolTip: "readWrite",
                    legend: "readWrite",
                    axisX: "readWrite",
                    axisY: "readWrite",
                    axisX2: "readWrite",
                    axisY2: "readWrite",
                    data: "readWrite",
                    options: "readWrite",
                    bounds: "readOnly",
                    container: "readOnly"
                }
            },
            Title: {
                padding: 0,
                text: null,
                verticalAlign: "top",
                horizontalAlign: "center",
                fontSize: 50,
                fontFamily: "Calibri",
                fontWeight: "normal",
                fontColor: "black",
                fontStyle: "normal",
                borderThickness: 0,
                borderColor: "black",
                cornerRadius: 0,
                backgroundColor: D ? "transparent" : null,
                margin: 5,
                wrap: !0,
                maxWidth: null,
                dockInsidePlotArea: !1,
                publicProperties: {
                    options: "readWrite",
                    bounds: "readWrite",
                    chart: "readWrite"
                }
            },
            Subtitle: {
                padding: 0,
                text: null,
                verticalAlign: "top",
                horizontalAlign: "center",
                fontSize: 54,
                fontFamily: "Calibri",
                fontWeight: "normal",
                fontColor: "black",
                fontStyle: "normal",
                borderThickness: 0,
                borderColor: "black",
                cornerRadius: 0,
                backgroundColor: null,
                margin: 2,
                wrap: !0,
                maxWidth: null,
                dockInsidePlotArea: !1,
                publicProperties: {
                    options: "readWrite",
                    bounds: "readWrite",
                    chart: "readWrite"
                }
            },
            Toolbar: {
                backgroundColor: "white",
                backgroundColorOnHover: "#2196f3",
                borderColor: "#2196f3",
                borderThickness: 1,
                fontColor: "black",
                fontColorOnHover: "white",
                publicProperties: {
                    options: "readWrite",
                    chart: "readWrite"
                }
            },
            Legend: {
                name: null,
                verticalAlign: "center",
                horizontalAlign: "right",
                fontSize: 14,
                fontFamily: "calibri",
                fontWeight: "normal",
                fontColor: "black",
                fontStyle: "normal",
                cursor: null,
                itemmouseover: null,
                itemmouseout: null,
                itemmousemove: null,
                itemclick: null,
                dockInsidePlotArea: !1,
                reversed: !1,
                backgroundColor: D ? "transparent" : null,
                borderColor: D ? "transparent" : null,
                borderThickness: 0,
                cornerRadius: 0,
                maxWidth: null,
                maxHeight: null,
                markerMargin: null,
                itemMaxWidth: null,
                itemWidth: null,
                itemWrap: !0,
                itemTextFormatter: null,
                publicProperties: {
                    options: "readWrite",
                    bounds: "readWrite",
                    chart: "readWrite"
                }
            },
            ToolTip: {
                enabled: !0,
                shared: !1,
                animationEnabled: !0,
                content: null,
                contentFormatter: null,
                reversed: !1,
                backgroundColor: D ? "rgba(255,255,255,.9)" : "rgb(255,255,255)",
                borderColor: null,
                borderThickness: 2,
                cornerRadius: 5,
                fontSize: 14,
                fontColor: "black",
                fontFamily: "Calibri, Arial, Georgia, serif;",
                fontWeight: "normal",
                fontStyle: "italic",
                publicProperties: {
                    options: "readWrite",
                    chart: "readOnly"
                }
            },
            Axis: {
                minimum: null,
                maximum: null,
                viewportMinimum: null,
                viewportMaximum: null,
                interval: null,
                intervalType: null,
                reversed: !1,
                logarithmic: !1,
                logarithmBase: 10,
                title: null,
                titleFontColor: "black",
                titleFontSize: 50,
                titleFontFamily: "arial",
                titleFontWeight: "normal",
                titleFontStyle: "normal",
                titleWrap: !0,
                titleMaxWidth: null,
                titleBackgroundColor: D ? "transparent" : null,
                titleBorderColor: D ? "transparent" : null,
                titleBorderThickness: 0,
                titleCornerRadius: 0,
                labelAngle: 0,
                labelFontFamily: "arial",
                labelFontColor: "black",
                labelFontSize: 12,
                labelFontWeight: "normal",
                labelFontStyle: "normal",
                labelAutoFit: !0,
                labelWrap: !0,
                labelMaxWidth: null,
                labelFormatter: null,
                labelBackgroundColor: D ? "transparent" : null,
                labelBorderColor: D ? "transparent" : null,
                labelBorderThickness: 0,
                labelCornerRadius: 0,
                labelPlacement: "outside",
                prefix: "",
                suffix: "",
                includeZero: !0,
                tickLength: 5,
                tickColor: "black",
                tickThickness: 1,
                lineColor: "black",
                lineThickness: 1,
                lineDashType: "solid",
                gridColor: "A0A0A0",
                gridThickness: 0,
                gridDashType: "solid",
                interlacedColor: D ? "transparent" : null,
                valueFormatString: null,
                margin: 2,
                publicProperties: {
                    options: "readWrite",
                    stripLines: "readWrite",
                    scaleBreaks: "readWrite",
                    crosshair: "readWrite",
                    bounds: "readOnly",
                    chart: "readOnly"
                }
            },
            StripLine: {
                value: null,
                startValue: null,
                endValue: null,
                color: "orange",
                opacity: null,
                thickness: 2,
                lineDashType: "solid",
                label: "",
                labelPlacement: "inside",
                labelAlign: "far",
                labelWrap: !0,
                labelMaxWidth: null,
                labelBackgroundColor: null,
                labelBorderColor: D ? "transparent" : null,
                labelBorderThickness: 0,
                labelCornerRadius: 0,
                labelFontFamily: "arial",
                labelFontColor: "orange",
                labelFontSize: 12,
                labelFontWeight: "normal",
                labelFontStyle: "normal",
                labelFormatter: null,
                showOnTop: !1,
                publicProperties: {
                    options: "readWrite",
                    axis: "readOnly",
                    bounds: "readOnly",
                    chart: "readOnly"
                }
            },
            ScaleBreaks: {
                autoCalculate: !1,
                collapsibleThreshold: "25%",
                maxNumberOfAutoBreaks: 2,
                spacing: 8,
                type: "straight",
                color: "#FFFFFF",
                fillOpacity: .9,
                lineThickness: 2,
                lineColor: "#E16E6E",
                lineDashType: "solid",
                publicProperties: {
                    options: "readWrite",
                    customBreaks: "readWrite",
                    axis: "readOnly",
                    autoBreaks: "readOnly",
                    bounds: "readOnly",
                    chart: "readOnly"
                }
            },
            Break: {
                startValue: null,
                endValue: null,
                spacing: 8,
                type: "straight",
                color: "#FFFFFF",
                fillOpacity: .9,
                lineThickness: 2,
                lineColor: "#E16E6E",
                lineDashType: "solid",
                publicProperties: {
                    options: "readWrite",
                    scaleBreaks: "readOnly",
                    bounds: "readOnly",
                    chart: "readOnly"
                }
            },
            Crosshair: {
                enabled: !1,
                snapToDataPoint: !1,
                color: "grey",
                opacity: null,
                thickness: 2,
                lineDashType: "solid",
                label: "",
                labelWrap: !0,
                labelMaxWidth: null,
                labelBackgroundColor: D ? "grey" : null,
                labelBorderColor: D ? "grey" : null,
                labelBorderThickness: 0,
                labelCornerRadius: 0,
                labelFontFamily: D ? "Calibri, Optima, Candara, Verdana, Geneva, sans-serif" : "calibri",
                labelFontSize: 12,
                labelFontColor: "#fff",
                labelFontWeight: "normal",
                labelFontStyle: "normal",
                labelFormatter: null,
                valueFormatString: null,
                publicProperties: {
                    options: "readWrite",
                    axis: "readOnly",
                    bounds: "readOnly",
                    chart: "readOnly"
                }
            },
            DataSeries: {
                name: null,
                dataPoints: null,
                label: "",
                bevelEnabled: !1,
                highlightEnabled: !0,
                cursor: "default",
                indexLabel: "",
                indexLabelPlacement: "auto",
                indexLabelOrientation: "horizontal",
                indexLabelFontColor: "black",
                indexLabelFontSize: 52,
                indexLabelFontStyle: "normal",
                indexLabelFontFamily: "Arial",
                indexLabelFontWeight: "normal",
                indexLabelBackgroundColor: null,
                indexLabelLineColor: "gray",
                indexLabelLineThickness: 1,
                indexLabelLineDashType: "solid",
                indexLabelMaxWidth: null,
                indexLabelWrap: !0,
                indexLabelFormatter: null,
                lineThickness: 2,
                lineDashType: "solid",
                connectNullData: !1,
                nullDataLineDashType: "dash",
                color: null,
                lineColor: null,
                risingColor: "white",
                fallingColor: "red",
                fillOpacity: null,
                startAngle: 0,
                radius: null,
                innerRadius: null,
                neckHeight: null,
                neckWidth: null,
                reversed: !1,
                valueRepresents: null,
                linkedDataSeriesIndex: null,
                whiskerThickness: 2,
                whiskerDashType: "solid",
                whiskerColor: null,
                whiskerLength: null,
                stemThickness: 2,
                stemColor: null,
                stemDashType: "solid",
                upperBoxColor: "white",
                lowerBoxColor: "white",
                type: "column",
                xValueType: "number",
                axisXType: "primary",
                axisYType: "primary",
                axisXIndex: 0,
                axisYIndex: 0,
                xValueFormatString: null,
                yValueFormatString: null,
                zValueFormatString: null,
                percentFormatString: null,
                showInLegend: null,
                legendMarkerType: null,
                legendMarkerColor: null,
                legendText: null,
                legendMarkerBorderColor: D ? "transparent" : null,
                legendMarkerBorderThickness: 0,
                markerType: "circle",
                markerColor: null,
                markerSize: null,
                markerBorderColor: D ? "transparent" : null,
                markerBorderThickness: 0,
                mouseover: null,
                mouseout: null,
                mousemove: null,
                click: null,
                toolTipContent: null,
                visible: !0,
                publicProperties: {
                    options: "readWrite",
                    axisX: "readWrite",
                    axisY: "readWrite",
                    chart: "readOnly"
                }
            },
            TextBlock: {
                x: 0,
                y: 0,
                width: null,
                height: null,
                maxWidth: null,
                maxHeight: null,
                padding: 0,
                angle: 0,
                text: "",
                horizontalAlign: "center",
                fontSize: 52,
                fontFamily: "calibri",
                fontWeight: "normal",
                fontColor: "black",
                fontStyle: "normal",
                borderThickness: 0,
                borderColor: "black",
                cornerRadius: 0,
                backgroundColor: null,
                textBaseline: "top"
            },
            CultureInfo: {
                decimalSeparator: ".",
                digitGroupSeparator: ",",
                zoomText: "Zoom",
                panText: "Pan",
                resetText: "Reset",
                menuText: "More Options",
                saveJPGText: "Save as JPEG",
                savePNGText: "Save as PNG",
                printText: "Print",
                days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
                months: "January February March April May June July August September October November December".split(" "),
                shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
            }
        },
        z = {
            en: {}
        },
        X = D ? "Trebuchet MS, Helvetica, sans-serif" : "Arial",
        Y = D ? "Impact, Charcoal, sans-serif" : "Arial",
        E = {
            colorSet1: "#4F81BC #C0504E #9BBB58 #23BFAA #8064A1 #4AACC5 #F79647 #7F6084 #77A033 #33558B #E59566".split(" "),
            colorSet2: "#6D78AD #51CDA0 #DF7970 #4C9CA0 #AE7D99 #C9D45C #5592AD #DF874D #52BCA8 #8E7AA3 #E3CB64 #C77B85 #C39762 #8DD17E #B57952 #FCC26C".split(" "),
            colorSet3: "#8CA1BC #36845C #017E82 #8CB9D0 #708C98 #94838D #F08891 #0366A7 #008276 #EE7757 #E5BA3A #F2990B #03557B #782970".split(" ")
        },
        O = {
            colorSet: "colorSet1",
            backgroundColor: "#FFFFFF",
            title: {
                fontFamily: Y,
                fontSize: 62,
                fontColor: B = "#333333",
                fontWeight: "normal",
                verticalAlign: "top",
                margin: 5
            },
            subtitles: [{
                fontFamily: Y,
                fontSize: H = 14,
                fontColor: B,
                fontWeight: "normal",
                verticalAlign: "top",
                margin: 5
            }],
            data: [{
                indexLabelFontFamily: X,
                indexLabelFontSize: H,
                indexLabelFontColor: B,
                indexLabelFontWeight: "normal",
                indexLabelLineThickness: 1
            }],
            axisX: [{
                titleFontFamily: X,
                titleFontSize: N = 40,
                titleFontColor: B,
                titleFontWeight: "normal",
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: F = "#000000",
                labelFontWeight: "normal",
                lineThickness: 1,
                lineColor: _ = "#666666",
                tickThickness: 1,
                tickColor: _,
                gridThickness: 0,
                gridColor: _,
                stripLines: [{
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#FF7300",
                    labelFontWeight: "normal",
                    labelBackgroundColor: null,
                    color: "#FF7300",
                    thickness: 1
                }],
                crosshair: {
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#EEEEEE",
                    labelFontWeight: "normal",
                    labelBackgroundColor: L = A = "#000000",
                    color: A,
                    thickness: 1,
                    lineDashType: "dash"
                },
                scaleBreaks: {
                    type: "zigzag",
                    spacing: "2%",
                    lineColor: "#BBBBBB",
                    lineThickness: 1,
                    lineDashType: "solid"
                }
            }],
            axisX2: [{
                titleFontFamily: X,
                titleFontSize: N,
                titleFontColor: B,
                titleFontWeight: "normal",
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: F,
                labelFontWeight: "normal",
                lineThickness: 1,
                lineColor: _,
                tickThickness: 1,
                tickColor: _,
                gridThickness: 0,
                gridColor: _,
                stripLines: [{
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#FF7300",
                    labelFontWeight: "normal",
                    labelBackgroundColor: null,
                    color: "#FF7300",
                    thickness: 1
                }],
                crosshair: {
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#EEEEEE",
                    labelFontWeight: "normal",
                    labelBackgroundColor: L,
                    color: A,
                    thickness: 1,
                    lineDashType: "dash"
                },
                scaleBreaks: {
                    type: "zigzag",
                    spacing: "2%",
                    lineColor: "#BBBBBB",
                    lineThickness: 1,
                    lineDashType: "solid"
                }
            }],
            axisY: [{
                titleFontFamily: X,
                titleFontSize: N,
                titleFontColor: B,
                titleFontWeight: "normal",
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: F,
                labelFontWeight: "normal",
                lineThickness: 1,
                lineColor: _,
                tickThickness: 1,
                tickColor: _,
                gridThickness: 1,
                gridColor: _,
                stripLines: [{
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#FF7300",
                    labelFontWeight: "normal",
                    labelBackgroundColor: null,
                    color: "#FF7300",
                    thickness: 1
                }],
                crosshair: {
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#EEEEEE",
                    labelFontWeight: "normal",
                    labelBackgroundColor: L,
                    color: A,
                    thickness: 1,
                    lineDashType: "dash"
                },
                scaleBreaks: {
                    type: "zigzag",
                    spacing: "2%",
                    lineColor: "#BBBBBB",
                    lineThickness: 1,
                    lineDashType: "solid"
                }
            }],
            axisY2: [{
                titleFontFamily: X,
                titleFontSize: N,
                titleFontColor: B,
                titleFontWeight: "normal",
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: F,
                labelFontWeight: "normal",
                lineThickness: 1,
                lineColor: _,
                tickThickness: 1,
                tickColor: _,
                gridThickness: 1,
                gridColor: _,
                stripLines: [{
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#FF7300",
                    labelFontWeight: "normal",
                    labelBackgroundColor: null,
                    color: "#FF7300",
                    thickness: 1
                }],
                crosshair: {
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: "#EEEEEE",
                    labelFontWeight: "normal",
                    labelBackgroundColor: L,
                    color: A,
                    thickness: 1,
                    lineDashType: "dash"
                },
                scaleBreaks: {
                    type: "zigzag",
                    spacing: "2%",
                    lineColor: "#BBBBBB",
                    lineThickness: 1,
                    lineDashType: "solid"
                }
            }],
            legend: {
                fontFamily: X,
                fontSize: 14,
                fontColor: B,
                fontWeight: "bold",
                verticalAlign: "bottom",
                horizontalAlign: "center"
            },
            toolTip: {
                fontFamily: X,
                fontSize: 14,
                fontStyle: "normal",
                cornerRadius: 0,
                borderThickness: 1
            }
        };
    F = B = "#F5F5F5", _ = "#FFFFFF", A = "#40BAF1", L = "#F5F5F5";
    var R = {
        colorSet: "colorSet2",
        title: {
            fontFamily: X,
            fontSize: 83,
            fontColor: "#3A3A3A",
            fontWeight: "bold",
            verticalAlign: "top",
            margin: 5
        },
        subtitles: [{
            fontFamily: X,
            fontSize: H = 14,
            fontColor: "#3A3A3A",
            fontWeight: "normal",
            verticalAlign: "top",
            margin: 5
        }],
        data: [{
            indexLabelFontFamily: X,
            indexLabelFontSize: H,
            indexLabelFontColor: "#666666",
            indexLabelFontWeight: "normal",
            indexLabelLineThickness: 1
        }],
        axisX: [{
            titleFontFamily: X,
            titleFontSize: N = 50,
            titleFontColor: "#666666",
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: "#666666",
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: "#BBBBBB",
            tickThickness: 1,
            tickColor: "#BBBBBB",
            gridThickness: 1,
            gridColor: "#BBBBBB",
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FFA500",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FFA500",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#EEEEEE",
                labelFontWeight: "normal",
                labelBackgroundColor: "black",
                color: "black",
                thickness: 1,
                lineDashType: "dot"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#BBBBBB",
                lineThickness: 1,
                lineDashType: "solid"
            }
        }],
        axisX2: [{
            titleFontFamily: X,
            titleFontSize: N,
            titleFontColor: "#666666",
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: "#666666",
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: "#BBBBBB",
            tickColor: "#BBBBBB",
            tickThickness: 1,
            gridThickness: 1,
            gridColor: "#BBBBBB",
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FFA500",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FFA500",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#EEEEEE",
                labelFontWeight: "normal",
                labelBackgroundColor: "black",
                color: "black",
                thickness: 1,
                lineDashType: "dot"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#BBBBBB",
                lineThickness: 1,
                lineDashType: "solid"
            }
        }],
        axisY: [{
            titleFontFamily: X,
            titleFontSize: N,
            titleFontColor: "#666666",
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: "#666666",
            labelFontWeight: "normal",
            lineThickness: 0,
            lineColor: "#BBBBBB",
            tickColor: "#BBBBBB",
            tickThickness: 1,
            gridThickness: 1,
            gridColor: "#BBBBBB",
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FFA500",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FFA500",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#EEEEEE",
                labelFontWeight: "normal",
                labelBackgroundColor: "black",
                color: "black",
                thickness: 1,
                lineDashType: "dot"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#BBBBBB",
                lineThickness: 1,
                lineDashType: "solid"
            }
        }],
        axisY2: [{
            titleFontFamily: X,
            titleFontSize: N,
            titleFontColor: "#666666",
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: "#666666",
            labelFontWeight: "normal",
            lineThickness: 0,
            lineColor: "#BBBBBB",
            tickColor: "#BBBBBB",
            tickThickness: 1,
            gridThickness: 1,
            gridColor: "#BBBBBB",
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FFA500",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FFA500",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#EEEEEE",
                labelFontWeight: "normal",
                labelBackgroundColor: "black",
                color: "black",
                thickness: 1,
                lineDashType: "dot"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#BBBBBB",
                lineThickness: 1,
                lineDashType: "solid"
            }
        }],
        legend: {
            fontFamily: X,
            fontSize: 14,
            fontColor: "#3A3A3A",
            fontWeight: "bold",
            verticalAlign: "bottom",
            horizontalAlign: "center"
        },
        toolTip: {
            fontFamily: X,
            fontSize: 14,
            fontStyle: "normal",
            cornerRadius: 0,
            borderThickness: 1
        }
    };
    F = B = "#F5F5F5", Y = {
        colorSet: "colorSet12",
        backgroundColor: "#2A2A2A",
        title: {
            fontFamily: Y,
            fontSize: 62,
            fontColor: B,
            fontWeight: "normal",
            verticalAlign: "top",
            margin: 5
        },
        subtitles: [{
            fontFamily: Y,
            fontSize: H = 14,
            fontColor: B,
            fontWeight: "normal",
            verticalAlign: "top",
            margin: 5
        }],
        toolbar: {
            backgroundColor: "#666666",
            backgroundColorOnHover: "#FF7372",
            borderColor: "#FF7372",
            borderThickness: 1,
            fontColor: "#F5F5F5",
            fontColorOnHover: "#F5F5F5"
        },
        data: [{
            indexLabelFontFamily: X,
            indexLabelFontSize: H,
            indexLabelFontColor: F,
            indexLabelFontWeight: "normal",
            indexLabelLineThickness: 1
        }],
        axisX: [{
            titleFontFamily: X,
            titleFontSize: N = 50,
            titleFontColor: F,
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: F,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: _ = "#FFFFFF",
            tickThickness: 1,
            tickColor: _,
            gridThickness: 0,
            gridColor: _,
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: L = "#F5F5F5",
                color: A = "#40BAF1",
                thickness: 1,
                lineDashType: "dash"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111"
            }
        }],
        axisX2: [{
            titleFontFamily: X,
            titleFontSize: N,
            titleFontColor: F,
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: F,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: _,
            tickThickness: 1,
            tickColor: _,
            gridThickness: 0,
            gridColor: _,
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: L,
                color: A,
                thickness: 1,
                lineDashType: "dash"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111"
            }
        }],
        axisY: [{
            titleFontFamily: X,
            titleFontSize: N,
            titleFontColor: F,
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: F,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: _,
            tickThickness: 1,
            tickColor: _,
            gridThickness: 1,
            gridColor: _,
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: L,
                color: A,
                thickness: 1,
                lineDashType: "dash"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111"
            }
        }],
        axisY2: [{
            titleFontFamily: X,
            titleFontSize: N,
            titleFontColor: F,
            titleFontWeight: "normal",
            labelFontFamily: X,
            labelFontSize: H,
            labelFontColor: F,
            labelFontWeight: "normal",
            lineThickness: 1,
            lineColor: _,
            tickThickness: 1,
            tickColor: _,
            gridThickness: 1,
            gridColor: _,
            stripLines: [{
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#FF7300",
                labelFontWeight: "normal",
                labelBackgroundColor: null,
                color: "#FF7300",
                thickness: 1
            }],
            crosshair: {
                labelFontFamily: X,
                labelFontSize: H,
                labelFontColor: "#000000",
                labelFontWeight: "normal",
                labelBackgroundColor: L,
                color: A,
                thickness: 1,
                lineDashType: "dash"
            },
            scaleBreaks: {
                type: "zigzag",
                spacing: "2%",
                lineColor: "#777777",
                lineThickness: 1,
                lineDashType: "solid",
                color: "#111111"
            }
        }],
        legend: {
            fontFamily: X,
            fontSize: 14,
            fontColor: B,
            fontWeight: "bold",
            verticalAlign: "bottom",
            horizontalAlign: "center"
        },
        toolTip: {
            fontFamily: X,
            fontSize: 14,
            fontStyle: "normal",
            cornerRadius: 0,
            borderThickness: 1,
            fontColor: F,
            backgroundColor: "rgba(0, 0, 0, .7)"
        }
    }, F = B = "#FAFAFA";
    var N, H, j = {
            light1: O,
            light2: R,
            dark1: Y,
            dark2: {
                colorSet: "colorSet2",
                backgroundColor: "#32373A",
                title: {
                    fontFamily: X,
                    fontSize: 52,
                    fontColor: B,
                    fontWeight: "normal",
                    verticalAlign: "top",
                    margin: 5
                },
                subtitles: [{
                    fontFamily: X,
                    fontSize: H = 14,
                    fontColor: B,
                    fontWeight: "normal",
                    verticalAlign: "top",
                    margin: 5
                }],
                toolbar: {
                    backgroundColor: "#666666",
                    backgroundColorOnHover: "#FF7372",
                    borderColor: "#FF7372",
                    borderThickness: 1,
                    fontColor: "#F5F5F5",
                    fontColorOnHover: "#F5F5F5"
                },
                data: [{
                    indexLabelFontFamily: X,
                    indexLabelFontSize: H,
                    indexLabelFontColor: F,
                    indexLabelFontWeight: "normal",
                    indexLabelLineThickness: 1
                }],
                axisX: [{
                    titleFontFamily: X,
                    titleFontSize: N = 50,
                    titleFontColor: F,
                    titleFontWeight: "normal",
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: F,
                    labelFontWeight: "normal",
                    lineThickness: 1,
                    lineColor: _ = "#FFFFFF",
                    tickThickness: 1,
                    tickColor: _,
                    gridThickness: 0,
                    gridColor: _,
                    stripLines: [{
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#FF7300",
                        labelFontWeight: "normal",
                        labelBackgroundColor: null,
                        color: "#FF7300",
                        thickness: 1
                    }],
                    crosshair: {
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#000000",
                        labelFontWeight: "normal",
                        labelBackgroundColor: L = "#F5F5F5",
                        color: A = "#40BAF1",
                        thickness: 1,
                        lineDashType: "dash"
                    },
                    scaleBreaks: {
                        type: "zigzag",
                        spacing: "2%",
                        lineColor: "#777777",
                        lineThickness: 1,
                        lineDashType: "solid",
                        color: "#111111"
                    }
                }],
                axisX2: [{
                    titleFontFamily: X,
                    titleFontSize: N,
                    titleFontColor: F,
                    titleFontWeight: "normal",
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: F,
                    labelFontWeight: "normal",
                    lineThickness: 1,
                    lineColor: _,
                    tickThickness: 1,
                    tickColor: _,
                    gridThickness: 0,
                    gridColor: _,
                    stripLines: [{
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#FF7300",
                        labelFontWeight: "normal",
                        labelBackgroundColor: null,
                        color: "#FF7300",
                        thickness: 1
                    }],
                    crosshair: {
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#000000",
                        labelFontWeight: "normal",
                        labelBackgroundColor: L,
                        color: A,
                        thickness: 1,
                        lineDashType: "dash"
                    },
                    scaleBreaks: {
                        type: "zigzag",
                        spacing: "2%",
                        lineColor: "#777777",
                        lineThickness: 1,
                        lineDashType: "solid",
                        color: "#111111"
                    }
                }],
                axisY: [{
                    titleFontFamily: X,
                    titleFontSize: N,
                    titleFontColor: F,
                    titleFontWeight: "normal",
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: F,
                    labelFontWeight: "normal",
                    lineThickness: 0,
                    lineColor: _,
                    tickThickness: 1,
                    tickColor: _,
                    gridThickness: 1,
                    gridColor: _,
                    stripLines: [{
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#FF7300",
                        labelFontWeight: "normal",
                        labelBackgroundColor: null,
                        color: "#FF7300",
                        thickness: 1
                    }],
                    crosshair: {
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#000000",
                        labelFontWeight: "normal",
                        labelBackgroundColor: L,
                        color: A,
                        thickness: 1,
                        lineDashType: "dash"
                    },
                    scaleBreaks: {
                        type: "zigzag",
                        spacing: "2%",
                        lineColor: "#777777",
                        lineThickness: 1,
                        lineDashType: "solid",
                        color: "#111111"
                    }
                }],
                axisY2: [{
                    titleFontFamily: X,
                    titleFontSize: N,
                    titleFontColor: F,
                    titleFontWeight: "normal",
                    labelFontFamily: X,
                    labelFontSize: H,
                    labelFontColor: F,
                    labelFontWeight: "normal",
                    lineThickness: 0,
                    lineColor: _,
                    tickThickness: 1,
                    tickColor: _,
                    gridThickness: 1,
                    gridColor: _,
                    stripLines: [{
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#FF7300",
                        labelFontWeight: "normal",
                        labelBackgroundColor: null,
                        color: "#FF7300",
                        thickness: 1
                    }],
                    crosshair: {
                        labelFontFamily: X,
                        labelFontSize: H,
                        labelFontColor: "#000000",
                        labelFontWeight: "normal",
                        labelBackgroundColor: L,
                        color: A,
                        thickness: 1,
                        lineDashType: "dash"
                    },
                    scaleBreaks: {
                        type: "zigzag",
                        spacing: "2%",
                        lineColor: "#777777",
                        lineThickness: 1,
                        lineDashType: "solid",
                        color: "#111111"
                    }
                }],
                legend: {
                    fontFamily: X,
                    fontSize: 14,
                    fontColor: B,
                    fontWeight: "bold",
                    verticalAlign: "bottom",
                    horizontalAlign: "center"
                },
                toolTip: {
                    fontFamily: X,
                    fontSize: 14,
                    fontStyle: "normal",
                    cornerRadius: 0,
                    borderThickness: 1,
                    fontColor: F,
                    backgroundColor: "rgba(0, 0, 0, .7)"
                }
            },
            theme1: O,
            theme2: R,
            theme3: O
        },
        U = {
            numberDuration: 1,
            yearDuration: 314496e5,
            monthDuration: 2592e6,
            weekDuration: 6048e5,
            dayDuration: 864e5,
            hourDuration: 36e5,
            minuteDuration: 6e4,
            secondDuration: 1e3,
            millisecondDuration: 1,
            dayOfWeekFromInt: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
        };
    V.fSDec = function(t) {
        for (var e = "", i = 0; i < t.length; i++) e += String.fromCharCode(Math.ceil(t.length / 57 / 5) ^ t.charCodeAt(i));
        return e
    }, V.obj = {
        trVs: "Ush`m!Wdsrhno",
        fntStr: "qy!B`mhcsh-!Mtbhe`!Fs`oed-!Mtbhe`!R`or!Tohbned-!@sh`m-!r`or,rdshg",
        txtBl: "udyuC`rdmhod",
        fnt: "gnou",
        fSy: "ghmmRuxmd",
        fTx: "ghmmUdyu",
        grClr: "fsdx",
        cntx: "buy",
        tp: "unq"
    }, delete W[V.fSDec("Bi`su")][V.fSDec("bsdehuIsdg")], V.pro = {
        sCH: W[V.fSDec("Bi`su")][V.fSDec("bsdehuIsdg")]
    }, V._fTWm = function(t) {
        if (void 0 === V.pro.sCH && !ot) try {
            var e = t[V.fSDec(V.obj.cntx)];
            e[V.fSDec(V.obj.txtBl)] = V.fSDec(V.obj.tp), e[V.fSDec(V.obj.fnt)] = 11 + V.fSDec(V.obj.fntStr), e[V.fSDec(V.obj.fSy)] = V.fSDec(V.obj.grClr), e[V.fSDec(V.obj.fTx)](V.fSDec(V.obj.trVs), 2, t.height - 11 - 2)
        } catch (t) {}
    };
    var q = {},
        J = null,
        K = function() {
            this.ctx.clearRect(0, 0, this.width, this.height), this.backgroundColor && (this.ctx.fillStyle = this.backgroundColor, this.ctx.fillRect(0, 0, this.width, this.height))
        },
        G = function(t, e, i) {
            return e = Math.min(this.width, this.height), Math.max("theme4" === this.theme ? 0 : 300 <= e ? 12 : 10, Math.round(e * (t / 400)))
        },
        Q = function() {
            var t = /D{1,4}|M{1,4}|Y{1,4}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|f{1,3}|t{1,2}|T{1,2}|K|z{1,3}|"[^"]*"|'[^']*'/g,
                e = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                a = "Sun Mon Tue Wed Thu Fri Sat".split(" "),
                s = "January February March April May June July August September October November December".split(" "),
                n = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                o = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
                l = /[^-+\dA-Z]/g;
            return function(r, h, d) {
                var x = d ? d.days : e,
                    c = d ? d.months : s,
                    p = d ? d.shortDays : a,
                    u = d ? d.shortMonths : n;
                d = "";
                var m = !1;
                if (r = r && r.getTime ? r : r ? new Date(r) : new Date, isNaN(r)) throw SyntaxError("invalid date");
                "UTC:" === h.slice(0, 4) && (h = h.slice(4), m = !0);
                var g = r[(d = m ? "getUTC" : "get") + "Date"](),
                    b = r[d + "Day"](),
                    y = r[d + "Month"](),
                    v = r[d + "FullYear"](),
                    f = r[d + "Hours"](),
                    k = r[d + "Minutes"](),
                    M = r[d + "Seconds"](),
                    T = r[d + "Milliseconds"](),
                    P = m ? 0 : r.getTimezoneOffset();
                return h.replace(t, function(t) {
                    switch (t) {
                        case "D":
                            return g;
                        case "DD":
                            return i(g, 2);
                        case "DDD":
                            return p[b];
                        case "DDDD":
                            return x[b];
                        case "M":
                            return y + 1;
                        case "MM":
                            return i(y + 1, 2);
                        case "MMM":
                            return u[y];
                        case "MMMM":
                            return c[y];
                        case "Y":
                            return parseInt(String(v).slice(-2));
                        case "YY":
                            return i(String(v).slice(-2), 2);
                        case "YYY":
                            return i(String(v).slice(-3), 3);
                        case "YYYY":
                            return i(v, 4);
                        case "h":
                            return f % 12 || 12;
                        case "hh":
                            return i(f % 12 || 12, 2);
                        case "H":
                            return f;
                        case "HH":
                            return i(f, 2);
                        case "m":
                            return k;
                        case "mm":
                            return i(k, 2);
                        case "s":
                            return M;
                        case "ss":
                            return i(M, 2);
                        case "f":
                            return String(T).slice(0, 1);
                        case "ff":
                            return i(String(T).slice(0, 2), 2);
                        case "fff":
                            return i(String(T).slice(0, 3), 3);
                        case "t":
                            return 12 > f ? "a" : "p";
                        case "tt":
                            return 12 > f ? "am" : "pm";
                        case "T":
                            return 12 > f ? "A" : "P";
                        case "TT":
                            return 12 > f ? "AM" : "PM";
                        case "K":
                            return m ? "UTC" : (String(r).match(o) || [""]).pop().replace(l, "");
                        case "z":
                            return (0 < P ? "-" : "+") + Math.floor(Math.abs(P) / 60);
                        case "zz":
                            return (0 < P ? "-" : "+") + i(Math.floor(Math.abs(P) / 60), 2);
                        case "zzz":
                            return (0 < P ? "-" : "+") + i(Math.floor(Math.abs(P) / 60), 2) + i(Math.abs(P) % 60, 2);
                        default:
                            return t.slice(1, t.length - 1)
                    }
                })
            }
        }(),
        Z = function(t, e, a) {
            if (null === t) return "";
            if (!isFinite(t)) return t;
            var s = 0 > (t = Number(t));
            s && (t *= -1);
            var n = a ? a.decimalSeparator : ".",
                o = a ? a.digitGroupSeparator : ",",
                l = "";
            e = String(e);
            l = 1;
            var r = a = "",
                h = -1,
                d = [],
                x = [],
                c = 0,
                p = 0,
                u = 0,
                m = !1,
                g = 0;
            r = e.match(/"[^"]*"|'[^']*'|[eE][+-]*[0]+|[,]+[.]|\u2030|./g);
            e = null;
            for (var b = 0; r && b < r.length; b++)
                if ("." === (e = r[b]) && 0 > h) h = b;
                else {
                    if ("%" === e) l *= 100;
                    else {
                        if ("‰" === e) {
                            l *= 1e3;
                            continue
                        }
                        if ("," === e[0] && "." === e[e.length - 1]) {
                            l /= Math.pow(1e3, e.length - 1), h = b + e.length - 1;
                            continue
                        }
                        "E" !== e[0] && "e" !== e[0] || "0" !== e[e.length - 1] || (m = !0)
                    }
                    0 > h ? (d.push(e), "#" === e || "0" === e ? c++ : "," === e && u++) : (x.push(e), "#" !== e && "0" !== e || p++)
                }
            for (m && (e = Math.floor(t), r = -Math.floor(Math.log(t) / Math.LN10 + 1), g = 0 === t ? 0 : 0 === e ? -(c + r) : String(e).length - c, l /= Math.pow(10, g)), 0 > h && (h = b), e = (l = (t * l).toFixed(p)).split("."), l = (e[0] + "").split(""), t = (e[1] + "").split(""), l && "0" === l[0] && l.shift(), m = r = b = p = h = 0; 0 < d.length;)
                if ("#" === (e = d.pop()) || "0" === e)
                    if (++h === c) {
                        var y = l;
                        l = [];
                        if ("0" === e)
                            for (e = c - p - (y ? y.length : 0); 0 < e;) y.unshift("0"), e--;
                        for (; 0 < y.length;) a = y.pop() + a, 0 == ++m % r && b === u && 0 < y.length && (a = o + a)
                    } else 0 < l.length ? (a = l.pop() + a, p++, m++) : "0" === e && (a = "0" + a, p++, m++), 0 == m % r && b === u && 0 < l.length && (a = o + a);
            else "E" !== e[0] && "e" !== e[0] || "0" !== e[e.length - 1] || !/[eE][+-]*[0]+/.test(e) ? "," === e ? (b++, r = m, m = 0, 0 < l.length && (a = o + a)) : a = 1 < e.length && ('"' === e[0] && '"' === e[e.length - 1] || "'" === e[0] && "'" === e[e.length - 1]) ? e.slice(1, e.length - 1) + a : e + a : a += (e = 0 > g ? e.replace("+", "").replace("-", "") : e.replace("-", "")).replace(/[0]+/, function(t) {
                return i(g, t.length)
            });
            for (o = "", d = !1; 0 < x.length;) "#" === (e = x.shift()) || "0" === e ? 0 < t.length && 0 !== Number(t.join("")) ? (o += t.shift(), d = !0) : "0" === e && (o += "0", d = !0) : 1 < e.length && ('"' === e[0] && '"' === e[e.length - 1] || "'" === e[0] && "'" === e[e.length - 1]) ? o += e.slice(1, e.length - 1) : "E" !== e[0] && "e" !== e[0] || "0" !== e[e.length - 1] || !/[eE][+-]*[0]+/.test(e) ? o += e : o += (e = 0 > g ? e.replace("+", "").replace("-", "") : e.replace("-", "")).replace(/[0]+/, function(t) {
                return i(g, t.length)
            });
            return a += (d ? n : "") + o, s ? "-" + a : a
        },
        $ = function(t) {
            var e = 0,
                i = 0;
            return (t = t || window.event).offsetX || 0 === t.offsetX ? (e = t.offsetX, i = t.offsetY) : t.layerX || 0 == t.layerX ? (e = t.layerX, i = t.layerY) : (e = t.pageX - t.target.offsetLeft, i = t.pageY - t.target.offsetTop), {
                x: e,
                y: i
            }
        },
        tt = !0,
        et = window.devicePixelRatio || 1,
        it = 1,
        at = tt ? et / it : 1,
        st = function(t, e, i, a, s, n, o, l, r, h, d, x, c) {
            void 0 === c && (c = 1), o = o || 0, l = l || "black";
            var p = 15 < a - e && 15 < s - i ? 8 : .35 * Math.min(a - e, s - i);
            t.beginPath(), t.moveTo(e, i), t.save(), t.fillStyle = n, t.globalAlpha = c, t.fillRect(e, i, a - e, s - i), t.globalAlpha = 1, 0 < o && (c = 0 == o % 2 ? 0 : .5, t.beginPath(), t.lineWidth = o, t.strokeStyle = l, t.moveTo(e, i), t.rect(e - c, i - c, a - e + 2 * c, s - i + 2 * c), t.stroke()), t.restore(), !0 === r && (t.save(), t.beginPath(), t.moveTo(e, i), t.lineTo(e + p, i + p), t.lineTo(a - p, i + p), t.lineTo(a, i), t.closePath(), (o = t.createLinearGradient((a + e) / 2, i + p, (a + e) / 2, i)).addColorStop(0, n), o.addColorStop(1, "rgba(255, 255, 255, .4)"), t.fillStyle = o, t.fill(), t.restore()), !0 === h && (t.save(), t.beginPath(), t.moveTo(e, s), t.lineTo(e + p, s - p), t.lineTo(a - p, s - p), t.lineTo(a, s), t.closePath(), (o = t.createLinearGradient((a + e) / 2, s - p, (a + e) / 2, s)).addColorStop(0, n), o.addColorStop(1, "rgba(255, 255, 255, .4)"), t.fillStyle = o, t.fill(), t.restore()), !0 === d && (t.save(), t.beginPath(), t.moveTo(e, i), t.lineTo(e + p, i + p), t.lineTo(e + p, s - p), t.lineTo(e, s), t.closePath(), (o = t.createLinearGradient(e + p, (s + i) / 2, e, (s + i) / 2)).addColorStop(0, n), o.addColorStop(1, "rgba(255, 255, 255, 0.1)"), t.fillStyle = o, t.fill(), t.restore()), !0 === x && (t.save(), t.beginPath(), t.moveTo(a, i), t.lineTo(a - p, i + p), t.lineTo(a - p, s - p), t.lineTo(a, s), (o = t.createLinearGradient(a - p, (s + i) / 2, a, (s + i) / 2)).addColorStop(0, n), o.addColorStop(1, "rgba(255, 255, 255, 0.1)"), t.fillStyle = o, o.addColorStop(0, n), o.addColorStop(1, "rgba(255, 255, 255, 0.1)"), t.fillStyle = o, t.fill(), t.closePath(), t.restore())
        },
        nt = function(t) {
            for (var e = "", i = 0; i < t.length; i++) e += String.fromCharCode(Math.ceil(t.length / 57 / 5) ^ t.charCodeAt(i));
            return e
        },
        ot = window && window[nt("mnb`uhno")] && window[nt("mnb`uhno")].href && window[nt("mnb`uhno")].href.indexOf && (-1 !== window[nt("mnb`uhno")].href.indexOf(nt("b`ow`rkr/bnl")) || -1 !== window[nt("mnb`uhno")].href.indexOf(nt("gdonqhy/bnl")) || -1 !== window[nt("mnb`uhno")].href.indexOf(nt("gheemd")));
    ot && window[nt("mnb`uhno")].href.indexOf(nt("gheemd"));
    f.prototype.setOptions = function(t, e) {
        if (W[this._defaultsKey]) {
            var i, a = W[this._defaultsKey];
            for (i in a) "publicProperties" !== i && a.hasOwnProperty(i) && (this[i] = t && i in t ? t[i] : e && i in e ? e[i] : a[i])
        } else I && window.console && console.log("defaults not set")
    }, f.prototype.get = function(t) {
        var e = W[this._defaultsKey];
        return "options" === t ? this.options && this.options._isPlaceholder ? null : this.options : e.hasOwnProperty(t) || e.publicProperties && e.publicProperties.hasOwnProperty(t) ? this[t] : void(window.console && window.console.log('Property "' + t + "\" doesn't exist. Please check for typo."))
    }, f.prototype.set = function(t, e, i) {
        i = void 0 === i || i;
        var a = W[this._defaultsKey];
        if ("options" === t) this.createUserOptions(e);
        else {
            if (!(a.hasOwnProperty(t) || a.publicProperties && a.publicProperties.hasOwnProperty(t) && "readWrite" === a.publicProperties[t])) return void(window.console && (a.publicProperties && a.publicProperties.hasOwnProperty(t) && "readOnly" === a.publicProperties[t] ? window.console.log('Property "' + t + '" is read-only.') : window.console.log('Property "' + t + "\" doesn't exist. Please check for typo.")));
            this.options._isPlaceholder && this.createUserOptions(), this.options[t] = e
        }
        i && (this.stockChart || this.chart || this).render()
    }, f.prototype.addTo = function(t, e, i, a) {
        a = void 0 === a || a;
        var s = W[this._defaultsKey];
        s.hasOwnProperty(t) || s.publicProperties && s.publicProperties.hasOwnProperty(t) && "readWrite" === s.publicProperties[t] ? (this.options._isPlaceholder && this.createUserOptions(), void 0 === this.options[t] && (this.options[t] = []), t = this.options[t], i = null == i ? t.length : i, t.splice(i, 0, e), a && (this.chart || this).render()) : window.console && (s.publicProperties && s.publicProperties.hasOwnProperty(t) && "readOnly" === s.publicProperties[t] ? window.console.log('Property "' + t + '" is read-only.') : window.console.log('Property "' + t + "\" doesn't exist. Please check for typo."))
    }, f.prototype.createUserOptions = function(t) {
        if (void 0 !== t || this.options._isPlaceholder)
            if (this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.isOptionsInArray) {
                this.parent.options[this.optionsName] || (this.parent.options[this.optionsName] = []);
                var e = this.parent.options[this.optionsName],
                    i = e.length;
                this.options._isPlaceholder || (r(e), i = e.indexOf(this.options)), this.options = void 0 === t ? {} : t, e[i] = this.options
            } else this.options = void 0 === t ? {} : t, t = this.parent.options, this.optionsName ? e = this.optionsName : (e = this._defaultsKey) && 0 !== e.length ? (i = e.charAt(0).toLowerCase(), 1 < e.length && (i = i.concat(e.slice(1))), e = i) : e = void 0, t[e] = this.options
    }, f.prototype.remove = function(t) {
        if (t = void 0 === t || t, this.isOptionsInArray) {
            var e = this.parent.options[this.optionsName];
            r(e);
            var i = e.indexOf(this.options);
            0 <= i && e.splice(i, 1)
        } else delete this.parent.options[this.optionsName];
        t && (this.chart || this).render()
    }, f.prototype.updateOption = function(t) {
        !W[this._defaultsKey] && I && window.console && console.log("defaults not set");
        var e = W[this._defaultsKey],
            i = {},
            a = this[t],
            s = this._themeOptionsKey,
            n = this._index;
        return this.theme && l(s) && l(n) ? i = l(j[this.theme]) ? j.light1 : j[this.theme] : this.parent && this.parent.themeOptions && this.parent.themeOptions[s] && (null === n ? i = this.parent.themeOptions[s] : 0 < this.parent.themeOptions[s].length && (i = Math.min(this.parent.themeOptions[s].length - 1, n), i = this.parent.themeOptions[s][i])), this.themeOptions = i, t in e && (a = t in this.options ? this.options[t] : i && t in i ? i[t] : e[t]), a !== this[t] && (this[t] = a, !0)
    }, f.prototype.trackChanges = function(t) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        this.sessionVariables[t] = this.options[t]
    }, f.prototype.isBeingTracked = function(t) {
        return this.options._oldOptions || (this.options._oldOptions = {}), !!this.options._oldOptions[t]
    }, f.prototype.hasOptionChanged = function(t) {
        if (!this.sessionVariables) throw "Session Variable Store not set";
        return this.sessionVariables[t] !== this.options[t]
    }, f.prototype.addEventListener = function(t, e, i) {
        t && e && (this._eventListeners[t] = this._eventListeners[t] || [], this._eventListeners[t].push({
            context: i || this,
            eventHandler: e
        }))
    }, f.prototype.removeEventListener = function(t, e) {
        if (t && e && this._eventListeners[t])
            for (var i = this._eventListeners[t], a = 0; a < i.length; a++)
                if (i[a].eventHandler === e) {
                    i[a].splice(a, 1);
                    break
                }
    }, f.prototype.removeAllEventListeners = function() {
        this._eventListeners = []
    }, f.prototype.dispatchEvent = function(t, e, i) {
        if (t && this._eventListeners[t]) {
            e = e || {};
            for (var a = this._eventListeners[t], s = 0; s < a.length; s++) a[s].eventHandler.call(a[s].context, e)
        }
        "function" == typeof this[t] && this[t].call(i || this.chart, e)
    }, k.prototype.registerSpace = function(t, e) {
        "top" === t ? this._topOccupied += e.height : "bottom" === t ? this._bottomOccupied += e.height : "left" === t ? this._leftOccupied += e.width : "right" === t && (this._rightOccupied += e.width)
    }, k.prototype.unRegisterSpace = function(t, e) {
        "top" === t ? this._topOccupied -= e.height : "bottom" === t ? this._bottomOccupied -= e.height : "left" === t ? this._leftOccupied -= e.width : "right" === t && (this._rightOccupied -= e.width)
    }, k.prototype.getFreeSpace = function() {
        return {
            x1: this._x1 + this._leftOccupied,
            y1: this._y1 + this._topOccupied,
            x2: this._x2 - this._rightOccupied,
            y2: this._y2 - this._bottomOccupied,
            width: this._x2 - this._x1 - this._rightOccupied - this._leftOccupied,
            height: this._y2 - this._y1 - this._bottomOccupied - this._topOccupied
        }
    }, k.prototype.reset = function() {
        this._rightOccupied = this._leftOccupied = this._bottomOccupied = this._topOccupied = this._padding
    }, t(M, f), M.prototype._initialize = function() {
        l(this.padding) || "object" != typeof this.padding ? this.topPadding = this.rightPadding = this.bottomPadding = this.leftPadding = 0 | Number(this.padding) : (this.topPadding = l(this.padding.top) ? 0 : 0 | Number(this.padding.top), this.rightPadding = l(this.padding.right) ? 0 : 0 | Number(this.padding.right), this.bottomPadding = l(this.padding.bottom) ? 0 : 0 | Number(this.padding.bottom), this.leftPadding = l(this.padding.left) ? 0 : 0 | Number(this.padding.left))
    }, M.prototype.render = function(t) {
        if (0 !== this.fontSize) {
            t && this.ctx.save();
            var e = this.ctx.font;
            this.ctx.textBaseline = this.textBaseline;
            var i = 0;
            this._isDirty && this.measureText(this.ctx), this.ctx.translate(this.x, this.y + i), "middle" === this.textBaseline && (i = -this._lineHeight / 2), this.ctx.font = this._getFontString(), this.ctx.rotate(Math.PI / 180 * this.angle);
            var a = 0,
                n = this.topPadding,
                o = null;
            for (this.ctx.roundRect || s(this.ctx), (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(0, i, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor), this.ctx.fillStyle = this.fontColor, i = 0; i < this._wrappedText.lines.length; i++) o = this._wrappedText.lines[i], "right" === this.horizontalAlign ? a = (this.width - (this.leftPadding + this.rightPadding)) / 2 - o.width / 2 + this.leftPadding : "left" === this.horizontalAlign ? a = this.leftPadding : "center" === this.horizontalAlign && (a = (this.width - (this.leftPadding + this.rightPadding)) / 2 - o.width / 2 + this.leftPadding), this.ctx.fillText(o.text, a, n), n += o.height;
            this.ctx.font = e, t && this.ctx.restore()
        }
    }, M.prototype.setText = function(t) {
        this.text = t, this._isDirty = !0, this._wrappedText = null
    }, M.prototype.measureText = function() {
        if (this._lineHeight = h(this.fontFamily, this.fontSize, this.fontWeight), null === this.maxWidth) throw "Please set maxWidth and height for TextBlock";
        return this._wrapText(this.ctx), this._isDirty = !1, {
            width: this.width,
            height: this.height
        }
    }, M.prototype._getLineWithWidth = function(t, e, i) {
        if (!(t = String(t))) return {
            text: "",
            width: 0
        };
        var a = i = 0,
            s = t.length - 1,
            n = 1 / 0;
        for (this.ctx.font = this._getFontString(); a <= s;) {
            n = Math.floor((a + s) / 2);
            var o = t.substr(0, n + 1);
            if ((i = this.ctx.measureText(o).width) < e) a = n + 1;
            else {
                if (!(i > e)) break;
                s = n - 1
            }
        }
        return i > e && 1 < o.length && (o = o.substr(0, o.length - 1), i = this.ctx.measureText(o).width), e = !0, o.length !== t.length && " " !== t[o.length] || (e = !1), e && (1 < (t = o.split(" ")).length && t.pop(), o = t.join(" "), i = this.ctx.measureText(o).width), {
            text: o,
            width: i
        }
    }, M.prototype._wrapText = function() {
        var t = new String(a(String(this.text))),
            e = [],
            i = this.ctx.font,
            s = 0,
            n = 0;
        if (this.ctx.font = this._getFontString(), 0 === this.frontSize) n = s = 0;
        else
            for (; 0 < t.length;) {
                var o = this.maxHeight - (this.topPadding + this.bottomPadding),
                    l = this._getLineWithWidth(t, this.maxWidth - (this.leftPadding + this.rightPadding), !1);
                l.height = this._lineHeight, e.push(l);
                var r = n;
                n = Math.max(n, l.width), s = s + l.height, t = a(t.slice(l.text.length, t.length));
                o && s > o && (s -= (l = e.pop()).height, n = r)
            }
        this._wrappedText = {
            lines: e,
            width: n,
            height: s
        }, this.width = n + (this.leftPadding + this.rightPadding), this.height = s + (this.topPadding + this.bottomPadding), this.ctx.font = i
    }, M.prototype._getFontString = function() {
        var t;
        t = this.fontStyle ? this.fontStyle + " " : "", t += this.fontWeight ? this.fontWeight + " " : "", t += this.fontSize ? this.fontSize + "px " : "";
        var e = this.fontFamily ? this.fontFamily + "" : "";
        return !D && e && ("'" !== (e = e.split(",")[0])[0] && '"' !== e[0] && (e = "'" + e + "'")), t + e
    }, t(T, f), t(P, f), P.prototype.setLayout = function() {
        if (this.text) {
            var t, e, i, a = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,
                s = a.layoutManager.getFreeSpace(),
                n = s.x1,
                o = s.y1,
                r = 0,
                h = 0,
                d = this.chart._menuButton && this.chart.exportEnabled && "top" === this.verticalAlign ? 22 : 0;
            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (null === this.maxWidth && (this.maxWidth = s.width - 4 - d * ("center" === this.horizontalAlign ? 2 : 1)), h = .5 * s.height - this.margin - 2, r = 0) : "center" === this.verticalAlign && ("left" === this.horizontalAlign || "right" === this.horizontalAlign ? (null === this.maxWidth && (this.maxWidth = s.height - 4), h = .5 * s.width - this.margin - 2) : "center" === this.horizontalAlign && (null === this.maxWidth && (this.maxWidth = s.width - 4), h = .5 * s.height - 4)), l(this.padding) || "number" != typeof this.padding ? l(this.padding) || "object" != typeof this.padding || (i = this.padding.top ? this.padding.top : this.padding.bottom ? this.padding.bottom : 0, i += this.padding.bottom ? this.padding.bottom : this.padding.top ? this.padding.top : 0, i *= 1.25) : i = 2.5 * this.padding, this.wrap || (h = Math.min(h, Math.max(1.5 * this.fontSize, this.fontSize + i))), i = (h = new M(this.ctx, {
                fontSize: this.fontSize,
                fontFamily: this.fontFamily,
                fontColor: this.fontColor,
                fontStyle: this.fontStyle,
                fontWeight: this.fontWeight,
                horizontalAlign: this.horizontalAlign,
                verticalAlign: this.verticalAlign,
                borderColor: this.borderColor,
                borderThickness: this.borderThickness,
                backgroundColor: this.backgroundColor,
                maxWidth: this.maxWidth,
                maxHeight: h,
                cornerRadius: this.cornerRadius,
                text: this.text,
                padding: this.padding,
                textBaseline: "top"
            })).measureText(), "top" === this.verticalAlign || "bottom" === this.verticalAlign ? ("top" === this.verticalAlign ? (o = s.y1 + 2, e = "top") : "bottom" === this.verticalAlign && (o = s.y2 - 2 - i.height, e = "bottom"), "left" === this.horizontalAlign ? n = s.x1 + 2 : "center" === this.horizontalAlign ? n = s.x1 + s.width / 2 - i.width / 2 : "right" === this.horizontalAlign && (n = s.x2 - 2 - i.width - d), t = this.horizontalAlign, this.width = i.width, this.height = i.height) : "center" === this.verticalAlign && ("left" === this.horizontalAlign ? (n = s.x1 + 2, o = s.y2 - 2 - (this.maxWidth / 2 - i.width / 2), r = -90, e = "left", this.width = i.height, this.height = i.width) : "right" === this.horizontalAlign ? (n = s.x2 - 2, o = s.y1 + 2 + (this.maxWidth / 2 - i.width / 2), r = 90, e = "right", this.width = i.height, this.height = i.width) : "center" === this.horizontalAlign && (o = a.y1 + (a.height / 2 - i.height / 2), n = a.x1 + (a.width / 2 - i.width / 2), e = "center", this.width = i.width, this.height = i.height), t = "center"), h.x = n, h.y = o, h.angle = r, h.horizontalAlign = t, this._textBlock = h, a.layoutManager.registerSpace(e, {
                width: this.width + ("left" === e || "right" === e ? this.margin + 2 : 0),
                height: this.height + ("top" === e || "bottom" === e ? this.margin + 2 : 0)
            }), this.bounds = {
                x1: n,
                y1: o,
                x2: n + this.width,
                y2: o + this.height
            }, this.ctx.textBaseline = "top"
        }
    }, P.prototype.render = function() {
        this._textBlock && this._textBlock.render(!0)
    }, t(w, f), w.prototype.setLayout = P.prototype.setLayout, w.prototype.render = P.prototype.render, C.prototype.get = function(t, e) {
        var i = null;
        return 0 < this.pool.length ? u(i = this.pool.pop(), t, e) : i = m(t, e), i
    }, C.prototype.release = function(t) {
        this.pool.push(t)
    }, t(S, f);
    var lt = {
        addTheme: function(t, e) {
            j[t] = e
        },
        addColorSet: function(t, e) {
            E[t] = e
        },
        addCultureInfo: function(t, e) {
            z[t] = e
        },
        formatNumber: function(t, e, i) {
            if (z[i = i || "en"]) return Z(t, e || "#,##0.##", new S(i));
            throw "Unknown Culture Name"
        },
        formatDate: function(t, e, i) {
            if (z[i = i || "en"]) return Q(t, e || "DD MMM YYYY", new S(i));
            throw "Unknown Culture Name"
        }
    };
    "undefined" != typeof module && void 0 !== module.exports ? module.exports = lt : "function" == typeof define && define.amd ? define([], function() {
        return lt
    }) : window.CanvasJS = lt, lt.Chart = function() {
        function i(t, e) {
            return t.x - e.x
        }

        function o(t, e) {
            e = e || {}, this.theme = l(e.theme) || l(j[e.theme]) ? "light1" : e.theme, o.base.constructor.call(this, "Chart", null, e, null, null);
            var i = this;
            if (this._containerId = t, this._objectsInitialized = !1, this.overlaidCanvasCtx = this.ctx = null, this._indexLabels = [], this._panTimerId = 0, this._lastTouchEventType = "", this._lastTouchData = null, this.isAnimating = !1, this.renderCount = 0, this.disableToolTip = this.animatedRender = !1, this.canvasPool = new C, this.allDOMEventHandlers = [], this.panEnabled = !1, this._defaultCursor = "default", this.plotArea = {
                    canvas: null,
                    ctx: null,
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    width: 0,
                    height: 0
                }, this._dataInRenderedOrder = [], this.container = "string" == typeof this._containerId ? document.getElementById(this._containerId) : this._containerId) {
                this.container.innerHTML = "";
                var a = this.options.width ? this.width : 0 < this.container.clientWidth ? this.container.clientWidth : this.width,
                    n = this.options.height ? this.height : 0 < this.container.clientHeight ? this.container.clientHeight : this.height;
                this.width = a, this.height = n, this.x1 = this.y1 = 0, this.x2 = this.width, this.y2 = this.height, this._selectedColorSet = void 0 !== E[this.colorSet] ? E[this.colorSet] : E.colorSet1, this._canvasJSContainer = document.createElement("div"), this._canvasJSContainer.setAttribute("class", "canvasjs-chart-container"), this._canvasJSContainer.style.position = "relative", this._canvasJSContainer.style.textAlign = "left", this._canvasJSContainer.style.cursor = "auto", D || (this._canvasJSContainer.style.height = "0px"), this.container.appendChild(this._canvasJSContainer), this.canvas = m(a, n), this._preRenderCanvas = m(a, n), this.canvas.style.position = "absolute", this.canvas.style.WebkitUserSelect = "none", this.canvas.style.MozUserSelect = "none", this.canvas.style.msUserSelect = "none", this.canvas.style.userSelect = "none", this.canvas.getContext && (this._canvasJSContainer.appendChild(this.canvas), this.ctx = this.canvas.getContext("2d"), this.ctx.textBaseline = "top", s(this.ctx), this._preRenderCtx = this._preRenderCanvas.getContext("2d"), this._preRenderCtx.textBaseline = "top", s(this._preRenderCtx), D ? this.plotArea.ctx = this.ctx : (this.plotArea.canvas = m(a, n), this.plotArea.canvas.style.position = "absolute", this.plotArea.canvas.setAttribute("class", "plotAreaCanvas"), this._canvasJSContainer.appendChild(this.plotArea.canvas), this.plotArea.ctx = this.plotArea.canvas.getContext("2d")), this.overlaidCanvas = m(a, n), this.overlaidCanvas.style.position = "absolute", this.overlaidCanvas.style.webkitTapHighlightColor = "transparent", this.overlaidCanvas.style.WebkitUserSelect = "none", this.overlaidCanvas.style.MozUserSelect = "none", this.overlaidCanvas.style.msUserSelect = "none", this.overlaidCanvas.style.userSelect = "none", this.overlaidCanvas.getContext && (this._canvasJSContainer.appendChild(this.overlaidCanvas), this.overlaidCanvasCtx = this.overlaidCanvas.getContext("2d"), this.overlaidCanvasCtx.textBaseline = "top", s(this.overlaidCanvasCtx)), this._eventManager = new N(this), this.windowResizeHandler = x(window, "resize", function() {
                    i._updateSize() && i.render()
                }, this.allDOMEventHandlers), this._toolBar = document.createElement("div"), this._toolBar.setAttribute("class", "canvasjs-chart-toolbar"), this._toolBar.style.cssText = "position: absolute; right: 1px; top: 1px;", this._canvasJSContainer.appendChild(this._toolBar), this.bounds = {
                    x1: 0,
                    y1: 0,
                    x2: this.width,
                    y2: this.height
                }, x(this.overlaidCanvas, "click", function(t) {
                    i._mouseEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, "mousemove", function(t) {
                    i._mouseEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, "mouseup", function(t) {
                    i._mouseEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, "mousedown", function(t) {
                    i._mouseEventHandler(t), v(i._dropdownMenu)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, "mouseout", function(t) {
                    i._mouseEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerDown" : "touchstart", function(t) {
                    i._touchEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerMove" : "touchmove", function(t) {
                    i._touchEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerUp" : "touchend", function(t) {
                    i._touchEventHandler(t)
                }, this.allDOMEventHandlers), x(this.overlaidCanvas, window.navigator.msPointerEnabled ? "MSPointerCancel" : "touchcancel", function(t) {
                    i._touchEventHandler(t)
                }, this.allDOMEventHandlers), this.toolTip = new R(this, this.options.toolTip), this.data = null, this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this.sessionVariables = {
                    axisX: [],
                    axisX2: [],
                    axisY: [],
                    axisY2: []
                })
            } else window.console && window.console.log('CanvasJS Error: Chart Container with id "' + this._containerId + '" was not found')
        }

        function _(t, e) {
            for (var i, a = [], s = 0; s < t.length; s++)
                if (0 == s) a.push(t[0]);
                else {
                    var n, o, l;
                    n = 0 === (l = s - 1) ? 0 : l - 1, o = l === t.length - 1 ? l : l + 1, i = Math.abs((t[o].x - t[n].x) / (0 == t[o].x - t[l].x ? .01 : t[o].x - t[l].x)) * (e - 1) / 2 + 1;
                    var r = (t[o].x - t[n].x) / i;
                    i = (t[o].y - t[n].y) / i, a[a.length] = t[l].x > t[n].x && 0 < r || t[l].x < t[n].x && 0 > r ? {
                        x: t[l].x + r / 3,
                        y: t[l].y + i / 3
                    } : {
                        x: t[l].x,
                        y: t[l].y + i / 9
                    }, n = 0 === (l = s) ? 0 : l - 1, o = l === t.length - 1 ? l : l + 1, i = Math.abs((t[o].x - t[n].x) / (0 == t[l].x - t[n].x ? .01 : t[l].x - t[n].x)) * (e - 1) / 2 + 1, r = (t[o].x - t[n].x) / i, i = (t[o].y - t[n].y) / i, a[a.length] = t[l].x > t[n].x && 0 < r || t[l].x < t[n].x && 0 > r ? {
                        x: t[l].x - r / 3,
                        y: t[l].y - i / 3
                    } : {
                        x: t[l].x,
                        y: t[l].y - i / 9
                    }, a[a.length] = t[s]
                }
            return a
        }

        function B(t, e, i, a, s, n, o, l, r, h) {
            var x = 0;
            h ? (o.color = n, l.color = n) : h = 1, x = r ? Math.abs(s - i) : Math.abs(a - e), x = 0 < o.trimLength ? Math.abs(x * o.trimLength / 100) : Math.abs(x - o.length), r ? (i += x / 2, s -= x / 2) : (e += x / 2, a -= x / 2);
            x = 1 == Math.round(o.thickness) % 2 ? .5 : 0;
            var c = 1 == Math.round(l.thickness) % 2 ? .5 : 0;
            t.save(), t.globalAlpha = h, t.strokeStyle = l.color || n, t.lineWidth = l.thickness || 2, t.setLineDash && t.setLineDash(d(l.dashType, l.thickness)), t.beginPath(), r && 0 < l.thickness ? (t.moveTo(a - o.thickness / 2, Math.round((i + s) / 2) - c), t.lineTo(e + o.thickness / 2, Math.round((i + s) / 2) - c)) : 0 < l.thickness && (t.moveTo(Math.round((e + a) / 2) - c, i + o.thickness / 2), t.lineTo(Math.round((e + a) / 2) - c, s - o.thickness / 2)), t.stroke(), t.strokeStyle = o.color || n, t.lineWidth = o.thickness || 2, t.setLineDash && t.setLineDash(d(o.dashType, o.thickness)), t.beginPath(), r && 0 < o.thickness ? (t.moveTo(a - x, i), t.lineTo(a - x, s), t.moveTo(e + x, i), t.lineTo(e + x, s)) : 0 < o.thickness && (t.moveTo(e, i + x), t.lineTo(a, i + x), t.moveTo(e, s - x), t.lineTo(a, s - x)), t.stroke(), t.restore()
        }

        function F(t, e, i, a, s) {
            return null == t ? void 0 === i ? e : i : (t = parseFloat(t.toString()) * (0 <= t.toString().indexOf("%") ? e / 100 : 1), void 0 !== a && (t = Math.min(a, t), void 0 !== s && (t = Math.max(s, t))), !isNaN(t) && t <= e && 0 <= t ? t : void 0 === i ? e : i)
        }

        function A(t, e) {
            A.base.constructor.call(this, "Legend", "legend", e, null, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.ghostCtx = this.chart._eventManager.ghostCtx, this.items = [], this.optionsName = "legend", this.height = this.width = 0, this.orientation = null, this.dataSeries = [], this.bounds = {
                x1: null,
                y1: null,
                x2: null,
                y2: null
            }, void 0 === this.options.fontSize && (this.fontSize = this.chart.getAutoFontSize(this.fontSize)), this.lineHeight = h(this.fontFamily, this.fontSize, this.fontWeight), this.horizontalSpacing = this.fontSize
        }

        function L(t, e, i, a) {
            for (L.base.constructor.call(this, "DataSeries", "data", e, i, t), this.chart = t, this.canvas = t.canvas, this._ctx = t.canvas.ctx, this.index = i, this.noDataPointsInPlotArea = 0, this.id = a, this.chart._eventManager.objectMap[a] = {
                    id: a,
                    objectType: "dataSeries",
                    dataSeriesIndex: i
                }, t = e.dataPoints ? e.dataPoints.length : 0, this.dataPointEOs = [], e = 0; e < t; e++) this.dataPointEOs[e] = {};
            this.dataPointIds = [], this.plotUnit = [], this.axisY = this.axisX = null, this.optionsName = "data", this.isOptionsInArray = !0, null === this.fillOpacity && (this.type.match(/area/i) ? this.fillOpacity = .7 : this.fillOpacity = 1), this.axisPlacement = this.getDefaultAxisPlacement(), void 0 === this.options.indexLabelFontSize && (this.indexLabelFontSize = this.chart.getAutoFontSize(this.indexLabelFontSize))
        }

        function W(t, e, i, a, s, n) {
            if (W.base.constructor.call(this, "Axis", e, i, a, t), this.chart = t, this.canvas = t.canvas, this.ctx = t.ctx, this.intervalStartPosition = this.maxHeight = this.maxWidth = 0, this.labels = [], this.dataSeries = [], this._stripLineLabels = this._ticks = this._labels = null, this.dataInfo = {
                    min: 1 / 0,
                    max: -1 / 0,
                    viewPortMin: 1 / 0,
                    viewPortMax: -1 / 0,
                    minDiff: 1 / 0
                }, this.isOptionsInArray = !0, "axisX" === s ? ("left" === n || "bottom" === n ? (this.optionsName = "axisX", l(this.chart.sessionVariables.axisX[a]) && (this.chart.sessionVariables.axisX[a] = {}), this.sessionVariables = this.chart.sessionVariables.axisX[a]) : (this.optionsName = "axisX2", l(this.chart.sessionVariables.axisX2[a]) && (this.chart.sessionVariables.axisX2[a] = {}), this.sessionVariables = this.chart.sessionVariables.axisX2[a]), this.options.interval || (this.intervalType = null)) : "left" === n || "bottom" === n ? (this.optionsName = "axisY", l(this.chart.sessionVariables.axisY[a]) && (this.chart.sessionVariables.axisY[a] = {}), this.sessionVariables = this.chart.sessionVariables.axisY[a]) : (this.optionsName = "axisY2", l(this.chart.sessionVariables.axisY2[a]) && (this.chart.sessionVariables.axisY2[a] = {}), this.sessionVariables = this.chart.sessionVariables.axisY2[a]), void 0 === this.options.titleFontSize && (this.titleFontSize = this.chart.getAutoFontSize(this.titleFontSize)), void 0 === this.options.labelFontSize && (this.labelFontSize = this.chart.getAutoFontSize(this.labelFontSize)), this.type = s, "axisX" !== s || i && void 0 !== i.gridThickness || (this.gridThickness = 0), this._position = n, this.lineCoordinates = {
                    x1: null,
                    y1: null,
                    x2: null,
                    y2: null,
                    width: null
                }, this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360), this.options.scaleBreaks && (this.scaleBreaks = new z(this.chart, this.options.scaleBreaks, ++this.chart._eventManager.lastObjectId, this)), this.stripLines = [], this.options.stripLines && 0 < this.options.stripLines.length)
                for (t = 0; t < this.options.stripLines.length; t++) this.stripLines.push(new Y(this.chart, this.options.stripLines[t], t, ++this.chart._eventManager.lastObjectId, this));
            this.options.crosshair && (this.crosshair = new O(this.chart, this.options.crosshair, this)), this._titleTextBlock = null, this.hasOptionChanged("viewportMinimum") && null === this.viewportMinimum && (this.options.viewportMinimum = void 0, this.sessionVariables.viewportMinimum = null), this.hasOptionChanged("viewportMinimum") || isNaN(this.sessionVariables.newViewportMinimum) || null === this.sessionVariables.newViewportMinimum ? this.sessionVariables.newViewportMinimum = null : this.viewportMinimum = this.sessionVariables.newViewportMinimum, this.hasOptionChanged("viewportMaximum") && null === this.viewportMaximum && (this.options.viewportMaximum = void 0, this.sessionVariables.viewportMaximum = null), this.hasOptionChanged("viewportMaximum") || isNaN(this.sessionVariables.newViewportMaximum) || null === this.sessionVariables.newViewportMaximum ? this.sessionVariables.newViewportMaximum = null : this.viewportMaximum = this.sessionVariables.newViewportMaximum, null !== this.minimum && null !== this.viewportMinimum && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)), null !== this.maximum && null !== this.viewportMaximum && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)), this.trackChanges("viewportMinimum"), this.trackChanges("viewportMaximum")
        }

        function z(t, e, i, a) {
            if (z.base.constructor.call(this, "ScaleBreaks", "scaleBreaks", e, null, a), this.id = i, this.chart = t, this.ctx = this.chart.ctx, this.axis = a, this.optionsName = "scaleBreaks", this.isOptionsInArray = !1, this._appliedBreaks = [], this.customBreaks = [], this.autoBreaks = [], "string" == typeof this.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 8 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" != typeof this.spacing && (this.spacing = 8), this.autoCalculate && (this.maxNumberOfAutoBreaks = Math.min(this.maxNumberOfAutoBreaks, 5)), this.options.customBreaks && 0 < this.options.customBreaks.length) {
                for (t = 0; t < this.options.customBreaks.length; t++) this.customBreaks.push(new X(this.chart, "customBreaks", this.options.customBreaks[t], t, ++this.chart._eventManager.lastObjectId, this)), "number" == typeof this.customBreaks[t].startValue && "number" == typeof this.customBreaks[t].endValue && this.customBreaks[t].endValue !== this.customBreaks[t].startValue && this._appliedBreaks.push(this.customBreaks[t]);
                for (this._appliedBreaks.sort(function(t, e) {
                        return t.startValue - e.startValue
                    }), t = 0; t < this._appliedBreaks.length - 1; t++) this._appliedBreaks[t].endValue >= this._appliedBreaks[t + 1].startValue && (this._appliedBreaks[t].endValue = Math.max(this._appliedBreaks[t].endValue, this._appliedBreaks[t + 1].endValue), window.console && window.console.log("CanvasJS Error: Breaks " + t + " and " + (t + 1) + " are overlapping."), this._appliedBreaks.splice(t, 2), t--)
            }
        }

        function X(t, e, i, a, s, n) {
            X.base.constructor.call(this, "Break", e, i, a, n), this.id = s, this.chart = t, this.ctx = this.chart.ctx, this.scaleBreaks = n, this.optionsName = e, this.isOptionsInArray = !0, this.type = i.type ? this.type : n.type, this.fillOpacity = l(i.fillOpacity) ? n.fillOpacity : this.fillOpacity, this.lineThickness = l(i.lineThickness) ? n.lineThickness : this.lineThickness, this.color = i.color ? this.color : n.color, this.lineColor = i.lineColor ? this.lineColor : n.lineColor, this.lineDashType = i.lineDashType ? this.lineDashType : n.lineDashType, !l(this.startValue) && this.startValue.getTime && (this.startValue = this.startValue.getTime()), !l(this.endValue) && this.endValue.getTime && (this.endValue = this.endValue.getTime()), "number" == typeof this.startValue && "number" == typeof this.endValue && this.endValue < this.startValue && (t = this.startValue, this.startValue = this.endValue, this.endValue = t), this.spacing = void 0 === i.spacing ? n.spacing : i.spacing, "string" == typeof this.options.spacing ? (this.spacing = parseFloat(this.spacing), this.spacing = isNaN(this.spacing) ? 0 : (10 < this.spacing ? 10 : this.spacing) + "%") : "number" != typeof this.options.spacing && (this.spacing = n.spacing), this.size = n.parent.logarithmic ? 1 : 0
        }

        function Y(t, e, i, a, s) {
            Y.base.constructor.call(this, "StripLine", "stripLines", e, i, s), this.id = a, this.chart = t, this.ctx = this.chart.ctx, this.label = this.label, this.axis = s, this.optionsName = "stripLines", this.isOptionsInArray = !0, this._thicknessType = "pixel", null !== this.startValue && null !== this.endValue && (this.value = s.logarithmic ? Math.sqrt((this.startValue.getTime ? this.startValue.getTime() : this.startValue) * (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) : ((this.startValue.getTime ? this.startValue.getTime() : this.startValue) + (this.endValue.getTime ? this.endValue.getTime() : this.endValue)) / 2, this._thicknessType = null)
        }

        function O(t, e, i) {
            O.base.constructor.call(this, "Crosshair", "crosshair", e, null, i), this.chart = t, this.ctx = this.chart.ctx, this.axis = i, this.optionsName = "crosshair", this._thicknessType = "pixel"
        }

        function R(t, e) {
            R.base.constructor.call(this, "ToolTip", "toolTip", e, null, t), this.chart = t, this.canvas = t.canvas, this.ctx = this.chart.ctx, this.currentDataPointIndex = this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, this.containerTransitionDuration = .1, this.mozContainerTransition = this.getContainerTransition(this.containerTransitionDuration), this.optionsName = "toolTip", this._initialize()
        }

        function N(t) {
            this.chart = t, this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.ghostCanvas = m(this.chart.width, this.chart.height), this.ghostCtx = this.ghostCanvas.getContext("2d"), this.mouseoveredObjectMaps = []
        }

        function H(t) {
            this.chart = t, this.ctx = this.chart.plotArea.ctx, this.animations = [], this.animationRequestId = null
        }
        t(o, f), o.prototype.destroy = function() {
            var t = this.allDOMEventHandlers;
            this._animator && this._animator.cancelAllAnimations(), this._panTimerId && clearTimeout(this._panTimerId);
            for (var e = 0; e < t.length; e++) {
                var i = t[e][0],
                    a = t[e][1],
                    s = t[e][2],
                    n = (n = t[e][3]) || !1;
                i.removeEventListener ? i.removeEventListener(a, s, n) : i.detachEvent && i.detachEvent("on" + a, s)
            }
            for (this.allDOMEventHandlers = [], this.removeAllEventListeners(); this._canvasJSContainer && this._canvasJSContainer.hasChildNodes();) this._canvasJSContainer.removeChild(this._canvasJSContainer.lastChild);
            for (; this.container && this.container.hasChildNodes();) this.container.removeChild(this.container.lastChild);
            for (; this._dropdownMenu && this._dropdownMenu.hasChildNodes();) this._dropdownMenu.removeChild(this._dropdownMenu.lastChild);
            this.overlaidCanvas = this.canvas = this.container = this._canvasJSContainer = null, this._toolBar = this._dropdownMenu = this._menuButton = this._resetButton = this._zoomButton = this._breaksCanvas = this._preRenderCanvas = this.toolTip.container = null
        }, o.prototype._updateOptions = function() {
            var t = this;
            if (this.updateOption("width"), this.updateOption("height"), this.updateOption("dataPointWidth"), this.updateOption("dataPointMinWidth"), this.updateOption("dataPointMaxWidth"), this.updateOption("interactivityEnabled"), this.updateOption("theme"), this.updateOption("colorSet") && (this._selectedColorSet = void 0 !== E[this.colorSet] ? E[this.colorSet] : E.colorSet1), this.updateOption("backgroundColor"), this.backgroundColor || (this.backgroundColor = "rgba(0,0,0,0)"), this.updateOption("culture"), this._cultureInfo = new S(this.options.culture), this.updateOption("animationEnabled"), this.animationEnabled = this.animationEnabled && D, this.updateOption("animationDuration"), this.updateOption("rangeChanging"), this.updateOption("rangeChanged"), this.updateOption("exportEnabled"), this.updateOption("exportFileName"), this.updateOption("zoomType"), this.options.zoomEnabled) {
                if (!this._zoomButton) {
                    var e = !1;
                    v(this._zoomButton = document.createElement("button")), b(this, this._zoomButton), this._toolBar.appendChild(this._zoomButton), this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, x(this._zoomButton, "touchstart", function(t) {
                        e = !0
                    }, this.allDOMEventHandlers), x(this._zoomButton, "click", function() {
                        t.zoomEnabled ? (t.zoomEnabled = !1, t.panEnabled = !0, b(t, t._zoomButton)) : (t.zoomEnabled = !0, t.panEnabled = !1, b(t, t._zoomButton)), t.render()
                    }, this.allDOMEventHandlers), x(this._zoomButton, "mouseover", function() {
                        e ? e = !1 : (g(0, t._zoomButton, {
                            backgroundColor: t.toolbar.backgroundColorOnHover,
                            color: t.toolbar.fontColorOnHover,
                            transition: "0.4s",
                            WebkitTransition: "0.4s"
                        }), 0 >= navigator.userAgent.search("MSIE") && g(0, t._zoomButton.childNodes[0], {
                            WebkitFilter: "invert(100%)",
                            filter: "invert(100%)"
                        }))
                    }, this.allDOMEventHandlers), x(this._zoomButton, "mouseout", function() {
                        e || (g(0, t._zoomButton, {
                            backgroundColor: t.toolbar.backgroundColor,
                            color: t.toolbar.fontColor,
                            transition: "0.4s",
                            WebkitTransition: "0.4s"
                        }), 0 >= navigator.userAgent.search("MSIE") && g(0, t._zoomButton.childNodes[0], {
                            WebkitFilter: "invert(0%)",
                            filter: "invert(0%)"
                        }))
                    }, this.allDOMEventHandlers)
                }
                this._resetButton || (e = !1, v(this._resetButton = document.createElement("button")), b(this, this._resetButton), this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor, this._toolBar.appendChild(this._resetButton), x(this._resetButton, "touchstart", function(t) {
                    e = !0
                }, this.allDOMEventHandlers), x(this._resetButton, "click", function() {
                    if (t.toolTip.hide(), t.zoomEnabled || t.panEnabled ? (t.zoomEnabled = !0, t.panEnabled = !1, b(t, t._zoomButton), t._defaultCursor = "default", t.overlaidCanvas.style.cursor = t._defaultCursor) : (t.zoomEnabled = !1, t.panEnabled = !1), t.sessionVariables.axisX)
                        for (var e = 0; e < t.sessionVariables.axisX.length; e++) t.sessionVariables.axisX[e].newViewportMinimum = null, t.sessionVariables.axisX[e].newViewportMaximum = null;
                    if (t.sessionVariables.axisX2)
                        for (e = 0; e < t.sessionVariables.axisX2.length; e++) t.sessionVariables.axisX2[e].newViewportMinimum = null, t.sessionVariables.axisX2[e].newViewportMaximum = null;
                    if (t.sessionVariables.axisY)
                        for (e = 0; e < t.sessionVariables.axisY.length; e++) t.sessionVariables.axisY[e].newViewportMinimum = null, t.sessionVariables.axisY[e].newViewportMaximum = null;
                    if (t.sessionVariables.axisY2)
                        for (e = 0; e < t.sessionVariables.axisY2.length; e++) t.sessionVariables.axisY2[e].newViewportMinimum = null, t.sessionVariables.axisY2[e].newViewportMaximum = null;
                    t.resetOverlayedCanvas(), v(t._zoomButton, t._resetButton), t._dispatchRangeEvent("rangeChanging", "reset"), t.render(), t._dispatchRangeEvent("rangeChanged", "reset"), t.syncCharts && t.syncCharts(null, null)
                }, this.allDOMEventHandlers), x(this._resetButton, "mouseover", function() {
                    e || (g(0, t._resetButton, {
                        backgroundColor: t.toolbar.backgroundColorOnHover,
                        color: t.toolbar.hoverFfontColorOnHoverontColor,
                        transition: "0.4s",
                        WebkitTransition: "0.4s"
                    }), 0 >= navigator.userAgent.search("MSIE") && g(0, t._resetButton.childNodes[0], {
                        WebkitFilter: "invert(100%)",
                        filter: "invert(100%)"
                    }))
                }, this.allDOMEventHandlers), x(this._resetButton, "mouseout", function() {
                    e || (g(0, t._resetButton, {
                        backgroundColor: t.toolbar.backgroundColor,
                        color: t.toolbar.fontColor,
                        transition: "0.4s",
                        WebkitTransition: "0.4s"
                    }), 0 >= navigator.userAgent.search("MSIE") && g(0, t._resetButton.childNodes[0], {
                        WebkitFilter: "invert(0%)",
                        filter: "invert(0%)"
                    }))
                }, this.allDOMEventHandlers), this.overlaidCanvas.style.cursor = t._defaultCursor), this.zoomEnabled || this.panEnabled || (this._zoomButton ? (t._zoomButton.getAttribute("state") === t._cultureInfo.zoomText ? (this.panEnabled = !0, this.zoomEnabled = !1) : (this.zoomEnabled = !0, this.panEnabled = !1), y(t._zoomButton, t._resetButton)) : (this.zoomEnabled = !0, this.panEnabled = !1))
            } else this.panEnabled = this.zoomEnabled = !1;
            if (this._menuButton ? this.exportEnabled ? y(this._menuButton) : v(this._menuButton) : this.exportEnabled && D && (e = !1, this._menuButton = document.createElement("button"), b(this, this._menuButton), this._toolBar.appendChild(this._menuButton), x(this._menuButton, "touchstart", function(t) {
                    e = !0
                }, this.allDOMEventHandlers), x(this._menuButton, "click", function() {
                    "none" !== t._dropdownMenu.style.display || t._dropDownCloseTime && 500 >= (new Date).getTime() - t._dropDownCloseTime.getTime() || (t._dropdownMenu.style.display = "block", t._menuButton.blur(), t._dropdownMenu.focus())
                }, this.allDOMEventHandlers, !0), x(this._menuButton, "mouseover", function() {
                    e || (g(0, t._menuButton, {
                        backgroundColor: t.toolbar.backgroundColorOnHover,
                        color: t.toolbar.fontColorOnHover
                    }), 0 >= navigator.userAgent.search("MSIE") && g(0, t._menuButton.childNodes[0], {
                        WebkitFilter: "invert(100%)",
                        filter: "invert(100%)"
                    }))
                }, this.allDOMEventHandlers, !0), x(this._menuButton, "mouseout", function() {
                    e || (g(0, t._menuButton, {
                        backgroundColor: t.toolbar.backgroundColor,
                        color: t.toolbar.fontColor
                    }), 0 >= navigator.userAgent.search("MSIE") && g(0, t._menuButton.childNodes[0], {
                        WebkitFilter: "invert(0%)",
                        filter: "invert(0%)"
                    }))
                }, this.allDOMEventHandlers, !0)), !this._dropdownMenu && this.exportEnabled && D) {
                e = !1, this._dropdownMenu = document.createElement("div"), this._dropdownMenu.setAttribute("tabindex", -1);
                var i = -1 !== this.theme.indexOf("dark") ? "black" : "#888888";
                this._dropdownMenu.style.cssText = "position: absolute; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; cursor: pointer;right: 0px;top: 25px;min-width: 120px;outline: 0;font-size: 14px; font-family: Arial, Helvetica, sans-serif;padding: 5px 0px 5px 0px;text-align: left;line-height: 10px;background-color:" + this.toolbar.backgroundColor + ";box-shadow: 2px 2px 10px " + i, t._dropdownMenu.style.display = "none", this._toolBar.appendChild(this._dropdownMenu), x(this._dropdownMenu, "blur", function() {
                    v(t._dropdownMenu), t._dropDownCloseTime = new Date
                }, this.allDOMEventHandlers, !0), (i = document.createElement("div")).style.cssText = "padding: 12px 8px 12px 8px", i.innerHTML = this._cultureInfo.printText, i.style.backgroundColor = this.toolbar.backgroundColor, i.style.color = this.toolbar.fontColor, this._dropdownMenu.appendChild(i), x(i, "touchstart", function(t) {
                    e = !0
                }, this.allDOMEventHandlers), x(i, "mouseover", function() {
                    e || (this.style.backgroundColor = t.toolbar.backgroundColorOnHover, this.style.color = t.toolbar.fontColorOnHover)
                }, this.allDOMEventHandlers, !0), x(i, "mouseout", function() {
                    e || (this.style.backgroundColor = t.toolbar.backgroundColor, this.style.color = t.toolbar.fontColor)
                }, this.allDOMEventHandlers, !0), x(i, "click", function() {
                    t.print(), v(t._dropdownMenu)
                }, this.allDOMEventHandlers, !0), (i = document.createElement("div")).style.cssText = "padding: 12px 8px 12px 8px", i.innerHTML = this._cultureInfo.saveJPGText, i.style.backgroundColor = this.toolbar.backgroundColor, i.style.color = this.toolbar.fontColor, this._dropdownMenu.appendChild(i), x(i, "touchstart", function(t) {
                    e = !0
                }, this.allDOMEventHandlers), x(i, "mouseover", function() {
                    e || (this.style.backgroundColor = t.toolbar.backgroundColorOnHover, this.style.color = t.toolbar.fontColorOnHover)
                }, this.allDOMEventHandlers, !0), x(i, "mouseout", function() {
                    e || (this.style.backgroundColor = t.toolbar.backgroundColor, this.style.color = t.toolbar.fontColor)
                }, this.allDOMEventHandlers, !0), x(i, "click", function() {
                    t.canvas, t.exportFileName, v(t._dropdownMenu)
                }, this.allDOMEventHandlers, !0), (i = document.createElement("div")).style.cssText = "padding: 12px 8px 12px 8px", i.innerHTML = this._cultureInfo.savePNGText, i.style.backgroundColor = this.toolbar.backgroundColor, i.style.color = this.toolbar.fontColor, this._dropdownMenu.appendChild(i), x(i, "touchstart", function(t) {
                    e = !0
                }, this.allDOMEventHandlers), x(i, "mouseover", function() {
                    e || (this.style.backgroundColor = t.toolbar.backgroundColorOnHover, this.style.color = t.toolbar.fontColorOnHover)
                }, this.allDOMEventHandlers, !0), x(i, "mouseout", function() {
                    e || (this.style.backgroundColor = t.toolbar.backgroundColor, this.style.color = t.toolbar.fontColor)
                }, this.allDOMEventHandlers, !0), x(i, "click", function() {
                    t.canvas, t.exportFileName, v(t._dropdownMenu)
                }, this.allDOMEventHandlers, !0)
            }
            for (var a in "none" !== this._toolBar.style.display && this._zoomButton && (this.panEnabled, b(t, t._zoomButton), t._resetButton.getAttribute("state") !== t._cultureInfo.resetText && b(t, t._resetButton)), this.options.toolTip && this.toolTip.options !== this.options.toolTip && (this.toolTip.options = this.options.toolTip), this.toolTip.options) this.toolTip.options.hasOwnProperty(a) && this.toolTip.updateOption(a)
        }, o.prototype._updateSize = function() {
            var t;
            t = [this.canvas, this._preRenderCanvas, this.overlaidCanvas, this._eventManager.ghostCanvas];
            var e = 0,
                i = 0;
            if (this.options.width ? e = this.width : this.width = e = 0 < this.container.clientWidth ? this.container.clientWidth : this.width, this.options.height ? i = this.height : this.height = i = 0 < this.container.clientHeight ? this.container.clientHeight : this.height, this.canvas.width !== e * at || this.canvas.height !== i * at) {
                for (var a = 0; a < t.length; a++) u(t[a], e, i);
                t = !0
            } else t = !1;
            return t
        }, o.prototype._initialize = function() {
            this.isNavigator = !l(this.parent) && !l(this.parent._defaultsKey) && "Navigator" === this.parent._defaultsKey, this.toolbar = new T(this, this.options.toolbar), this._animator ? this._animator.cancelAllAnimations() : this._animator = new H(this), this.removeAllEventListeners(), this.disableToolTip = !1, this._axes = [], this.funnelPyramidClickHandler = this.pieDoughnutClickHandler = null, this._updateOptions(), this.animatedRender = D && this.animationEnabled && 0 === this.renderCount, this._updateSize(), this.clearCanvas(), this.ctx.beginPath(), this.axisX = [], this.axisX2 = [], this.axisY = [], this.axisY2 = [], this._indexLabels = [], this._dataInRenderedOrder = [], this._events = [], this._eventManager && this._eventManager.reset(), this.plotInfo = {
                axisPlacement: null,
                plotTypes: []
            }, this.layoutManager = new k(0, 0, this.width, this.height, this.isNavigator ? 0 : 2), this.plotArea.layoutManager && this.plotArea.layoutManager.reset(), this.data = [];
            var t = 0,
                e = null;
            if (this.options.data) {
                for (var a = 0; a < this.options.data.length; a++)
                    if (t++, !this.options.data[a].type || 0 <= o._supportedChartTypes.indexOf(this.options.data[a].type)) {
                        var s = new L(this, this.options.data[a], t - 1, ++this._eventManager.lastObjectId);
                        "error" === s.type && (s.linkedDataSeriesIndex = l(this.options.data[a].linkedDataSeriesIndex) ? a - 1 : this.options.data[a].linkedDataSeriesIndex, 0 > s.linkedDataSeriesIndex || s.linkedDataSeriesIndex >= this.options.data.length || "number" != typeof s.linkedDataSeriesIndex || "error" === this.options.data[s.linkedDataSeriesIndex].type) && (s.linkedDataSeriesIndex = null), null === s.name && (s.name = "DataSeries " + t), null === s.color ? 1 < this.options.data.length ? (s._colorSet = [this._selectedColorSet[s.index % this._selectedColorSet.length]], s.color = this._selectedColorSet[s.index % this._selectedColorSet.length]) : s._colorSet = "line" === s.type || "stepLine" === s.type || "spline" === s.type || "area" === s.type || "stepArea" === s.type || "splineArea" === s.type || "stackedArea" === s.type || "stackedArea100" === s.type || "rangeArea" === s.type || "rangeSplineArea" === s.type || "candlestick" === s.type || "ohlc" === s.type || "waterfall" === s.type || "boxAndWhisker" === s.type ? [this._selectedColorSet[0]] : this._selectedColorSet : s._colorSet = [s.color], null === s.markerSize && (("line" === s.type || "stepLine" === s.type || "spline" === s.type || 0 <= s.type.toLowerCase().indexOf("area")) && s.dataPoints && s.dataPoints.length < this.width / 16 || "scatter" === s.type) && (s.markerSize = 8), "bubble" !== s.type && "scatter" !== s.type || !s.dataPoints || (s.dataPoints.some ? s.dataPoints.some(function(t) {
                            return t.x
                        }) && s.dataPoints.sort(i) : s.dataPoints.sort(i)), this.data.push(s);
                        var n, r = s.axisPlacement;
                        e = e || r;
                        if ("normal" === r ? "xySwapped" === this.plotInfo.axisPlacement ? n = 'You cannot combine "' + s.type + '" with bar chart' : "none" === this.plotInfo.axisPlacement ? n = 'You cannot combine "' + s.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "normal") : "xySwapped" === r ? "normal" === this.plotInfo.axisPlacement ? n = 'You cannot combine "' + s.type + '" with line, area, column or pie chart' : "none" === this.plotInfo.axisPlacement ? n = 'You cannot combine "' + s.type + '" with pie chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "xySwapped") : "none" === r ? "normal" === this.plotInfo.axisPlacement ? n = 'You cannot combine "' + s.type + '" with line, area, column or bar chart' : "xySwapped" === this.plotInfo.axisPlacement ? n = 'You cannot combine "' + s.type + '" with bar chart' : null === this.plotInfo.axisPlacement && (this.plotInfo.axisPlacement = "none") : null === r && "none" === this.plotInfo.axisPlacement && (n = 'You cannot combine "' + s.type + '" with pie chart'), n && window.console) return void window.console.log(n)
                    }
                for (a = 0; a < this.data.length; a++) {
                    if ("none" == e && "error" === this.data[a].type && window.console) return void window.console.log('You cannot combine "' + s.type + '" with error chart');
                    "error" === this.data[a].type && (this.data[a].axisPlacement = this.plotInfo.axisPlacement = e || "normal", this.data[a]._linkedSeries = null === this.data[a].linkedDataSeriesIndex ? null : this.data[this.data[a].linkedDataSeriesIndex])
                }
            }
            this._objectsInitialized = !0, this._plotAreaElements = []
        }, o._supportedChartTypes = r("line stepLine spline column area stepArea splineArea bar bubble scatter stackedColumn stackedColumn100 stackedBar stackedBar100 stackedArea stackedArea100 candlestick ohlc boxAndWhisker rangeColumn error rangeBar rangeArea rangeSplineArea pie doughnut funnel pyramid waterfall".split(" ")), o.prototype.setLayout = function() {
            for (var t = this._plotAreaElements, e = 0; e < this.data.length; e++)
                if ("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) {
                    if (!this.data[e].axisYType || "primary" === this.data[e].axisYType)
                        if (this.options.axisY && 0 < this.options.axisY.length) {
                            if (!this.axisY.length)
                                for (var i = 0; i < this.options.axisY.length; i++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[i] = new W(this, "axisY", this.options.axisY[i], i, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[i] = new W(this, "axisY", this.options.axisY[i], i, "axisY", "bottom"));
                            this.data[e].axisY = this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0], this.axisY[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e])
                        } else this.axisY.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY[0] = new W(this, "axisY", this.options.axisY, 0, "axisY", "left")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY[0] = new W(this, "axisY", this.options.axisY, 0, "axisY", "bottom"))), this.data[e].axisY = this.axisY[0], this.axisY[0].dataSeries.push(this.data[e]);
                    if ("secondary" === this.data[e].axisYType)
                        if (this.options.axisY2 && 0 < this.options.axisY2.length) {
                            if (!this.axisY2.length)
                                for (i = 0; i < this.options.axisY2.length; i++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[i] = new W(this, "axisY2", this.options.axisY2[i], i, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[i] = new W(this, "axisY2", this.options.axisY2[i], i, "axisY", "top"));
                            this.data[e].axisY = this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0], this.axisY2[0 <= this.data[e].axisYIndex && this.data[e].axisYIndex < this.axisY2.length ? this.data[e].axisYIndex : 0].dataSeries.push(this.data[e])
                        } else this.axisY2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisY2[0] = new W(this, "axisY2", this.options.axisY2, 0, "axisY", "right")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisY2[0] = new W(this, "axisY2", this.options.axisY2, 0, "axisY", "top"))), this.data[e].axisY = this.axisY2[0], this.axisY2[0].dataSeries.push(this.data[e]);
                    if (!this.data[e].axisXType || "primary" === this.data[e].axisXType)
                        if (this.options.axisX && 0 < this.options.axisX.length) {
                            if (!this.axisX.length)
                                for (i = 0; i < this.options.axisX.length; i++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[i] = new W(this, "axisX", this.options.axisX[i], i, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[i] = new W(this, "axisX", this.options.axisX[i], i, "axisX", "left"));
                            this.data[e].axisX = this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0], this.axisX[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e])
                        } else this.axisX.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX[0] = new W(this, "axisX", this.options.axisX, 0, "axisX", "bottom")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX[0] = new W(this, "axisX", this.options.axisX, 0, "axisX", "left"))), this.data[e].axisX = this.axisX[0], this.axisX[0].dataSeries.push(this.data[e]);
                    if ("secondary" === this.data[e].axisXType)
                        if (this.options.axisX2 && 0 < this.options.axisX2.length) {
                            if (!this.axisX2.length)
                                for (i = 0; i < this.options.axisX2.length; i++) "normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[i] = new W(this, "axisX2", this.options.axisX2[i], i, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[i] = new W(this, "axisX2", this.options.axisX2[i], i, "axisX", "right"));
                            this.data[e].axisX = this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0], this.axisX2[0 <= this.data[e].axisXIndex && this.data[e].axisXIndex < this.axisX2.length ? this.data[e].axisXIndex : 0].dataSeries.push(this.data[e])
                        } else this.axisX2.length || ("normal" === this.plotInfo.axisPlacement ? this._axes.push(this.axisX2[0] = new W(this, "axisX2", this.options.axisX2, 0, "axisX", "top")) : "xySwapped" === this.plotInfo.axisPlacement && this._axes.push(this.axisX2[0] = new W(this, "axisX2", this.options.axisX2, 0, "axisX", "right"))), this.data[e].axisX = this.axisX2[0], this.axisX2[0].dataSeries.push(this.data[e])
                }
            if (this.axisY) {
                for (i = 1; i < this.axisY.length; i++) void 0 === this.axisY[i].options.gridThickness && (this.axisY[i].gridThickness = 0);
                for (i = 0; i < this.axisY.length - 1; i++) void 0 === this.axisY[i].options.margin && (this.axisY[i].margin = 10)
            }
            if (this.axisY2) {
                for (i = 1; i < this.axisY2.length; i++) void 0 === this.axisY2[i].options.gridThickness && (this.axisY2[i].gridThickness = 0);
                for (i = 0; i < this.axisY2.length - 1; i++) void 0 === this.axisY2[i].options.margin && (this.axisY2[i].margin = 10)
            }
            if (this.axisY && 0 < this.axisY.length && this.axisY2 && 0 < this.axisY2.length && (0 < this.axisY[0].gridThickness && void 0 === this.axisY2[0].options.gridThickness ? this.axisY2[0].gridThickness = 0 : 0 < this.axisY2[0].gridThickness && void 0 === this.axisY[0].options.gridThickness && (this.axisY[0].gridThickness = 0)), this.axisX)
                for (i = 0; i < this.axisX.length; i++) void 0 === this.axisX[i].options.gridThickness && (this.axisX[i].gridThickness = 0);
            if (this.axisX2)
                for (i = 0; i < this.axisX2.length; i++) void 0 === this.axisX2[i].options.gridThickness && (this.axisX2[i].gridThickness = 0);
            if (this.axisX && 0 < this.axisX.length && this.axisX2 && 0 < this.axisX2.length && (0 < this.axisX[0].gridThickness && void 0 === this.axisX2[0].options.gridThickness ? this.axisX2[0].gridThickness = 0 : 0 < this.axisX2[0].gridThickness && void 0 === this.axisX[0].options.gridThickness && (this.axisX[0].gridThickness = 0)), i = !1, 0 < this._axes.length && (this.zoomEnabled || this.panEnabled))
                for (e = 0; e < this._axes.length; e++)
                    if (null !== this._axes[e].viewportMinimum || null !== this._axes[e].viewportMaximum) {
                        i = !0;
                        break
                    }
            if (i ? (y(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._zoomButton.style.borderRight = this.toolbar.borderThickness + "px solid " + this.toolbar.borderColor, this._resetButton.style.borderRight = (this.exportEnabled ? this.toolbar.borderThickness : 0) + "px solid " + this.toolbar.borderColor) : (v(this._zoomButton, this._resetButton), this._toolBar.style.border = this.toolbar.borderThickness + "px solid transparent", this.options.zoomEnabled && (this.zoomEnabled = !0, this.panEnabled = !1)), this._processData(), this.options.title && (this.title = new P(this, this.options.title), this.title.dockInsidePlotArea ? t.push(this.title) : this.title.setLayout()), this.subtitles = [], this.options.subtitles)
                for (e = 0; e < this.options.subtitles.length; e++) i = new w(this, this.options.subtitles[e], e), this.subtitles.push(i), i.dockInsidePlotArea ? t.push(i) : i.setLayout();
            for (this.legend = new A(this, this.options.legend), e = 0; e < this.data.length; e++)(this.data[e].showInLegend || "pie" === this.data[e].type || "doughnut" === this.data[e].type || "funnel" === this.data[e].type || "pyramid" === this.data[e].type) && this.legend.dataSeries.push(this.data[e]);
            for (this.legend.dockInsidePlotArea ? t.push(this.legend) : this.legend.setLayout(), e = 0; e < this._axes.length; e++)
                if (this._axes[e].scaleBreaks && this._axes[e].scaleBreaks._appliedBreaks.length) {
                    D ? (this._breaksCanvas = m(this.width, this.height), this._breaksCanvasCtx = this._breaksCanvas.getContext("2d")) : (this._breaksCanvas = this.canvas, this._breaksCanvasCtx = this.ctx);
                    break
                }
            this._preRenderCanvas = l(this._preRenderCanvas) ? m(this.width, this.height) : this._preRenderCanvas, this._preRenderCtx = this._preRenderCanvas.getContext("2d"), "normal" !== this.plotInfo.axisPlacement && "xySwapped" !== this.plotInfo.axisPlacement || W.setLayout(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement, this.layoutManager.getFreeSpace())
        }, o.prototype.renderElements = function() {
            var t = this._plotAreaElements;
            this.title && !this.title.dockInsidePlotArea && this.title.render();
            for (var e = 0; e < this.subtitles.length; e++) this.subtitles[e].dockInsidePlotArea || this.subtitles[e].render();
            if (this.legend.dockInsidePlotArea || this.legend.render(), "normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) W.render(this.axisX, this.axisX2, this.axisY, this.axisY2, this.plotInfo.axisPlacement);
            else {
                if ("none" !== this.plotInfo.axisPlacement) return;
                this.preparePlotArea()
            }
            for (e = 0; e < t.length; e++) t[e].setLayout(), t[e].render();
            var i = [];
            if (this.animatedRender) {
                var a = m(this.width, this.height);
                a.getContext("2d").drawImage(this.canvas, 0, 0, this.width, this.height)
            }
            var s;
            t = this.ctx.miterLimit;
            for (this.ctx.miterLimit = 3, D && this._breaksCanvas && (this._preRenderCtx.drawImage(this.canvas, 0, 0, this.width, this.height), this._preRenderCtx.drawImage(this._breaksCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx.globalCompositeOperation = "source-atop", this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), this._preRenderCtx.clearRect(0, 0, this.width, this.height)), e = 0; e < this.plotInfo.plotTypes.length; e++)
                for (var n = this.plotInfo.plotTypes[e], o = 0; o < n.plotUnits.length; o++) {
                    var l = n.plotUnits[o],
                        r = null;
                    l.targetCanvas = null, this.animatedRender && (l.targetCanvas = m(this.width, this.height), l.targetCanvasCtx = l.targetCanvas.getContext("2d"), s = l.targetCanvasCtx.miterLimit, l.targetCanvasCtx.miterLimit = 3), "line" === l.type ? r = this.renderLine(l) : "stepLine" === l.type ? r = this.renderStepLine(l) : "spline" === l.type ? r = this.renderSpline(l) : "column" === l.type ? r = this.renderColumn(l) : "bar" === l.type ? r = this.renderBar(l) : "area" === l.type ? r = this.renderArea(l) : "stepArea" === l.type ? r = this.renderStepArea(l) : "splineArea" === l.type ? r = this.renderSplineArea(l) : "stackedColumn" === l.type ? r = this.renderStackedColumn(l) : "stackedColumn100" === l.type ? r = this.renderStackedColumn100(l) : "stackedBar" === l.type ? r = this.renderStackedBar(l) : "stackedBar100" === l.type ? r = this.renderStackedBar100(l) : "stackedArea" === l.type ? r = this.renderStackedArea(l) : "stackedArea100" === l.type ? r = this.renderStackedArea100(l) : "bubble" === l.type ? r = r = this.renderBubble(l) : "scatter" === l.type ? r = this.renderScatter(l) : "pie" === l.type ? this.renderPie(l) : "doughnut" === l.type ? this.renderPie(l) : "funnel" === l.type ? r = this.renderFunnel(l) : "pyramid" === l.type ? r = this.renderFunnel(l) : "candlestick" === l.type ? r = this.renderCandlestick(l) : "ohlc" === l.type ? r = this.renderCandlestick(l) : "rangeColumn" === l.type ? r = this.renderRangeColumn(l) : "error" === l.type ? r = this.renderError(l) : "rangeBar" === l.type ? r = this.renderRangeBar(l) : "rangeArea" === l.type ? r = this.renderRangeArea(l) : "rangeSplineArea" === l.type ? r = this.renderRangeSplineArea(l) : "waterfall" === l.type ? r = this.renderWaterfall(l) : "boxAndWhisker" === l.type && (r = this.renderBoxAndWhisker(l));
                    for (var h = 0; h < l.dataSeriesIndexes.length; h++) this._dataInRenderedOrder.push(this.data[l.dataSeriesIndexes[h]]);
                    this.animatedRender && (l.targetCanvasCtx.miterLimit = s, r && i.push(r))
                }
            this.ctx.miterLimit = t, this.animatedRender && this._breaksCanvasCtx && i.push({
                source: this._breaksCanvasCtx,
                dest: this.plotArea.ctx,
                animationCallback: tt.fadeInAnimation,
                easingFunction: tt.easing.easeInQuad,
                animationBase: 0,
                startTimePercent: .7
            }), this.animatedRender && 0 < this._indexLabels.length && (s = m(this.width, this.height).getContext("2d"), i.push(this.renderIndexLabels(s)));
            var d = this;
            if (0 < i.length) d.disableToolTip = !0, d._animator.animate(200, d.animationDuration, function(t) {
                d.ctx.clearRect(0, 0, d.width, d.height), d.ctx.drawImage(a, 0, 0, Math.floor(d.width * at), Math.floor(d.height * at), 0, 0, d.width, d.height);
                for (var e = 0; e < i.length; e++) r = i[e], 1 > t && void 0 !== r.startTimePercent ? t >= r.startTimePercent && r.animationCallback(r.easingFunction(t - r.startTimePercent, 0, 1, 1 - r.startTimePercent), r) : r.animationCallback(r.easingFunction(t, 0, 1, 1), r);
                d.dispatchEvent("dataAnimationIterationEnd", {
                    chart: d
                })
            }, function() {
                i = [];
                for (var t = 0; t < d.plotInfo.plotTypes.length; t++)
                    for (var e = d.plotInfo.plotTypes[t], s = 0; s < e.plotUnits.length; s++) e.plotUnits[s].targetCanvas = null;
                a = null, d.disableToolTip = !1
            });
            else {
                if (d._breaksCanvas)
                    if (D) d.plotArea.ctx.drawImage(d._breaksCanvas, 0, 0, this.width, this.height);
                    else
                        for (h = 0; h < d._axes.length; h++) d._axes[h].createMask();
                0 < d._indexLabels.length && d.renderIndexLabels(), d.dispatchEvent("dataAnimationIterationEnd", {
                    chart: d
                })
            }
            for (this.attachPlotAreaEventHandlers(), this.zoomEnabled || this.panEnabled || !this._zoomButton || "none" === this._zoomButton.style.display || v(this._zoomButton, this._resetButton), this.toolTip._updateToolTip(), this.renderCount++, I && (d = this, setTimeout(function() {
                    var t = document.getElementById("ghostCanvasCopy");
                    t && (u(t, d.width, d.height), t.getContext("2d").drawImage(d._eventManager.ghostCanvas, 0, 0))
                }, 2e3)), this._breaksCanvas && (delete this._breaksCanvas, delete this._breaksCanvasCtx), h = 0; h < this._axes.length; h++) this._axes[h].maskCanvas && (delete this._axes[h].maskCanvas, delete this._axes[h].maskCtx)
        }, o.prototype.render = function(t) {
            t && (this.options = t), this._initialize(), this.setLayout(), this.renderElements()
        }, o.prototype.attachPlotAreaEventHandlers = function() {
            this.attachEvent({
                context: this,
                chart: this,
                mousedown: this._plotAreaMouseDown,
                mouseup: this._plotAreaMouseUp,
                mousemove: this._plotAreaMouseMove,
                cursor: this.panEnabled ? "move" : "default",
                capture: !0,
                bounds: this.plotArea
            })
        }, o.prototype.categoriseDataSeries = function() {
            for (var t = "", e = 0; e < this.data.length; e++)
                if ((t = this.data[e]).dataPoints && 0 !== t.dataPoints.length && t.visible && 0 <= o._supportedChartTypes.indexOf(t.type)) {
                    for (var i = null, a = !1, s = null, n = !1, l = 0; l < this.plotInfo.plotTypes.length; l++)
                        if (this.plotInfo.plotTypes[l].type === t.type) {
                            a = !0, i = this.plotInfo.plotTypes[l];
                            break
                        }
                    for (a || (i = {
                            type: t.type,
                            totalDataSeries: 0,
                            plotUnits: []
                        }, this.plotInfo.plotTypes.push(i)), l = 0; l < i.plotUnits.length; l++)
                        if (i.plotUnits[l].axisYType === t.axisYType && i.plotUnits[l].axisXType === t.axisXType && i.plotUnits[l].axisYIndex === t.axisYIndex && i.plotUnits[l].axisXIndex === t.axisXIndex) {
                            n = !0, s = i.plotUnits[l];
                            break
                        }
                    n || (s = {
                        type: t.type,
                        previousDataSeriesCount: 0,
                        index: i.plotUnits.length,
                        plotType: i,
                        axisXType: t.axisXType,
                        axisYType: t.axisYType,
                        axisYIndex: t.axisYIndex,
                        axisXIndex: t.axisXIndex,
                        axisY: "primary" === t.axisYType ? this.axisY[0 <= t.axisYIndex && t.axisYIndex < this.axisY.length ? t.axisYIndex : 0] : this.axisY2[0 <= t.axisYIndex && t.axisYIndex < this.axisY2.length ? t.axisYIndex : 0],
                        axisX: "primary" === t.axisXType ? this.axisX[0 <= t.axisXIndex && t.axisXIndex < this.axisX.length ? t.axisXIndex : 0] : this.axisX2[0 <= t.axisXIndex && t.axisXIndex < this.axisX2.length ? t.axisXIndex : 0],
                        dataSeriesIndexes: [],
                        yTotals: []
                    }, i.plotUnits.push(s)), i.totalDataSeries++, s.dataSeriesIndexes.push(e), t.plotUnit = s
                }
            for (e = 0; e < this.plotInfo.plotTypes.length; e++)
                for (i = this.plotInfo.plotTypes[e], l = t = 0; l < i.plotUnits.length; l++) i.plotUnits[l].previousDataSeriesCount = t, t += i.plotUnits[l].dataSeriesIndexes.length
        }, o.prototype.assignIdToDataPoints = function() {
            for (var t = 0; t < this.data.length; t++) {
                var e = this.data[t];
                if (e.dataPoints)
                    for (var i = e.dataPoints.length, a = 0; a < i; a++) e.dataPointIds[a] = ++this._eventManager.lastObjectId
            }
        }, o.prototype._processData = function() {
            this.assignIdToDataPoints(), this.categoriseDataSeries();
            for (var t = 0; t < this.plotInfo.plotTypes.length; t++)
                for (var e = this.plotInfo.plotTypes[t], i = 0; i < e.plotUnits.length; i++) {
                    var a = e.plotUnits[i];
                    "line" === a.type || "stepLine" === a.type || "spline" === a.type || "column" === a.type || "area" === a.type || "stepArea" === a.type || "splineArea" === a.type || "bar" === a.type || "bubble" === a.type || "scatter" === a.type ? this._processMultiseriesPlotUnit(a) : "stackedColumn" === a.type || "stackedBar" === a.type || "stackedArea" === a.type ? this._processStackedPlotUnit(a) : "stackedColumn100" === a.type || "stackedBar100" === a.type || "stackedArea100" === a.type ? this._processStacked100PlotUnit(a) : "candlestick" === a.type || "ohlc" === a.type || "rangeColumn" === a.type || "rangeBar" === a.type || "rangeArea" === a.type || "rangeSplineArea" === a.type || "error" === a.type || "boxAndWhisker" === a.type ? this._processMultiYPlotUnit(a) : "waterfall" === a.type && this._processSpecificPlotUnit(a)
                }
            this.calculateAutoBreaks()
        }, o.prototype._processMultiseriesPlotUnit = function(t) {
            if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length))
                for (var e, i, a = t.axisY.dataInfo, s = t.axisX.dataInfo, n = !1, o = 0; o < t.dataSeriesIndexes.length; o++) {
                    var l, r = this.data[t.dataSeriesIndexes[o]],
                        h = 0,
                        d = !1,
                        x = !1;
                    if ("normal" === r.axisPlacement || "xySwapped" === r.axisPlacement) var c = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : t.axisX.logarithmic ? 0 : -1 / 0,
                        p = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0;
                    for ((r.dataPoints[h].x && r.dataPoints[h].x.getTime || "dateTime" === r.xValueType) && (n = !0), h = 0; h < r.dataPoints.length; h++) {
                        if (void 0 === r.dataPoints[h].x && (r.dataPoints[h].x = h + (t.axisX.logarithmic ? 1 : 0)), r.dataPoints[h].x.getTime ? (n = !0, e = r.dataPoints[h].x.getTime()) : e = r.dataPoints[h].x, i = r.dataPoints[h].y, e < s.min && (s.min = e), e > s.max && (s.max = e), i < a.min && "number" == typeof i && (a.min = i), i > a.max && "number" == typeof i && (a.max = i), 0 < h) {
                            if (t.axisX.logarithmic) {
                                var u = e / r.dataPoints[h - 1].x;
                                1 > u && (u = 1 / u), s.minDiff > u && 1 !== u && (s.minDiff = u)
                            } else 0 > (u = e - r.dataPoints[h - 1].x) && (u *= -1), s.minDiff > u && 0 !== u && (s.minDiff = u);
                            null !== i && null !== r.dataPoints[h - 1].y && (t.axisY.logarithmic ? (1 > (u = i / r.dataPoints[h - 1].y) && (u = 1 / u), a.minDiff > u && 1 !== u && (a.minDiff = u)) : (0 > (u = i - r.dataPoints[h - 1].y) && (u *= -1), a.minDiff > u && 0 !== u && (a.minDiff = u)))
                        }
                        if (e < c && !d) null !== i && (l = e);
                        else {
                            if (!d && (d = !0, 0 < h)) {
                                h -= 2;
                                continue
                            }
                            if (e > p && !x) x = !0;
                            else if (e > p && x) continue;
                            r.dataPoints[h].label && (t.axisX.labels[e] = r.dataPoints[h].label), e < s.viewPortMin && (s.viewPortMin = e), e > s.viewPortMax && (s.viewPortMax = e), null === i ? s.viewPortMin === e && l < e && (s.viewPortMin = l) : (i < a.viewPortMin && "number" == typeof i && (a.viewPortMin = i), i > a.viewPortMax && "number" == typeof i && (a.viewPortMax = i))
                        }
                    }
                    r.axisX.valueType = r.xValueType = n ? "dateTime" : "number"
                }
        }, o.prototype._processStackedPlotUnit = function(t) {
            if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) {
                for (var e, i, a = t.axisY.dataInfo, s = t.axisX.dataInfo, n = !1, o = [], r = [], h = 1 / 0, d = -1 / 0, x = 0; x < t.dataSeriesIndexes.length; x++) {
                    var c, p = this.data[t.dataSeriesIndexes[x]],
                        u = 0,
                        m = !1,
                        g = !1;
                    if ("normal" === p.axisPlacement || "xySwapped" === p.axisPlacement) var b = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -1 / 0,
                        y = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0;
                    for ((p.dataPoints[u].x && p.dataPoints[u].x.getTime || "dateTime" === p.xValueType) && (n = !0), u = 0; u < p.dataPoints.length; u++) {
                        if (void 0 === p.dataPoints[u].x && (p.dataPoints[u].x = u + (t.axisX.logarithmic ? 1 : 0)), p.dataPoints[u].x.getTime ? (n = !0, e = p.dataPoints[u].x.getTime()) : e = p.dataPoints[u].x, i = l(p.dataPoints[u].y) ? 0 : p.dataPoints[u].y, e < s.min && (s.min = e), e > s.max && (s.max = e), 0 < u) {
                            if (t.axisX.logarithmic) {
                                var v = e / p.dataPoints[u - 1].x;
                                1 > v && (v = 1 / v), s.minDiff > v && 1 !== v && (s.minDiff = v)
                            } else 0 > (v = e - p.dataPoints[u - 1].x) && (v *= -1), s.minDiff > v && 0 !== v && (s.minDiff = v);
                            null !== i && null !== p.dataPoints[u - 1].y && (t.axisY.logarithmic ? 0 < i && (1 > (v = i / p.dataPoints[u - 1].y) && (v = 1 / v), a.minDiff > v && 1 !== v && (a.minDiff = v)) : (0 > (v = i - p.dataPoints[u - 1].y) && (v *= -1), a.minDiff > v && 0 !== v && (a.minDiff = v)))
                        }
                        if (e < b && !m) null !== p.dataPoints[u].y && (c = e);
                        else {
                            if (!m && (m = !0, 0 < u)) {
                                u -= 2;
                                continue
                            }
                            if (e > y && !g) g = !0;
                            else if (e > y && g) continue;
                            p.dataPoints[u].label && (t.axisX.labels[e] = p.dataPoints[u].label), e < s.viewPortMin && (s.viewPortMin = e), e > s.viewPortMax && (s.viewPortMax = e), null === p.dataPoints[u].y ? s.viewPortMin === e && c < e && (s.viewPortMin = c) : (t.yTotals[e] = (t.yTotals[e] ? t.yTotals[e] : 0) + i, 0 <= i ? o[e] ? o[e] += i : (o[e] = i, h = Math.min(i, h)) : r[e] ? r[e] += i : (r[e] = i, d = Math.max(i, d)))
                        }
                    }
                    t.axisY.scaleBreaks && t.axisY.scaleBreaks.autoCalculate && 1 <= t.axisY.scaleBreaks.maxNumberOfAutoBreaks && (a.dataPointYPositiveSums ? (a.dataPointYPositiveSums.push.apply(a.dataPointYPositiveSums, o), a.dataPointYNegativeSums.push.apply(a.dataPointYPositiveSums, r)) : (a.dataPointYPositiveSums = o, a.dataPointYNegativeSums = r)), p.axisX.valueType = p.xValueType = n ? "dateTime" : "number"
                }
                for (u in o) o.hasOwnProperty(u) && !isNaN(u) && ((t = o[u]) < a.min && (a.min = Math.min(t, h)), t > a.max && (a.max = t), u < s.viewPortMin || u > s.viewPortMax || (t < a.viewPortMin && (a.viewPortMin = Math.min(t, h)), t > a.viewPortMax && (a.viewPortMax = t)));
                for (u in r) r.hasOwnProperty(u) && !isNaN(u) && ((t = r[u]) < a.min && (a.min = t), t > a.max && (a.max = Math.max(t, d)), u < s.viewPortMin || u > s.viewPortMax || (t < a.viewPortMin && (a.viewPortMin = t), t > a.viewPortMax && (a.viewPortMax = Math.max(t, d))))
            }
        }, o.prototype._processStacked100PlotUnit = function(t) {
            if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) {
                for (var e, i, a = t.axisY.dataInfo, s = t.axisX.dataInfo, n = !1, o = !1, r = !1, h = [], d = 0; d < t.dataSeriesIndexes.length; d++) {
                    var x, c = this.data[t.dataSeriesIndexes[d]],
                        p = 0,
                        u = !1,
                        m = !1;
                    if ("normal" === c.axisPlacement || "xySwapped" === c.axisPlacement) var g = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : -1 / 0,
                        b = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0;
                    for ((c.dataPoints[p].x && c.dataPoints[p].x.getTime || "dateTime" === c.xValueType) && (n = !0), p = 0; p < c.dataPoints.length; p++) {
                        if (void 0 === c.dataPoints[p].x && (c.dataPoints[p].x = p + (t.axisX.logarithmic ? 1 : 0)), c.dataPoints[p].x.getTime ? (n = !0, e = c.dataPoints[p].x.getTime()) : e = c.dataPoints[p].x, i = l(c.dataPoints[p].y) ? null : c.dataPoints[p].y, e < s.min && (s.min = e), e > s.max && (s.max = e), 0 < p) {
                            if (t.axisX.logarithmic) {
                                var y = e / c.dataPoints[p - 1].x;
                                1 > y && (y = 1 / y), s.minDiff > y && 1 !== y && (s.minDiff = y)
                            } else 0 > (y = e - c.dataPoints[p - 1].x) && (y *= -1), s.minDiff > y && 0 !== y && (s.minDiff = y);
                            l(i) || null === c.dataPoints[p - 1].y || (t.axisY.logarithmic ? 0 < i && (1 > (y = i / c.dataPoints[p - 1].y) && (y = 1 / y), a.minDiff > y && 1 !== y && (a.minDiff = y)) : (0 > (y = i - c.dataPoints[p - 1].y) && (y *= -1), a.minDiff > y && 0 !== y && (a.minDiff = y)))
                        }
                        if (e < g && !u) null !== i && (x = e);
                        else {
                            if (!u && (u = !0, 0 < p)) {
                                p -= 2;
                                continue
                            }
                            if (e > b && !m) m = !0;
                            else if (e > b && m) continue;
                            c.dataPoints[p].label && (t.axisX.labels[e] = c.dataPoints[p].label), e < s.viewPortMin && (s.viewPortMin = e), e > s.viewPortMax && (s.viewPortMax = e), null === i ? s.viewPortMin === e && x < e && (s.viewPortMin = x) : (t.yTotals[e] = (t.yTotals[e] ? t.yTotals[e] : 0) + i, 0 <= i ? o = !0 : 0 > i && (r = !0), h[e] = h[e] ? h[e] + Math.abs(i) : Math.abs(i))
                        }
                    }
                    c.axisX.valueType = c.xValueType = n ? "dateTime" : "number"
                }
                t.axisY.logarithmic ? (a.max = l(a.viewPortMax) ? 99 * Math.pow(t.axisY.logarithmBase, -.05) : Math.max(a.viewPortMax, 99 * Math.pow(t.axisY.logarithmBase, -.05)), a.min = l(a.viewPortMin) ? 1 : Math.min(a.viewPortMin, 1)) : o && !r ? (a.max = l(a.viewPortMax) ? 99 : Math.max(a.viewPortMax, 99), a.min = l(a.viewPortMin) ? 1 : Math.min(a.viewPortMin, 1)) : o && r ? (a.max = l(a.viewPortMax) ? 99 : Math.max(a.viewPortMax, 99), a.min = l(a.viewPortMin) ? -99 : Math.min(a.viewPortMin, -99)) : !o && r && (a.max = l(a.viewPortMax) ? -1 : Math.max(a.viewPortMax, -1), a.min = l(a.viewPortMin) ? -99 : Math.min(a.viewPortMin, -99)), a.viewPortMin = a.min, a.viewPortMax = a.max, t.dataPointYSums = h
            }
        }, o.prototype._processMultiYPlotUnit = function(t) {
            if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length))
                for (var e, i, a, s, n = t.axisY.dataInfo, o = t.axisX.dataInfo, l = !1, r = 0; r < t.dataSeriesIndexes.length; r++) {
                    var h, d, x, c = this.data[t.dataSeriesIndexes[r]],
                        p = 0,
                        u = !1,
                        m = !1;
                    if ("normal" === c.axisPlacement || "xySwapped" === c.axisPlacement) var g = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : t.axisX.logarithmic ? 0 : -1 / 0,
                        b = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0;
                    for ((c.dataPoints[p].x && c.dataPoints[p].x.getTime || "dateTime" === c.xValueType) && (l = !0), p = 0; p < c.dataPoints.length; p++) {
                        if (void 0 === c.dataPoints[p].x && (c.dataPoints[p].x = p + (t.axisX.logarithmic ? 1 : 0)), c.dataPoints[p].x.getTime ? (l = !0, e = c.dataPoints[p].x.getTime()) : e = c.dataPoints[p].x, (i = c.dataPoints[p].y) && i.length) {
                            a = Math.min.apply(null, i), s = Math.max.apply(null, i), d = !0;
                            for (var y = 0; y < i.length; y++) null === i.k && (d = !1);
                            d && (u || (x = h), h = e)
                        }
                        if (e < o.min && (o.min = e), e > o.max && (o.max = e), a < n.min && (n.min = a), s > n.max && (n.max = s), 0 < p && (t.axisX.logarithmic ? (1 > (d = e / c.dataPoints[p - 1].x) && (d = 1 / d), o.minDiff > d && 1 !== d && (o.minDiff = d)) : (0 > (d = e - c.dataPoints[p - 1].x) && (d *= -1), o.minDiff > d && 0 !== d && (o.minDiff = d)), i && null !== i[0] && c.dataPoints[p - 1].y && null !== c.dataPoints[p - 1].y[0] && (t.axisY.logarithmic ? (1 > (d = i[0] / c.dataPoints[p - 1].y[0]) && (d = 1 / d), n.minDiff > d && 1 !== d && (n.minDiff = d)) : (0 > (d = i[0] - c.dataPoints[p - 1].y[0]) && (d *= -1), n.minDiff > d && 0 !== d && (n.minDiff = d)))), !(e < g) || u) {
                            if (!u && (u = !0, 0 < p)) {
                                p -= 2, h = x;
                                continue
                            }
                            if (e > b && !m) m = !0;
                            else if (e > b && m) continue;
                            if (c.dataPoints[p].label && (t.axisX.labels[e] = c.dataPoints[p].label), e < o.viewPortMin && (o.viewPortMin = e), e > o.viewPortMax && (o.viewPortMax = e), o.viewPortMin === e && i)
                                for (y = 0; y < i.length; y++)
                                    if (null === i[y] && h < e) {
                                        o.viewPortMin = h;
                                        break
                                    }
                            null === i ? o.viewPortMin === e && h < e && (o.viewPortMin = h) : (a < n.viewPortMin && (n.viewPortMin = a), s > n.viewPortMax && (n.viewPortMax = s))
                        }
                    }
                    c.axisX.valueType = c.xValueType = l ? "dateTime" : "number"
                }
        }, o.prototype._processSpecificPlotUnit = function(t) {
            if ("waterfall" === t.type && t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length))
                for (var e, i, a = t.axisY.dataInfo, s = t.axisX.dataInfo, n = !1, o = 0; o < t.dataSeriesIndexes.length; o++) {
                    var l = this.data[t.dataSeriesIndexes[o]],
                        r = 0,
                        h = !1,
                        d = !1,
                        x = e = 0;
                    if ("normal" === l.axisPlacement || "xySwapped" === l.axisPlacement) var c = t.axisX.sessionVariables.newViewportMinimum ? t.axisX.sessionVariables.newViewportMinimum : this.options.axisX && this.options.axisX.viewportMinimum ? this.options.axisX.viewportMinimum : this.options.axisX && this.options.axisX.minimum ? this.options.axisX.minimum : t.axisX.logarithmic ? 0 : -1 / 0,
                        p = t.axisX.sessionVariables.newViewportMaximum ? t.axisX.sessionVariables.newViewportMaximum : this.options.axisX && this.options.axisX.viewportMaximum ? this.options.axisX.viewportMaximum : this.options.axisX && this.options.axisX.maximum ? this.options.axisX.maximum : 1 / 0;
                    for ((l.dataPoints[r].x && l.dataPoints[r].x.getTime || "dateTime" === l.xValueType) && (n = !0), r = 0; r < l.dataPoints.length; r++) void 0 !== l.dataPoints[r].isCumulativeSum && !0 === l.dataPoints[r].isCumulativeSum ? (l.dataPointEOs[r].cumulativeSumYStartValue = 0, l.dataPointEOs[r].cumulativeSum = 0 === r ? 0 : l.dataPointEOs[r - 1].cumulativeSum, l.dataPoints[r].y = 0 === r ? 0 : l.dataPointEOs[r - 1].cumulativeSum) : void 0 !== l.dataPoints[r].isIntermediateSum && !0 === l.dataPoints[r].isIntermediateSum ? (l.dataPointEOs[r].cumulativeSumYStartValue = x, l.dataPointEOs[r].cumulativeSum = 0 === r ? 0 : l.dataPointEOs[r - 1].cumulativeSum, l.dataPoints[r].y = 0 === r ? 0 : e, x = 0 === r ? 0 : l.dataPointEOs[r - 1].cumulativeSum, e = 0) : (i = "number" != typeof l.dataPoints[r].y ? 0 : l.dataPoints[r].y, l.dataPointEOs[r].cumulativeSumYStartValue = 0 === r ? 0 : l.dataPointEOs[r - 1].cumulativeSum, l.dataPointEOs[r].cumulativeSum = 0 === r ? i : l.dataPointEOs[r - 1].cumulativeSum + i, e += i);
                    for (r = 0; r < l.dataPoints.length; r++)
                        if (void 0 === l.dataPoints[r].x && (l.dataPoints[r].x = r + (t.axisX.logarithmic ? 1 : 0)), l.dataPoints[r].x.getTime ? (n = !0, e = l.dataPoints[r].x.getTime()) : e = l.dataPoints[r].x, i = l.dataPoints[r].y, e < s.min && (s.min = e), e > s.max && (s.max = e), l.dataPointEOs[r].cumulativeSum < a.min && (a.min = l.dataPointEOs[r].cumulativeSum), l.dataPointEOs[r].cumulativeSum > a.max && (a.max = l.dataPointEOs[r].cumulativeSum), 0 < r && (t.axisX.logarithmic ? (1 > (x = e / l.dataPoints[r - 1].x) && (x = 1 / x), s.minDiff > x && 1 !== x && (s.minDiff = x)) : (0 > (x = e - l.dataPoints[r - 1].x) && (x *= -1), s.minDiff > x && 0 !== x && (s.minDiff = x)), null !== i && null !== l.dataPoints[r - 1].y && (t.axisY.logarithmic ? (1 > (i = l.dataPointEOs[r].cumulativeSum / l.dataPointEOs[r - 1].cumulativeSum) && (i = 1 / i), a.minDiff > i && 1 !== i && (a.minDiff = i)) : (0 > (i = l.dataPointEOs[r].cumulativeSum - l.dataPointEOs[r - 1].cumulativeSum) && (i *= -1), a.minDiff > i && 0 !== i && (a.minDiff = i)))), !(e < c) || h) {
                            if (!h && (h = !0, 0 < r)) {
                                r -= 2;
                                continue
                            }
                            if (e > p && !d) d = !0;
                            else if (e > p && d) continue;
                            l.dataPoints[r].label && (t.axisX.labels[e] = l.dataPoints[r].label), e < s.viewPortMin && (s.viewPortMin = e), e > s.viewPortMax && (s.viewPortMax = e), 0 < r && (l.dataPointEOs[r - 1].cumulativeSum < a.viewPortMin && (a.viewPortMin = l.dataPointEOs[r - 1].cumulativeSum), l.dataPointEOs[r - 1].cumulativeSum > a.viewPortMax && (a.viewPortMax = l.dataPointEOs[r - 1].cumulativeSum)), l.dataPointEOs[r].cumulativeSum < a.viewPortMin && (a.viewPortMin = l.dataPointEOs[r].cumulativeSum), l.dataPointEOs[r].cumulativeSum > a.viewPortMax && (a.viewPortMax = l.dataPointEOs[r].cumulativeSum)
                        }
                    l.axisX.valueType = l.xValueType = n ? "dateTime" : "number"
                }
        }, o.prototype.calculateAutoBreaks = function() {
            function t(t, e, i, a) {
                return a ? (1 >= (i = Math.pow(Math.min(i * t / e, e / t), .2)) && (i = Math.pow(1 > t ? 1 / t : Math.min(e / t, t), .25)), {
                    startValue: t * i,
                    endValue: e / i
                }) : (0 >= (i = .2 * Math.min(i - e + t, e - t)) && (i = .25 * Math.min(e - t, Math.abs(t))), {
                    startValue: t + i,
                    endValue: e - i
                })
            }

            function e(t) {
                if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length)) {
                    var e = t.axisX.scaleBreaks && t.axisX.scaleBreaks.autoCalculate && 1 <= t.axisX.scaleBreaks.maxNumberOfAutoBreaks,
                        i = t.axisY.scaleBreaks && t.axisY.scaleBreaks.autoCalculate && 1 <= t.axisY.scaleBreaks.maxNumberOfAutoBreaks;
                    if (e || i)
                        for (var a, n, o = t.axisY.dataInfo, r = (c = t.axisX.dataInfo).min, h = c.max, d = o.min, x = o.max, c = c._dataRanges, p = (o = o._dataRanges, 0), u = 0; u < t.dataSeriesIndexes.length; u++) {
                            var m = s.data[t.dataSeriesIndexes[u]];
                            if (!(4 > m.dataPoints.length))
                                for (p = 0; p < m.dataPoints.length; p++)
                                    if (e && (n = (h + 1 - r) * Math.max(parseFloat(t.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, (a = m.dataPoints[p].x.getTime ? m.dataPoints[p].x.getTime() : m.dataPoints[p].x) < c[n = Math.floor((a - r) / n)].min && (c[n].min = a), a > c[n].max && (c[n].max = a)), i) {
                                        var g = (x + 1 - d) * Math.max(parseFloat(t.axisY.scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                                        if ((a = "waterfall" === t.type ? m.dataPointEOs[p].cumulativeSum : m.dataPoints[p].y) && a.length)
                                            for (var b = 0; b < a.length; b++) n = Math.floor((a[b] - d) / g), a[b] < o[n].min && (o[n].min = a[b]), a[b] > o[n].max && (o[n].max = a[b]);
                                        else l(a) || (a < o[n = Math.floor((a - d) / g)].min && (o[n].min = a), a > o[n].max && (o[n].max = a))
                                    }
                        }
                }
            }

            function i(t) {
                if (t.dataSeriesIndexes && !(1 > t.dataSeriesIndexes.length) && t.axisX.scaleBreaks && t.axisX.scaleBreaks.autoCalculate && 1 <= t.axisX.scaleBreaks.maxNumberOfAutoBreaks)
                    for (var e, i = t.axisX.dataInfo, a = i.min, n = i.max, o = i._dataRanges, l = 0, r = 0; r < t.dataSeriesIndexes.length; r++) {
                        var h = s.data[t.dataSeriesIndexes[r]];
                        if (!(4 > h.dataPoints.length))
                            for (l = 0; l < h.dataPoints.length; l++) e = (n + 1 - a) * Math.max(parseFloat(t.axisX.scaleBreaks.collapsibleThreshold) || 10, 10) / 100, (i = h.dataPoints[l].x.getTime ? h.dataPoints[l].x.getTime() : h.dataPoints[l].x) < o[e = Math.floor((i - a) / e)].min && (o[e].min = i), i > o[e].max && (o[e].max = i)
                    }
            }
            for (var a, s = this, n = !1, o = 0; o < this._axes.length; o++)
                if (this._axes[o].scaleBreaks && this._axes[o].scaleBreaks.autoCalculate && 1 <= this._axes[o].scaleBreaks.maxNumberOfAutoBreaks) {
                    n = !0, this._axes[o].dataInfo._dataRanges = [];
                    for (var r = 0; r < 100 / Math.max(parseFloat(this._axes[o].scaleBreaks.collapsibleThreshold) || 10, 10); r++) this._axes[o].dataInfo._dataRanges.push({
                        min: 1 / 0,
                        max: -1 / 0
                    })
                }
            if (n) {
                for (o = 0; o < this.plotInfo.plotTypes.length; o++)
                    for (n = this.plotInfo.plotTypes[o], r = 0; r < n.plotUnits.length; r++) "line" === (a = n.plotUnits[r]).type || "stepLine" === a.type || "spline" === a.type || "column" === a.type || "area" === a.type || "stepArea" === a.type || "splineArea" === a.type || "bar" === a.type || "bubble" === a.type || "scatter" === a.type || "candlestick" === a.type || "ohlc" === a.type || "rangeColumn" === a.type || "rangeBar" === a.type || "rangeArea" === a.type || "rangeSplineArea" === a.type || "waterfall" === a.type || "error" === a.type || "boxAndWhisker" === a.type ? e(a) : 0 <= a.type.indexOf("stacked") && i(a);
                for (o = 0; o < this._axes.length; o++)
                    if (this._axes[o].dataInfo._dataRanges) {
                        var h = this._axes[o].dataInfo.min;
                        a = (this._axes[o].dataInfo.max + 1 - h) * Math.max(parseFloat(this._axes[o].scaleBreaks.collapsibleThreshold) || 10, 10) / 100;
                        var d, x, c = this._axes[o].dataInfo._dataRanges;
                        n = [];
                        if (this._axes[o].dataInfo.dataPointYPositiveSums) {
                            var p = this._axes[o].dataInfo.dataPointYPositiveSums;
                            for (r in d = c, p)
                                if (p.hasOwnProperty(r) && !isNaN(r) && !l(x = p[r])) {
                                    var u = Math.floor((x - h) / a);
                                    x < d[u].min && (d[u].min = x), x > d[u].max && (d[u].max = x)
                                }
                            delete this._axes[o].dataInfo.dataPointYPositiveSums
                        }
                        if (this._axes[o].dataInfo.dataPointYNegativeSums) {
                            for (r in d = c, p = this._axes[o].dataInfo.dataPointYNegativeSums) p.hasOwnProperty(r) && !isNaN(r) && (l(x = -1 * p[r]) || (x < d[u = Math.floor((x - h) / a)].min && (d[u].min = x), x > d[u].max && (d[u].max = x)));
                            delete this._axes[o].dataInfo.dataPointYNegativeSums
                        }
                        for (r = 0; r < c.length - 1; r++)
                            if (d = c[r].max, isFinite(d))
                                for (; r < c.length - 1;) {
                                    if (h = c[r + 1].min, isFinite(h)) {
                                        (x = h - d) > a && n.push({
                                            diff: x,
                                            start: d,
                                            end: h
                                        });
                                        break
                                    }
                                    r++
                                }
                            if (this._axes[o].scaleBreaks.customBreaks)
                                for (r = 0; r < this._axes[o].scaleBreaks.customBreaks.length; r++)
                                    for (a = 0; a < n.length; a++)(this._axes[o].scaleBreaks.customBreaks[r].startValue <= n[a].start && n[a].start <= this._axes[o].scaleBreaks.customBreaks[r].endValue || this._axes[o].scaleBreaks.customBreaks[r].startValue <= n[a].start && n[a].start <= this._axes[o].scaleBreaks.customBreaks[r].endValue || n[a].start <= this._axes[o].scaleBreaks.customBreaks[r].startValue && this._axes[o].scaleBreaks.customBreaks[r].startValue <= n[a].end || n[a].start <= this._axes[o].scaleBreaks.customBreaks[r].endValue && this._axes[o].scaleBreaks.customBreaks[r].endValue <= n[a].end) && (n.splice(a, 1), a--);
                        for (n.sort(function(t, e) {
                                return e.diff - t.diff
                            }), r = 0; r < Math.min(n.length, this._axes[o].scaleBreaks.maxNumberOfAutoBreaks); r++) a = t(n[r].start, n[r].end, this._axes[o].logarithmic ? this._axes[o].dataInfo.max / this._axes[o].dataInfo.min : this._axes[o].dataInfo.max - this._axes[o].dataInfo.min, this._axes[o].logarithmic), this._axes[o].scaleBreaks.autoBreaks.push(new X(this, "autoBreaks", a, r, ++this._eventManager.lastObjectId, this._axes[o].scaleBreaks)), this._axes[o].scaleBreaks._appliedBreaks.push(this._axes[o].scaleBreaks.autoBreaks[this._axes[o].scaleBreaks.autoBreaks.length - 1]);
                        this._axes[o].scaleBreaks._appliedBreaks.sort(function(t, e) {
                            return t.startValue - e.startValue
                        })
                    }
            }
        }, o.prototype.getDataPointAtXY = function(t, e, i) {
            i = i || !1;
            for (var a = [], s = this._dataInRenderedOrder.length - 1; 0 <= s; s--) {
                var n;
                (n = this._dataInRenderedOrder[s].getDataPointAtXY(t, e, i)) && a.push(n)
            }
            for (t = null, e = !1, i = 0; i < a.length; i++)
                if (("line" === a[i].dataSeries.type || "stepLine" === a[i].dataSeries.type || "area" === a[i].dataSeries.type || "stepArea" === a[i].dataSeries.type) && (s = p("markerSize", a[i].dataPoint, a[i].dataSeries) || 8, a[i].distance <= s / 2)) {
                    e = !0;
                    break
                }
            for (i = 0; i < a.length; i++) e && "line" !== a[i].dataSeries.type && "stepLine" !== a[i].dataSeries.type && "area" !== a[i].dataSeries.type && "stepArea" !== a[i].dataSeries.type || (t ? a[i].distance <= t.distance && (t = a[i]) : t = a[i]);
            return t
        }, o.prototype.getObjectAtXY = function(t, e, i) {
            var a = null;
            if (i = this.getDataPointAtXY(t, e, i || !1)) a = i.dataSeries.dataPointIds[i.dataPointIndex];
            else if (D) a = c(t, e, this._eventManager.ghostCtx);
            else
                for (i = 0; i < this.legend.items.length; i++) {
                    var s = this.legend.items[i];
                    t >= s.x1 && t <= s.x2 && e >= s.y1 && e <= s.y2 && (a = s.id)
                }
            return a
        }, o.prototype.getAutoFontSize = G, o.prototype.resetOverlayedCanvas = function() {
            this.overlaidCanvasCtx.clearRect(0, 0, this.width, this.height)
        }, o.prototype.clearCanvas = K, o.prototype.attachEvent = function(t) {
            this._events.push(t)
        }, o.prototype._touchEventHandler = function(t) {
            if (t.changedTouches && this.interactivityEnabled) {
                var e = [],
                    i = t.changedTouches,
                    a = i ? i[0] : t,
                    s = null;
                switch (t.type) {
                    case "touchstart":
                    case "MSPointerDown":
                        e = ["mousemove", "mousedown"], this._lastTouchData = $(a), this._lastTouchData.time = new Date;
                        break;
                    case "touchmove":
                    case "MSPointerMove":
                        e = ["mousemove"];
                        break;
                    case "touchend":
                    case "MSPointerUp":
                        var n = this._lastTouchData && this._lastTouchData.time ? new Date - this._lastTouchData.time : 0;
                        e = "touchstart" === this._lastTouchEventType || "MSPointerDown" === this._lastTouchEventType || 300 > n ? ["mouseup", "click"] : ["mouseup"];
                        break;
                    default:
                        return
                }
                if (!(i && 1 < i.length)) {
                    (s = $(a)).time = new Date;
                    try {
                        var o = s.y - this._lastTouchData.y;
                        n = s.time - this._lastTouchData.time;
                        (1 < Math.abs(o) && this._lastTouchData.scroll || 5 < Math.abs(o) && 250 > n) && (this._lastTouchData.scroll = !0)
                    } catch (t) {}
                    if (this._lastTouchEventType = t.type, this._lastTouchData.scroll && this.zoomEnabled) this.isDrag && this.resetOverlayedCanvas(), this.isDrag = !1;
                    else
                        for (i = 0; i < e.length; i++) s = e[i], (o = document.createEvent("MouseEvent")).initMouseEvent(s, !0, !0, window, 1, a.screenX, a.screenY, a.clientX, a.clientY, !1, !1, !1, !1, 0, null), a.target.dispatchEvent(o), (!l(this._lastTouchData.scroll) && !this._lastTouchData.scroll || !this._lastTouchData.scroll && 250 < n || "click" === s) && (t.preventManipulation && t.preventManipulation(), t.preventDefault && t.preventDefault())
                }
            }
        }, o.prototype._dispatchRangeEvent = function(t, e) {
            var i = {
                chart: this
            };
            i.type = t, i.trigger = e;
            var a = [];
            this.axisX && 0 < this.axisX.length && a.push("axisX"), this.axisX2 && 0 < this.axisX2.length && a.push("axisX2"), this.axisY && 0 < this.axisY.length && a.push("axisY"), this.axisY2 && 0 < this.axisY2.length && a.push("axisY2");
            for (var s = 0; s < a.length; s++)
                if (l(i[a[s]]) && (i[a[s]] = []), "axisY" === a[s])
                    for (var n = 0; n < this.axisY.length; n++) i[a[s]].push({
                        viewportMinimum: this[a[s]][n].sessionVariables.newViewportMinimum,
                        viewportMaximum: this[a[s]][n].sessionVariables.newViewportMaximum
                    });
                else if ("axisY2" === a[s])
                for (n = 0; n < this.axisY2.length; n++) i[a[s]].push({
                    viewportMinimum: this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum: this[a[s]][n].sessionVariables.newViewportMaximum
                });
            else if ("axisX" === a[s])
                for (n = 0; n < this.axisX.length; n++) i[a[s]].push({
                    viewportMinimum: this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum: this[a[s]][n].sessionVariables.newViewportMaximum
                });
            else if ("axisX2" === a[s])
                for (n = 0; n < this.axisX2.length; n++) i[a[s]].push({
                    viewportMinimum: this[a[s]][n].sessionVariables.newViewportMinimum,
                    viewportMaximum: this[a[s]][n].sessionVariables.newViewportMaximum
                });
            this.dispatchEvent(t, i, this)
        }, o.prototype._mouseEventHandler = function(t) {
            void 0 === t.target && t.srcElement && (t.target = t.srcElement);
            var e, i, a = $(t),
                s = t.type;
            if (t.which ? i = 3 == t.which : t.button && (i = 2 == t.button), o.capturedEventParam && (e = o.capturedEventParam, "mouseup" === s && (o.capturedEventParam = null, e.chart.overlaidCanvas.releaseCapture ? e.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", e.chart._mouseEventHandler, !1)), e.hasOwnProperty(s) && ("mouseup" !== s || e.chart.overlaidCanvas.releaseCapture ? t.target !== e.chart.overlaidCanvas && D || e[s].call(e.context, a.x, a.y) : t.target !== e.chart.overlaidCanvas && (e.chart.isDrag = !1))), this.interactivityEnabled)
                if (this._ignoreNextEvent) this._ignoreNextEvent = !1;
                else if (t.preventManipulation && t.preventManipulation(), t.preventDefault && t.preventDefault(), I && window.console && (window.console.log(s + " --\x3e x: " + a.x + "; y:" + a.y), i && window.console.log(t.which), "mouseup" === s && window.console.log("mouseup")), !i) {
                if (!o.capturedEventParam && this._events) {
                    for (var n = 0; n < this._events.length; n++)
                        if (this._events[n].hasOwnProperty(s)) {
                            if (i = (e = this._events[n]).bounds, a.x >= i.x1 && a.x <= i.x2 && a.y >= i.y1 && a.y <= i.y2) {
                                e[s].call(e.context, a.x, a.y), "mousedown" === s && !0 === e.capture ? (o.capturedEventParam = e, this.overlaidCanvas.setCapture ? this.overlaidCanvas.setCapture() : document.documentElement.addEventListener("mouseup", this._mouseEventHandler, !1)) : "mouseup" === s && (e.chart.overlaidCanvas.releaseCapture ? e.chart.overlaidCanvas.releaseCapture() : document.documentElement.removeEventListener("mouseup", this._mouseEventHandler, !1));
                                break
                            }
                            e = null
                        }
                    t.target.style.cursor = e && e.cursor ? e.cursor : this._defaultCursor
                }
                s = this.plotArea, (a.x < s.x1 || a.x > s.x2 || a.y < s.y1 || a.y > s.y2) && (this.toolTip && this.toolTip.enabled ? this.toolTip.hide() : this.resetOverlayedCanvas()), this.isDrag && this.zoomEnabled || !this._eventManager || this._eventManager.mouseEventHandler(t)
            }
        }, o.prototype._plotAreaMouseDown = function(t, e) {
            this.isDrag = !0, this.dragStartPoint = {
                x: t,
                y: e
            }
        }, o.prototype._plotAreaMouseUp = function(t, e) {
            if (("normal" === this.plotInfo.axisPlacement || "xySwapped" === this.plotInfo.axisPlacement) && this.isDrag) {
                var i = e - this.dragStartPoint.y,
                    a = t - this.dragStartPoint.x,
                    s = 0 <= this.zoomType.indexOf("x"),
                    n = 0 <= this.zoomType.indexOf("y"),
                    o = !1;
                if (this.resetOverlayedCanvas(), "xySwapped" === this.plotInfo.axisPlacement) {
                    var l = n;
                    n = s, s = l
                }
                if (this.panEnabled || this.zoomEnabled) {
                    if (this.panEnabled)
                        for (s = n = 0; s < this._axes.length; s++)(i = this._axes[s]).logarithmic ? i.viewportMinimum < i.minimum ? (n = i.minimum / i.viewportMinimum, i.sessionVariables.newViewportMinimum = i.viewportMinimum * n, i.sessionVariables.newViewportMaximum = i.viewportMaximum * n, o = !0) : i.viewportMaximum > i.maximum && (n = i.viewportMaximum / i.maximum, i.sessionVariables.newViewportMinimum = i.viewportMinimum / n, i.sessionVariables.newViewportMaximum = i.viewportMaximum / n, o = !0) : i.viewportMinimum < i.minimum ? (n = i.minimum - i.viewportMinimum, i.sessionVariables.newViewportMinimum = i.viewportMinimum + n, i.sessionVariables.newViewportMaximum = i.viewportMaximum + n, o = !0) : i.viewportMaximum > i.maximum && (n = i.viewportMaximum - i.maximum, i.sessionVariables.newViewportMinimum = i.viewportMinimum - n, i.sessionVariables.newViewportMaximum = i.viewportMaximum - n, o = !0);
                    else if ((!s || 2 < Math.abs(a)) && (!n || 2 < Math.abs(i)) && this.zoomEnabled) {
                        if (!this.dragStartPoint) return;
                        i = s ? this.dragStartPoint.x : this.plotArea.x1, a = n ? this.dragStartPoint.y : this.plotArea.y1, s = s ? t : this.plotArea.x2, n = n ? e : this.plotArea.y2, 2 < Math.abs(i - s) && 2 < Math.abs(a - n) && this._zoomPanToSelectedRegion(i, a, s, n) && (o = !0)
                    }
                    o && (this._ignoreNextEvent = !0, this._dispatchRangeEvent("rangeChanging", "zoom"), this.render(), this._dispatchRangeEvent("rangeChanged", "zoom"), o && this.zoomEnabled && "none" === this._zoomButton.style.display && (y(this._zoomButton, this._resetButton), b(this, this._zoomButton), b(this, this._resetButton)))
                }
            }
            if (this.isDrag = !1, "none" !== this.plotInfo.axisPlacement) {
                if (this.resetOverlayedCanvas(), this.axisX && 0 < this.axisX.length)
                    for (o = 0; o < this.axisX.length; o++) this.axisX[o].crosshair && this.axisX[o].crosshair.enabled && this.axisX[o].renderCrosshair(t, e);
                if (this.axisX2 && 0 < this.axisX2.length)
                    for (o = 0; o < this.axisX2.length; o++) this.axisX2[o].crosshair && this.axisX2[o].crosshair.enabled && this.axisX2[o].renderCrosshair(t, e);
                if (this.axisY && 0 < this.axisY.length)
                    for (o = 0; o < this.axisY.length; o++) this.axisY[o].crosshair && this.axisY[o].crosshair.enabled && this.axisY[o].renderCrosshair(t, e);
                if (this.axisY2 && 0 < this.axisY2.length)
                    for (o = 0; o < this.axisY2.length; o++) this.axisY2[o].crosshair && this.axisY2[o].crosshair.enabled && this.axisY2[o].renderCrosshair(t, e)
            }
        }, o.prototype._plotAreaMouseMove = function(t, e) {
            if (this.isDrag && "none" !== this.plotInfo.axisPlacement) {
                var i = 0,
                    a = 0,
                    s = i = null,
                    n = (s = 0 <= this.zoomType.indexOf("x"), 0 <= this.zoomType.indexOf("y")),
                    o = this;
                if ("xySwapped" === this.plotInfo.axisPlacement && (i = n, n = s, s = i), i = this.dragStartPoint.x - t, a = this.dragStartPoint.y - e, 2 < Math.abs(i) && 8 > Math.abs(i) && (this.panEnabled || this.zoomEnabled) ? this.toolTip.hide() : this.panEnabled || this.zoomEnabled || this.toolTip.mouseMoveHandler(t, e), (!s || 2 < Math.abs(i) || !n || 2 < Math.abs(a)) && (this.panEnabled || this.zoomEnabled))
                    if (this.panEnabled) s = {
                        x1: s ? this.plotArea.x1 + i : this.plotArea.x1,
                        y1: n ? this.plotArea.y1 + a : this.plotArea.y1,
                        x2: s ? this.plotArea.x2 + i : this.plotArea.x2,
                        y2: n ? this.plotArea.y2 + a : this.plotArea.y2
                    }, clearTimeout(o._panTimerId), o._panTimerId = setTimeout(function(i, a, s, n) {
                        return function() {
                            o._zoomPanToSelectedRegion(i, a, s, n, !0) && (o._dispatchRangeEvent("rangeChanging", "pan"), o.render(), o._dispatchRangeEvent("rangeChanged", "pan"), o.dragStartPoint.x = t, o.dragStartPoint.y = e)
                        }
                    }(s.x1, s.y1, s.x2, s.y2), 0);
                    else if (this.zoomEnabled) {
                    this.resetOverlayedCanvas(), i = this.overlaidCanvasCtx.globalAlpha, this.overlaidCanvasCtx.fillStyle = "#A89896";
                    a = s ? this.dragStartPoint.x : this.plotArea.x1;
                    var l = n ? this.dragStartPoint.y : this.plotArea.y1,
                        r = s ? t - this.dragStartPoint.x : this.plotArea.x2 - this.plotArea.x1,
                        h = n ? e - this.dragStartPoint.y : this.plotArea.y2 - this.plotArea.y1;
                    this.validateRegion(a, l, s ? t : this.plotArea.x2 - this.plotArea.x1, n ? e : this.plotArea.y2 - this.plotArea.y1, "xy" !== this.zoomType).isValid && (this.resetOverlayedCanvas(), this.overlaidCanvasCtx.fillStyle = "#99B2B5"), this.overlaidCanvasCtx.globalAlpha = .7, this.overlaidCanvasCtx.fillRect(a, l, r, h), this.overlaidCanvasCtx.globalAlpha = i
                }
            } else if (this.toolTip.mouseMoveHandler(t, e), "none" !== this.plotInfo.axisPlacement) {
                if (this.axisX && 0 < this.axisX.length)
                    for (s = 0; s < this.axisX.length; s++) this.axisX[s].crosshair && this.axisX[s].crosshair.enabled && this.axisX[s].renderCrosshair(t, e);
                if (this.axisX2 && 0 < this.axisX2.length)
                    for (s = 0; s < this.axisX2.length; s++) this.axisX2[s].crosshair && this.axisX2[s].crosshair.enabled && this.axisX2[s].renderCrosshair(t, e);
                if (this.axisY && 0 < this.axisY.length)
                    for (s = 0; s < this.axisY.length; s++) this.axisY[s].crosshair && this.axisY[s].crosshair.enabled && this.axisY[s].renderCrosshair(t, e);
                if (this.axisY2 && 0 < this.axisY2.length)
                    for (s = 0; s < this.axisY2.length; s++) this.axisY2[s].crosshair && this.axisY2[s].crosshair.enabled && this.axisY2[s].renderCrosshair(t, e)
            }
        }, o.prototype._zoomPanToSelectedRegion = function(t, e, i, a, s) {
            if (e = (t = this.validateRegion(t, e, i, a, s)).axesWithValidRange, i = t.axesRanges, t.isValid)
                for (a = 0; a < e.length; a++) s = i[a], e[a].setViewPortRange(s.val1, s.val2), this.syncCharts && this.syncCharts(s.val1, s.val2);
            return t.isValid
        }, o.prototype.validateRegion = function(t, e, i, a, s) {
            s = s || !1;
            for (var n = 0 <= this.zoomType.indexOf("x"), o = 0 <= this.zoomType.indexOf("y"), l = !1, r = [], h = [], d = [], x = 0; x < this._axes.length; x++)("axisX" === this._axes[x].type && n || "axisY" === this._axes[x].type && o) && h.push(this._axes[x]);
            for (o = 0; o < h.length; o++) {
                n = !1;
                if ((u = (x = h[o]).convertPixelToValue({
                        x: t,
                        y: e
                    })) > (p = x.convertPixelToValue({
                        x: i,
                        y: a
                    }))) var c = p,
                    p = u,
                    u = c;
                if (x.scaleBreaks)
                    for (c = 0; !n && c < x.scaleBreaks._appliedBreaks.length; c++) n = x.scaleBreaks._appliedBreaks[c].startValue <= u && x.scaleBreaks._appliedBreaks[c].endValue >= p;
                if (isFinite(x.dataInfo.minDiff))
                    if (c = x.getApparentDifference(u, p, null, !0), n || !(this.panEnabled && x.scaleBreaks && x.scaleBreaks._appliedBreaks.length) && (x.logarithmic && c < Math.pow(x.dataInfo.minDiff, 3) || !x.logarithmic && c < 3 * Math.abs(x.dataInfo.minDiff)) || u < x.minimum || p > x.maximum) {
                        if (!s) {
                            l = !1;
                            break
                        }
                    } else r.push(x), d.push({
                        val1: u,
                        val2: p
                    }), l = !0
            }
            return {
                isValid: l,
                axesWithValidRange: r,
                axesRanges: d
            }
        }, o.prototype.preparePlotArea = function() {
            var t = this.plotArea;
            if (!D && (0 < t.x1 || 0 < t.y1) && t.ctx.translate(t.x1, t.y1), (this.axisX[0] || this.axisX2[0]) && (this.axisY[0] || this.axisY2[0])) {
                var e = this.axisX[0] ? this.axisX[0].lineCoordinates : this.axisX2[0].lineCoordinates;
                if (this.axisY && 0 < this.axisY.length && this.axisY[0]) {
                    var i = this.axisY[0];
                    t.x1 = e.x1 < e.x2 ? e.x1 : i.lineCoordinates.x1, t.y1 = e.y1 < i.lineCoordinates.y1 ? e.y1 : i.lineCoordinates.y1, t.x2 = e.x2 > i.lineCoordinates.x2 ? e.x2 : i.lineCoordinates.x2, t.y2 = e.y2 > e.y1 ? e.y2 : i.lineCoordinates.y2, t.width = t.x2 - t.x1, t.height = t.y2 - t.y1
                }
                this.axisY2 && 0 < this.axisY2.length && this.axisY2[0] && (i = this.axisY2[0], t.x1 = e.x1 < e.x2 ? e.x1 : i.lineCoordinates.x1, t.y1 = e.y1 < i.lineCoordinates.y1 ? e.y1 : i.lineCoordinates.y1, t.x2 = e.x2 > i.lineCoordinates.x2 ? e.x2 : i.lineCoordinates.x2, t.y2 = e.y2 > e.y1 ? e.y2 : i.lineCoordinates.y2, t.width = t.x2 - t.x1, t.height = t.y2 - t.y1)
            } else e = this.layoutManager.getFreeSpace(), t.x1 = e.x1, t.x2 = e.x2, t.y1 = e.y1, t.y2 = e.y2, t.width = e.width, t.height = e.height;
            D || (t.canvas.width = t.width, t.canvas.height = t.height, t.canvas.style.left = t.x1 + "px", t.canvas.style.top = t.y1 + "px", (0 < t.x1 || 0 < t.y1) && t.ctx.translate(-t.x1, -t.y1)), t.layoutManager = new k(t.x1, t.y1, t.x2, t.y2, 2)
        }, o.prototype.renderIndexLabels = function(t) {
            var e = t || this.plotArea.ctx,
                i = this.plotArea,
                a = 0,
                s = 0,
                n = 0,
                o = 0,
                r = a = o = s = n = 0,
                h = 0;
            for (t = 0; t < this._indexLabels.length; t++) {
                var x, c, u = this._indexLabels[t],
                    m = u.chartType.toLowerCase();
                r = p("indexLabelFontColor", u.dataPoint, u.dataSeries), h = p("indexLabelFontSize", u.dataPoint, u.dataSeries);
                x = p("indexLabelFontFamily", u.dataPoint, u.dataSeries), c = p("indexLabelFontStyle", u.dataPoint, u.dataSeries);
                o = p("indexLabelFontWeight", u.dataPoint, u.dataSeries);
                var g = p("indexLabelBackgroundColor", u.dataPoint, u.dataSeries),
                    b = (s = p("indexLabelMaxWidth", u.dataPoint, u.dataSeries), n = p("indexLabelWrap", u.dataPoint, u.dataSeries), p("indexLabelLineDashType", u.dataPoint, u.dataSeries)),
                    y = p("indexLabelLineColor", u.dataPoint, u.dataSeries),
                    v = l(u.dataPoint.indexLabelLineThickness) ? l(u.dataSeries.options.indexLabelLineThickness) ? 0 : u.dataSeries.options.indexLabelLineThickness : u.dataPoint.indexLabelLineThickness,
                    f = (a = 0 < v ? Math.min(10, ("normal" === this.plotInfo.axisPlacement ? this.plotArea.height : this.plotArea.width) << 0) : 0, {
                        percent: null,
                        total: null
                    }),
                    k = null;
                (0 <= u.dataSeries.type.indexOf("stacked") || "pie" === u.dataSeries.type || "doughnut" === u.dataSeries.type) && (f = this.getPercentAndTotal(u.dataSeries, u.dataPoint)), (u.dataSeries.indexLabelFormatter || u.dataPoint.indexLabelFormatter) && (k = {
                    chart: this,
                    dataSeries: u.dataSeries,
                    dataPoint: u.dataPoint,
                    index: u.indexKeyword,
                    total: f.total,
                    percent: f.percent
                });
                var T = u.dataPoint.indexLabelFormatter ? u.dataPoint.indexLabelFormatter(k) : u.dataPoint.indexLabel ? this.replaceKeywordsWithValue(u.dataPoint.indexLabel, u.dataPoint, u.dataSeries, null, u.indexKeyword) : u.dataSeries.indexLabelFormatter ? u.dataSeries.indexLabelFormatter(k) : u.dataSeries.indexLabel ? this.replaceKeywordsWithValue(u.dataSeries.indexLabel, u.dataPoint, u.dataSeries, null, u.indexKeyword) : null;
                if (null !== T && "" !== T) {
                    f = p("indexLabelPlacement", u.dataPoint, u.dataSeries), k = p("indexLabelOrientation", u.dataPoint, u.dataSeries);
                    var P = u.direction,
                        w = u.dataSeries.axisX,
                        C = u.dataSeries.axisY,
                        S = !1;
                    if ((g = new M(e, {
                            x: 0,
                            y: 0,
                            maxWidth: s || .5 * this.width,
                            maxHeight: n ? 5 * h : 1.5 * h,
                            angle: "horizontal" === k ? 0 : -90,
                            text: T,
                            padding: 0,
                            backgroundColor: g,
                            horizontalAlign: "left",
                            fontSize: h,
                            fontFamily: x,
                            fontWeight: o,
                            fontColor: r,
                            fontStyle: c,
                            textBaseline: "top"
                        })).measureText(), u.dataSeries.indexLabelMaxWidth = g.maxWidth, "stackedarea100" === m) {
                        if (u.point.x < i.x1 || u.point.x > i.x2 || u.point.y < i.y1 - 1 || u.point.y > i.y2 + 1) continue
                    } else if ("rangearea" === m || "rangesplinearea" === m) {
                        if (u.dataPoint.x < w.viewportMinimum || u.dataPoint.x > w.viewportMaximum || Math.max.apply(null, u.dataPoint.y) < C.viewportMinimum || Math.min.apply(null, u.dataPoint.y) > C.viewportMaximum) continue
                    } else if (0 <= m.indexOf("line") || 0 <= m.indexOf("area") || 0 <= m.indexOf("bubble") || 0 <= m.indexOf("scatter")) {
                        if (u.dataPoint.x < w.viewportMinimum || u.dataPoint.x > w.viewportMaximum || u.dataPoint.y < C.viewportMinimum || u.dataPoint.y > C.viewportMaximum) continue
                    } else if (0 <= m.indexOf("column") || "waterfall" === m || "error" === m && !u.axisSwapped) {
                        if (u.dataPoint.x < w.viewportMinimum || u.dataPoint.x > w.viewportMaximum || u.bounds.y1 > i.y2 || u.bounds.y2 < i.y1) continue
                    } else if (0 <= m.indexOf("bar") || "error" === m) {
                        if (u.dataPoint.x < w.viewportMinimum || u.dataPoint.x > w.viewportMaximum || u.bounds.x1 > i.x2 || u.bounds.x2 < i.x1) continue
                    } else if ("candlestick" === m || "ohlc" === m) {
                        if (u.dataPoint.x < w.viewportMinimum || u.dataPoint.x > w.viewportMaximum || Math.max.apply(null, u.dataPoint.y) < C.viewportMinimum || Math.min.apply(null, u.dataPoint.y) > C.viewportMaximum) continue
                    } else if (u.dataPoint.x < w.viewportMinimum || u.dataPoint.x > w.viewportMaximum) continue;
                    s = o = 2, "horizontal" === k ? (r = g.width, h = g.height) : (h = g.width, r = g.height), "normal" === this.plotInfo.axisPlacement ? (0 <= m.indexOf("line") || 0 <= m.indexOf("area") ? (f = "auto", o = 4) : 0 <= m.indexOf("stacked") ? "auto" === f && (f = "inside") : "bubble" !== m && "scatter" !== m || (f = "inside"), x = u.point.x - r / 2, "inside" !== f ? (s = i.y1, n = i.y2, 0 < P ? (c = u.point.y - h - o - a) < s && (S = (c = "auto" === f ? Math.max(u.point.y, s) + o + a : s + o + a) + h > u.point.y) : (c = u.point.y + o + a) > n - h - o - a && (S = (c = "auto" === f ? Math.min(u.point.y, n) - h - o - a : n - h - o - a) < u.point.y)) : (s = Math.max(u.bounds.y1, i.y1), n = Math.min(u.bounds.y2, i.y2), a = 0 <= m.indexOf("range") || "error" === m ? 0 < P ? Math.max(u.bounds.y1, i.y1) + h / 2 + o : Math.min(u.bounds.y2, i.y2) - h / 2 - o : (Math.max(u.bounds.y1, i.y1) + Math.min(u.bounds.y2, i.y2)) / 2, 0 < P ? (c = Math.max(u.point.y, a) - h / 2) < s && ("bubble" === m || "scatter" === m) && (c = Math.max(u.point.y - h - o, i.y1 + o)) : (c = Math.min(u.point.y, a) - h / 2) > n - h - o && ("bubble" === m || "scatter" === m) && (c = Math.min(u.point.y + o, i.y2 - h - o)), c = Math.min(c, n - h))) : (0 <= m.indexOf("line") || 0 <= m.indexOf("area") || 0 <= m.indexOf("scatter") ? (f = "auto", s = 4) : 0 <= m.indexOf("stacked") ? "auto" === f && (f = "inside") : "bubble" === m && (f = "inside"), c = u.point.y - h / 2, "inside" !== f ? (o = i.x1, n = i.x2, 0 > P ? (x = u.point.x - r - s - a) < o && (S = (x = "auto" === f ? Math.max(u.point.x, o) + s + a : o + s + a) + r > u.point.x) : (x = u.point.x + s + a) > n - r - s - a && (S = (x = "auto" === f ? Math.min(u.point.x, n) - r - s - a : n - r - s - a) < u.point.x)) : (o = Math.max(u.bounds.x1, i.x1), Math.min(u.bounds.x2, i.x2), a = 0 <= m.indexOf("range") || "error" === m ? 0 > P ? Math.max(u.bounds.x1, i.x1) + r / 2 + s : Math.min(u.bounds.x2, i.x2) - r / 2 - s : (Math.max(u.bounds.x1, i.x1) + Math.min(u.bounds.x2, i.x2)) / 2, x = 0 > P ? Math.max(u.point.x, a) - r / 2 : Math.min(u.point.x, a) - r / 2, x = Math.max(x, o))), "vertical" === k && (c += h), g.x = x, g.y = c, g.render(!0), v && "inside" !== f && (0 > m.indexOf("bar") && ("error" !== m || !u.axisSwapped) && u.point.x > i.x1 && u.point.x < i.x2 || !S) && (0 > m.indexOf("column") && ("error" !== m || u.axisSwapped) && u.point.y > i.y1 && u.point.y < i.y2 || !S) && (e.lineWidth = v, e.strokeStyle = y || "gray", e.setLineDash && e.setLineDash(d(b, v)), e.beginPath(), e.moveTo(u.point.x, u.point.y), 0 <= m.indexOf("bar") || "error" === m && u.axisSwapped ? e.lineTo(x + (0 < u.direction ? 0 : r), c + ("horizontal" === k ? h : -h) / 2) : 0 <= m.indexOf("column") || "error" === m && !u.axisSwapped ? e.lineTo(x + r / 2, c + ((0 < u.direction ? h : -h) + ("horizontal" === k ? h : -h)) / 2) : e.lineTo(x + r / 2, c + ((c < u.point.y ? h : -h) + ("horizontal" === k ? h : -h)) / 2), e.stroke())
                }
            }
            for (e = {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0,
                    startTimePercent: .7
                }, t = 0; t < this._indexLabels.length; t++) g = p("indexLabelBackgroundColor", (u = this._indexLabels[t]).dataPoint, u.dataSeries), u.dataSeries.indexLabelBackgroundColor = l(g) ? D ? "transparent" : null : g;
            return e
        }, o.prototype.renderLine = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a = this._eventManager.ghostCtx;
                i.save();
                var s = this.plotArea;
                i.beginPath(), i.rect(s.x1, s.y1, s.width, s.height), i.clip();
                for (var n, o = [], l = 0; l < t.dataSeriesIndexes.length; l++) {
                    var r = t.dataSeriesIndexes[l],
                        h = this.data[r];
                    i.lineWidth = h.lineThickness;
                    var x = h.dataPoints,
                        c = "solid";
                    if (i.setLineDash) {
                        var p = d(h.nullDataLineDashType, h.lineThickness),
                            u = d(c = h.lineDashType, h.lineThickness);
                        i.setLineDash(u)
                    }
                    var m = h.id;
                    this._eventManager.objectMap[m] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: r
                    }, m = void 0, a.strokeStyle = m, a.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0;
                    m = h._colorSet;
                    var g = m = h.lineColor = h.options.lineColor ? h.options.lineColor : m[0];
                    i.strokeStyle = m;
                    var b, y, v = !0,
                        f = 0;
                    if (i.beginPath(), 0 < x.length) {
                        var k = !1;
                        for (f = 0; f < x.length; f++)
                            if (!((b = x[f].x.getTime ? x[f].x.getTime() : x[f].x) < t.axisX.dataInfo.viewPortMin || b > t.axisX.dataInfo.viewPortMax && (!h.connectNullData || !k)))
                                if ("number" != typeof x[f].y) 0 < f && !(h.connectNullData || k || v) && (i.stroke(), D && a.stroke()), k = !0;
                                else {
                                    b = t.axisX.convertValueToPixel(b), y = t.axisY.convertValueToPixel(x[f].y);
                                    var M = h.dataPointIds[f];
                                    if (this._eventManager.objectMap[M] = {
                                            id: M,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: r,
                                            dataPointIndex: f,
                                            x1: b,
                                            y1: y
                                        }, v || k ? (!v && h.connectNullData ? (i.setLineDash && (h.options.nullDataLineDashType || c === h.lineDashType && h.lineDashType !== h.nullDataLineDashType) && (i.stroke(), i.beginPath(), i.moveTo(n.x, n.y), c = h.nullDataLineDashType, i.setLineDash(p)), i.lineTo(b, y), D && a.lineTo(b, y)) : (i.beginPath(), i.moveTo(b, y), D && (a.beginPath(), a.moveTo(b, y))), k = v = !1) : (i.lineTo(b, y), D && a.lineTo(b, y), 0 == f % 500 && (i.stroke(), i.beginPath(), i.moveTo(b, y), D && (a.stroke(), a.beginPath(), a.moveTo(b, y)))), n = {
                                            x: b,
                                            y: y
                                        }, f < x.length - 1 && (g !== (x[f].lineColor || m) || c !== (x[f].lineDashType || h.lineDashType)) && (i.stroke(), i.beginPath(), i.moveTo(b, y), g = x[f].lineColor || m, i.strokeStyle = g, i.setLineDash && (x[f].lineDashType ? (c = x[f].lineDashType, i.setLineDash(d(c, h.lineThickness))) : (c = h.lineDashType, i.setLineDash(u)))), 0 < x[f].markerSize || 0 < h.markerSize) {
                                        var T = h.getMarkerProperties(f, b, y, i);
                                        o.push(T), M = void 0, D && o.push({
                                            x: b,
                                            y: y,
                                            ctx: a,
                                            type: T.type,
                                            size: T.size,
                                            color: M,
                                            borderColor: M,
                                            borderThickness: T.borderThickness
                                        })
                                    }(x[f].indexLabel || h.indexLabel || x[f].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "line",
                                        dataPoint: x[f],
                                        dataSeries: h,
                                        point: {
                                            x: b,
                                            y: y
                                        },
                                        direction: 0 > x[f].y === t.axisY.reversed ? 1 : -1,
                                        color: m
                                    })
                                }
                        i.stroke(), D && a.stroke()
                    }
                }
                return et.drawMarkers(o), D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(s.x1, s.y1, s.width, s.height), a.beginPath()), i.restore(), i.beginPath(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderStepLine = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a = this._eventManager.ghostCtx;
                i.save();
                var s = this.plotArea;
                i.beginPath(), i.rect(s.x1, s.y1, s.width, s.height), i.clip();
                for (var n, o = [], l = 0; l < t.dataSeriesIndexes.length; l++) {
                    var r = t.dataSeriesIndexes[l],
                        h = this.data[r];
                    i.lineWidth = h.lineThickness;
                    var x = h.dataPoints,
                        c = "solid";
                    if (i.setLineDash) {
                        var p = d(h.nullDataLineDashType, h.lineThickness),
                            u = d(c = h.lineDashType, h.lineThickness);
                        i.setLineDash(u)
                    }
                    var m = h.id;
                    this._eventManager.objectMap[m] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: r
                    }, m = void 0, a.strokeStyle = m, a.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0;
                    m = h._colorSet;
                    var g = m = h.lineColor = h.options.lineColor ? h.options.lineColor : m[0];
                    i.strokeStyle = m;
                    var b, y, v = !0,
                        f = 0;
                    if (i.beginPath(), 0 < x.length) {
                        var k = !1;
                        for (f = 0; f < x.length; f++)
                            if (!((b = x[f].getTime ? x[f].x.getTime() : x[f].x) < t.axisX.dataInfo.viewPortMin || b > t.axisX.dataInfo.viewPortMax && (!h.connectNullData || !k)))
                                if ("number" != typeof x[f].y) 0 < f && !(h.connectNullData || k || v) && (i.stroke(), D && a.stroke()), k = !0;
                                else {
                                    var M = y;
                                    b = t.axisX.convertValueToPixel(b), y = t.axisY.convertValueToPixel(x[f].y);
                                    var T = h.dataPointIds[f];
                                    this._eventManager.objectMap[T] = {
                                        id: T,
                                        objectType: "dataPoint",
                                        dataSeriesIndex: r,
                                        dataPointIndex: f,
                                        x1: b,
                                        y1: y
                                    }, v || k ? (!v && h.connectNullData ? (i.setLineDash && (h.options.nullDataLineDashType || c === h.lineDashType && h.lineDashType !== h.nullDataLineDashType) && (i.stroke(), i.beginPath(), i.moveTo(n.x, n.y), c = h.nullDataLineDashType, i.setLineDash(p)), i.lineTo(b, M), i.lineTo(b, y), D && (a.lineTo(b, M), a.lineTo(b, y))) : (i.beginPath(), i.moveTo(b, y), D && (a.beginPath(), a.moveTo(b, y))), k = v = !1) : (i.lineTo(b, M), D && a.lineTo(b, M), i.lineTo(b, y), D && a.lineTo(b, y), 0 == f % 500 && (i.stroke(), i.beginPath(), i.moveTo(b, y), D && (a.stroke(), a.beginPath(), a.moveTo(b, y)))), n = {
                                        x: b,
                                        y: y
                                    }, f < x.length - 1 && (g !== (x[f].lineColor || m) || c !== (x[f].lineDashType || h.lineDashType)) && (i.stroke(), i.beginPath(), i.moveTo(b, y), g = x[f].lineColor || m, i.strokeStyle = g, i.setLineDash && (x[f].lineDashType ? (c = x[f].lineDashType, i.setLineDash(d(c, h.lineThickness))) : (c = h.lineDashType, i.setLineDash(u)))), (0 < x[f].markerSize || 0 < h.markerSize) && (M = h.getMarkerProperties(f, b, y, i), o.push(M), T = void 0, D && o.push({
                                        x: b,
                                        y: y,
                                        ctx: a,
                                        type: M.type,
                                        size: M.size,
                                        color: T,
                                        borderColor: T,
                                        borderThickness: M.borderThickness
                                    })), (x[f].indexLabel || h.indexLabel || x[f].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "stepLine",
                                        dataPoint: x[f],
                                        dataSeries: h,
                                        point: {
                                            x: b,
                                            y: y
                                        },
                                        direction: 0 > x[f].y === t.axisY.reversed ? 1 : -1,
                                        color: m
                                    })
                                }
                        i.stroke(), D && a.stroke()
                    }
                }
                return et.drawMarkers(o), D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(s.x1, s.y1, s.width, s.height), a.beginPath()), i.restore(), i.beginPath(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderSpline = function(t) {
            function e(t) {
                if (0 < (t = _(t, 2)).length) {
                    a.beginPath(), D && s.beginPath(), a.moveTo(t[0].x, t[0].y), t[0].newStrokeStyle && (a.strokeStyle = t[0].newStrokeStyle), t[0].newLineDashArray && a.setLineDash(t[0].newLineDashArray), D && s.moveTo(t[0].x, t[0].y);
                    for (var e = 0; e < t.length - 3; e += 3) a.bezierCurveTo(t[e + 1].x, t[e + 1].y, t[e + 2].x, t[e + 2].y, t[e + 3].x, t[e + 3].y), D && s.bezierCurveTo(t[e + 1].x, t[e + 1].y, t[e + 2].x, t[e + 2].y, t[e + 3].x, t[e + 3].y), (0 < e && 0 == e % 3e3 || t[e + 3].newStrokeStyle || t[e + 3].newLineDashArray) && (a.stroke(), a.beginPath(), a.moveTo(t[e + 3].x, t[e + 3].y), t[e + 3].newStrokeStyle && (a.strokeStyle = t[e + 3].newStrokeStyle), t[e + 3].newLineDashArray && a.setLineDash(t[e + 3].newLineDashArray), D && (s.stroke(), s.beginPath(), s.moveTo(t[e + 3].x, t[e + 3].y)));
                    a.stroke(), D && s.stroke()
                }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
                a = D ? this._preRenderCtx : i;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s = this._eventManager.ghostCtx;
                a.save();
                var n = this.plotArea;
                a.beginPath(), a.rect(n.x1, n.y1, n.width, n.height), a.clip();
                for (var o = [], l = 0; l < t.dataSeriesIndexes.length; l++) {
                    var r = t.dataSeriesIndexes[l],
                        h = this.data[r];
                    a.lineWidth = h.lineThickness;
                    var x = h.dataPoints,
                        c = "solid";
                    if (a.setLineDash) {
                        var p = d(h.nullDataLineDashType, h.lineThickness),
                            u = d(c = h.lineDashType, h.lineThickness);
                        a.setLineDash(u)
                    }
                    var m = h.id;
                    this._eventManager.objectMap[m] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: r
                    }, m = void 0, s.strokeStyle = m, s.lineWidth = 0 < h.lineThickness ? Math.max(h.lineThickness, 4) : 0;
                    m = h._colorSet;
                    var g = m = h.lineColor = h.options.lineColor ? h.options.lineColor : m[0];
                    a.strokeStyle = m;
                    var b, y, v = 0,
                        f = [];
                    if (a.beginPath(), 0 < x.length)
                        for (y = !1, v = 0; v < x.length; v++)
                            if (!((b = x[v].getTime ? x[v].x.getTime() : x[v].x) < t.axisX.dataInfo.viewPortMin || b > t.axisX.dataInfo.viewPortMax && (!h.connectNullData || !y)))
                                if ("number" != typeof x[v].y) 0 < v && !y && (h.connectNullData ? a.setLineDash && 0 < f.length && (h.options.nullDataLineDashType || !x[v - 1].lineDashType) && (f[f.length - 1].newLineDashArray = p, c = h.nullDataLineDashType) : (e(f), f = [])), y = !0;
                                else {
                                    b = t.axisX.convertValueToPixel(b), y = t.axisY.convertValueToPixel(x[v].y);
                                    var k = h.dataPointIds[v];
                                    if (this._eventManager.objectMap[k] = {
                                            id: k,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: r,
                                            dataPointIndex: v,
                                            x1: b,
                                            y1: y
                                        }, f[f.length] = {
                                            x: b,
                                            y: y
                                        }, v < x.length - 1 && (g !== (x[v].lineColor || m) || c !== (x[v].lineDashType || h.lineDashType)) && (g = x[v].lineColor || m, f[f.length - 1].newStrokeStyle = g, a.setLineDash && (x[v].lineDashType ? (c = x[v].lineDashType, f[f.length - 1].newLineDashArray = d(c, h.lineThickness)) : (c = h.lineDashType, f[f.length - 1].newLineDashArray = u))), 0 < x[v].markerSize || 0 < h.markerSize) {
                                        var M = h.getMarkerProperties(v, b, y, a);
                                        o.push(M), k = void 0, D && o.push({
                                            x: b,
                                            y: y,
                                            ctx: s,
                                            type: M.type,
                                            size: M.size,
                                            color: k,
                                            borderColor: k,
                                            borderThickness: M.borderThickness
                                        })
                                    }(x[v].indexLabel || h.indexLabel || x[v].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "spline",
                                        dataPoint: x[v],
                                        dataSeries: h,
                                        point: {
                                            x: b,
                                            y: y
                                        },
                                        direction: 0 > x[v].y === t.axisY.reversed ? 1 : -1,
                                        color: m
                                    }), y = !1
                                }
                    e(f)
                }
                return et.drawMarkers(o), D && (i.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(n.x1, n.y1, n.width, n.height), s.beginPath()), a.restore(), a.beginPath(), {
                    source: i,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderColumn = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n, o = null,
                    l = this.plotArea,
                    r = 0,
                    h = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                    d = (r = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, this.plotArea.width / t.plotType.totalDataSeries * .9) << 0),
                    x = t.axisX.dataInfo.minDiff;
                for (isFinite(x) || (x = .3 * Math.abs(t.axisX.range)), x = this.dataPointWidth = this.options.dataPointWidth ? this.dataPointWidth : l.width * (t.axisX.logarithmic ? Math.log(x) / Math.log(t.axisX.range) : Math.abs(x) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && r > d && (r = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, d)), !this.dataPointMaxWidth && this.dataPointMinWidth && d < r && (d = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, r)), x < r && (x = r), x > d && (x = d), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(l.x1, l.y1, l.width, l.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.clip()), d = 0; d < t.dataSeriesIndexes.length; d++) {
                    var c = t.dataSeriesIndexes[d],
                        p = this.data[c],
                        u = p.dataPoints;
                    if (0 < u.length) {
                        var m = !!(5 < x && p.bevelEnabled);
                        for (r = 0; r < u.length; r++)
                            if (!((n = u[r].getTime ? u[r].x.getTime() : u[r].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && "number" == typeof u[r].y) {
                                a = t.axisX.convertValueToPixel(n), s = t.axisY.convertValueToPixel(u[r].y), a = t.axisX.reversed ? a + t.plotType.totalDataSeries * x / 2 - (t.previousDataSeriesCount + d) * x << 0 : a - t.plotType.totalDataSeries * x / 2 + (t.previousDataSeriesCount + d) * x << 0;
                                var g, b = t.axisX.reversed ? a - x << 0 : a + x << 0;
                                0 <= u[r].y ? g = h : (g = s, s = h), s > g && (o = s, s = g, g = o), o = u[r].color ? u[r].color : p._colorSet[r % p._colorSet.length], st(i, a, s, b, g, o, 0, null, m && 0 <= u[r].y, 0 > u[r].y && m, !1, !1, p.fillOpacity), o = p.dataPointIds[r], this._eventManager.objectMap[o] = {
                                    id: o,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: c,
                                    dataPointIndex: r,
                                    x1: a,
                                    y1: s,
                                    x2: b,
                                    y2: g
                                }, o = void 0, D && st(this._eventManager.ghostCtx, a, s, b, g, o, 0, null, !1, !1, !1, !1), (u[r].indexLabel || p.indexLabel || u[r].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "column",
                                    dataPoint: u[r],
                                    dataSeries: p,
                                    point: {
                                        x: a + (b - a) / 2,
                                        y: 0 > u[r].y === t.axisY.reversed ? s : g
                                    },
                                    direction: 0 > u[r].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: a,
                                        y1: Math.min(s, g),
                                        x2: b,
                                        y2: Math.max(s, g)
                                    },
                                    color: o
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.yScaleAnimation,
                    easingFunction: tt.easing.easeOutQuart,
                    animationBase: h < t.axisY.bounds.y1 ? t.axisY.bounds.y1 : h > t.axisY.bounds.y2 ? t.axisY.bounds.y2 : h
                }
            }
        }, o.prototype.renderStackedColumn = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n = null,
                    o = this.plotArea,
                    l = [],
                    r = [],
                    h = [],
                    d = [],
                    x = 0,
                    c = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0);
                x = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                a = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0;
                var p = t.axisX.dataInfo.minDiff;
                isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.options.dataPointWidth ? this.dataPointWidth : o.width * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && x > a && (x = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, a)), !this.dataPointMaxWidth && this.dataPointMinWidth && a < x && (a = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, x)), p < x && (p = x), p > a && (p = a), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(o.x1, o.y1, o.width, o.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip());
                for (var u = 0; u < t.dataSeriesIndexes.length; u++) {
                    var m = t.dataSeriesIndexes[u],
                        g = this.data[m],
                        b = g.dataPoints;
                    if (0 < b.length) {
                        var y = !!(5 < p && g.bevelEnabled);
                        for (i.strokeStyle = "#4572A7 ", x = 0; x < b.length; x++)
                            if (!((n = b[x].x.getTime ? b[x].x.getTime() : b[x].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && "number" == typeof b[x].y) {
                                var v, f = (a = t.axisX.convertValueToPixel(n)) - t.plotType.plotUnits.length * p / 2 + t.index * p << 0,
                                    k = f + p << 0;
                                if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < b[x].y) h[n] = b[x].y + (h[n] ? h[n] : 0), 0 < h[n] && (s = t.axisY.convertValueToPixel(h[n]), v = void 0 !== l[n] ? l[n] : c, l[n] = s);
                                else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= b[x].y) d[n] = b[x].y + (d[n] ? d[n] : 0), v = t.axisY.convertValueToPixel(d[n]), s = void 0 !== r[n] ? r[n] : c, r[n] = v;
                                else if (s = t.axisY.convertValueToPixel(b[x].y), 0 <= b[x].y) {
                                    var M = void 0 !== l[n] ? l[n] : 0;
                                    s -= M, v = c - M, l[n] = M + (v - s)
                                } else v = s + (M = r[n] ? r[n] : 0), s = c + M, r[n] = M + (v - s);
                                n = b[x].color ? b[x].color : g._colorSet[x % g._colorSet.length], st(i, f, s, k, v, n, 0, null, y && 0 <= b[x].y, 0 > b[x].y && y, !1, !1, g.fillOpacity), n = g.dataPointIds[x], this._eventManager.objectMap[n] = {
                                    id: n,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: m,
                                    dataPointIndex: x,
                                    x1: f,
                                    y1: s,
                                    x2: k,
                                    y2: v
                                }, n = void 0, D && st(this._eventManager.ghostCtx, f, s, k, v, n, 0, null, !1, !1, !1, !1), (b[x].indexLabel || g.indexLabel || b[x].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stackedColumn",
                                    dataPoint: b[x],
                                    dataSeries: g,
                                    point: {
                                        x: a,
                                        y: 0 <= b[x].y ? s : v
                                    },
                                    direction: 0 > b[x].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: f,
                                        y1: Math.min(s, v),
                                        x2: k,
                                        y2: Math.max(s, v)
                                    },
                                    color: n
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.yScaleAnimation,
                    easingFunction: tt.easing.easeOutQuart,
                    animationBase: c < t.axisY.bounds.y1 ? t.axisY.bounds.y1 : c > t.axisY.bounds.y2 ? t.axisY.bounds.y2 : c
                }
            }
        }, o.prototype.renderStackedColumn100 = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n = null,
                    o = this.plotArea,
                    l = [],
                    r = [],
                    h = [],
                    d = [],
                    x = 0,
                    c = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0);
                x = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                a = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.width << 0;
                var p = t.axisX.dataInfo.minDiff;
                isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.options.dataPointWidth ? this.dataPointWidth : o.width * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && x > a && (x = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, a)), !this.dataPointMaxWidth && this.dataPointMinWidth && a < x && (a = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, x)), p < x && (p = x), p > a && (p = a), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(o.x1, o.y1, o.width, o.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip());
                for (var u = 0; u < t.dataSeriesIndexes.length; u++) {
                    var m = t.dataSeriesIndexes[u],
                        g = this.data[m],
                        b = g.dataPoints;
                    if (0 < b.length) {
                        var y = !!(5 < p && g.bevelEnabled);
                        for (x = 0; x < b.length; x++)
                            if (!((n = b[x].x.getTime ? b[x].x.getTime() : b[x].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && "number" == typeof b[x].y) {
                                a = t.axisX.convertValueToPixel(n), s = 0 !== t.dataPointYSums[n] ? b[x].y / t.dataPointYSums[n] * 100 : 0;
                                var v, f = a - t.plotType.plotUnits.length * p / 2 + t.index * p << 0,
                                    k = f + p << 0;
                                if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < b[x].y) {
                                    if (h[n] = s + (void 0 !== h[n] ? h[n] : 0), 0 >= h[n]) continue;
                                    s = t.axisY.convertValueToPixel(h[n]), v = l[n] ? l[n] : c, l[n] = s
                                } else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= b[x].y) d[n] = s + (void 0 !== d[n] ? d[n] : 0), v = t.axisY.convertValueToPixel(d[n]), s = r[n] ? r[n] : c, r[n] = v;
                                else if (s = t.axisY.convertValueToPixel(s), 0 <= b[x].y) {
                                    var M = void 0 !== l[n] ? l[n] : 0;
                                    s -= M, v = c - M, t.dataSeriesIndexes.length - 1 === u && 1 >= Math.abs(o.y1 - s) && (s = o.y1), l[n] = M + (v - s)
                                } else v = s + (M = void 0 !== r[n] ? r[n] : 0), s = c + M, t.dataSeriesIndexes.length - 1 === u && 1 >= Math.abs(o.y2 - v) && (v = o.y2), r[n] = M + (v - s);
                                n = b[x].color ? b[x].color : g._colorSet[x % g._colorSet.length], st(i, f, s, k, v, n, 0, null, y && 0 <= b[x].y, 0 > b[x].y && y, !1, !1, g.fillOpacity), n = g.dataPointIds[x], this._eventManager.objectMap[n] = {
                                    id: n,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: m,
                                    dataPointIndex: x,
                                    x1: f,
                                    y1: s,
                                    x2: k,
                                    y2: v
                                }, n = void 0, D && st(this._eventManager.ghostCtx, f, s, k, v, n, 0, null, !1, !1, !1, !1), (b[x].indexLabel || g.indexLabel || b[x].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stackedColumn100",
                                    dataPoint: b[x],
                                    dataSeries: g,
                                    point: {
                                        x: a,
                                        y: 0 <= b[x].y ? s : v
                                    },
                                    direction: 0 > b[x].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: f,
                                        y1: Math.min(s, v),
                                        x2: k,
                                        y2: Math.max(s, v)
                                    },
                                    color: n
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.yScaleAnimation,
                    easingFunction: tt.easing.easeOutQuart,
                    animationBase: c < t.axisY.bounds.y1 ? t.axisY.bounds.y1 : c > t.axisY.bounds.y2 ? t.axisY.bounds.y2 : c
                }
            }
        }, o.prototype.renderBar = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n, o = null,
                    l = this.plotArea,
                    r = 0,
                    h = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                    d = (r = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, this.plotArea.height / t.plotType.totalDataSeries * .9) << 0),
                    x = t.axisX.dataInfo.minDiff;
                for (isFinite(x) || (x = .3 * Math.abs(t.axisX.range)), x = this.options.dataPointWidth ? this.dataPointWidth : l.height * (t.axisX.logarithmic ? Math.log(x) / Math.log(t.axisX.range) : Math.abs(x) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && r > d && (r = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, d)), !this.dataPointMaxWidth && this.dataPointMinWidth && d < r && (d = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, r)), x < r && (x = r), x > d && (x = d), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(l.x1, l.y1, l.width, l.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.clip()), d = 0; d < t.dataSeriesIndexes.length; d++) {
                    var c = t.dataSeriesIndexes[d],
                        p = this.data[c],
                        u = p.dataPoints;
                    if (0 < u.length) {
                        var m = !!(5 < x && p.bevelEnabled);
                        for (i.strokeStyle = "#4572A7 ", r = 0; r < u.length; r++)
                            if (!((n = u[r].getTime ? u[r].x.getTime() : u[r].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && "number" == typeof u[r].y) {
                                s = t.axisX.convertValueToPixel(n), a = t.axisY.convertValueToPixel(u[r].y), s = t.axisX.reversed ? s + t.plotType.totalDataSeries * x / 2 - (t.previousDataSeriesCount + d) * x << 0 : s - t.plotType.totalDataSeries * x / 2 + (t.previousDataSeriesCount + d) * x << 0;
                                var g, b = t.axisX.reversed ? s - x << 0 : s + x << 0;
                                0 <= u[r].y ? g = h : (g = a, a = h), o = u[r].color ? u[r].color : p._colorSet[r % p._colorSet.length], st(i, g, s, a, b, o, 0, null, m, !1, !1, !1, p.fillOpacity), o = p.dataPointIds[r], this._eventManager.objectMap[o] = {
                                    id: o,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: c,
                                    dataPointIndex: r,
                                    x1: g,
                                    y1: s,
                                    x2: a,
                                    y2: b
                                }, o = void 0, D && st(this._eventManager.ghostCtx, g, s, a, b, o, 0, null, !1, !1, !1, !1), (u[r].indexLabel || p.indexLabel || u[r].indexLabelFormatter || p.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "bar",
                                    dataPoint: u[r],
                                    dataSeries: p,
                                    point: {
                                        x: 0 <= u[r].y ? a : g,
                                        y: s + (b - s) / 2
                                    },
                                    direction: 0 > u[r].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: Math.min(g, a),
                                        y1: s,
                                        x2: Math.max(g, a),
                                        y2: b
                                    },
                                    color: o
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(l.x1, l.y1, l.width, l.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xScaleAnimation,
                    easingFunction: tt.easing.easeOutQuart,
                    animationBase: h < t.axisY.bounds.x1 ? t.axisY.bounds.x1 : h > t.axisY.bounds.x2 ? t.axisY.bounds.x2 : h
                }
            }
        }, o.prototype.renderStackedBar = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n = null,
                    o = this.plotArea,
                    l = [],
                    r = [],
                    h = [],
                    d = [],
                    x = 0,
                    c = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0);
                x = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0;
                var p = t.axisX.dataInfo.minDiff;
                isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.options.dataPointWidth ? this.dataPointWidth : o.height * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && x > s && (x = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, s)), !this.dataPointMaxWidth && this.dataPointMinWidth && s < x && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, x)), p < x && (p = x), p > s && (p = s), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(o.x1, o.y1, o.width, o.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip());
                for (var u = 0; u < t.dataSeriesIndexes.length; u++) {
                    var m = t.dataSeriesIndexes[u],
                        g = this.data[m],
                        b = g.dataPoints;
                    if (0 < b.length) {
                        var y = !!(5 < p && g.bevelEnabled);
                        for (i.strokeStyle = "#4572A7 ", x = 0; x < b.length; x++)
                            if (!((n = b[x].x.getTime ? b[x].x.getTime() : b[x].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && "number" == typeof b[x].y) {
                                var v, f = (s = t.axisX.convertValueToPixel(n)) - t.plotType.plotUnits.length * p / 2 + t.index * p << 0,
                                    k = f + p << 0;
                                if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < b[x].y) h[n] = b[x].y + (h[n] ? h[n] : 0), 0 < h[n] && (v = l[n] ? l[n] : c, l[n] = a = t.axisY.convertValueToPixel(h[n]));
                                else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= b[x].y) d[n] = b[x].y + (d[n] ? d[n] : 0), a = r[n] ? r[n] : c, r[n] = v = t.axisY.convertValueToPixel(d[n]);
                                else if (a = t.axisY.convertValueToPixel(b[x].y), 0 <= b[x].y) {
                                    var M = l[n] ? l[n] : 0;
                                    v = c + M, a += M, l[n] = M + (a - v)
                                } else v = a - (M = r[n] ? r[n] : 0), a = c - M, r[n] = M + (a - v);
                                n = b[x].color ? b[x].color : g._colorSet[x % g._colorSet.length], st(i, v, f, a, k, n, 0, null, y, !1, !1, !1, g.fillOpacity), n = g.dataPointIds[x], this._eventManager.objectMap[n] = {
                                    id: n,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: m,
                                    dataPointIndex: x,
                                    x1: v,
                                    y1: f,
                                    x2: a,
                                    y2: k
                                }, n = void 0, D && st(this._eventManager.ghostCtx, v, f, a, k, n, 0, null, !1, !1, !1, !1), (b[x].indexLabel || g.indexLabel || b[x].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stackedBar",
                                    dataPoint: b[x],
                                    dataSeries: g,
                                    point: {
                                        x: 0 <= b[x].y ? a : v,
                                        y: s
                                    },
                                    direction: 0 > b[x].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: Math.min(v, a),
                                        y1: f,
                                        x2: Math.max(v, a),
                                        y2: k
                                    },
                                    color: n
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xScaleAnimation,
                    easingFunction: tt.easing.easeOutQuart,
                    animationBase: c < t.axisY.bounds.x1 ? t.axisY.bounds.x1 : c > t.axisY.bounds.x2 ? t.axisY.bounds.x2 : c
                }
            }
        }, o.prototype.renderStackedBar100 = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n = null,
                    o = this.plotArea,
                    l = [],
                    r = [],
                    h = [],
                    d = [],
                    x = 0,
                    c = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0);
                x = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .15 * this.height << 0;
                var p = t.axisX.dataInfo.minDiff;
                isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.options.dataPointWidth ? this.dataPointWidth : o.height * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.plotUnits.length * .9 << 0, this.dataPointMaxWidth && x > s && (x = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, s)), !this.dataPointMaxWidth && this.dataPointMinWidth && s < x && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, x)), p < x && (p = x), p > s && (p = s), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(o.x1, o.y1, o.width, o.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.clip());
                for (var u = 0; u < t.dataSeriesIndexes.length; u++) {
                    var m = t.dataSeriesIndexes[u],
                        g = this.data[m],
                        b = g.dataPoints;
                    if (0 < b.length) {
                        var y = !!(5 < p && g.bevelEnabled);
                        for (i.strokeStyle = "#4572A7 ", x = 0; x < b.length; x++)
                            if (!((n = b[x].x.getTime ? b[x].x.getTime() : b[x].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && "number" == typeof b[x].y) {
                                var v;
                                s = t.axisX.convertValueToPixel(n), v = 0 !== t.dataPointYSums[n] ? b[x].y / t.dataPointYSums[n] * 100 : 0;
                                var f = s - t.plotType.plotUnits.length * p / 2 + t.index * p << 0,
                                    k = f + p << 0;
                                if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 < b[x].y) {
                                    if (h[n] = v + (h[n] ? h[n] : 0), 0 >= h[n]) continue;
                                    v = l[n] ? l[n] : c, l[n] = a = t.axisY.convertValueToPixel(h[n])
                                } else if (t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length && 0 >= b[x].y) d[n] = v + (d[n] ? d[n] : 0), a = r[n] ? r[n] : c, r[n] = v = t.axisY.convertValueToPixel(d[n]);
                                else if (a = t.axisY.convertValueToPixel(v), 0 <= b[x].y) {
                                    var M = l[n] ? l[n] : 0;
                                    v = c + M, a += M, t.dataSeriesIndexes.length - 1 === u && 1 >= Math.abs(o.x2 - a) && (a = o.x2), l[n] = M + (a - v)
                                } else v = a - (M = r[n] ? r[n] : 0), a = c - M, t.dataSeriesIndexes.length - 1 === u && 1 >= Math.abs(o.x1 - v) && (v = o.x1), r[n] = M + (a - v);
                                n = b[x].color ? b[x].color : g._colorSet[x % g._colorSet.length], st(i, v, f, a, k, n, 0, null, y, !1, !1, !1, g.fillOpacity), n = g.dataPointIds[x], this._eventManager.objectMap[n] = {
                                    id: n,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: m,
                                    dataPointIndex: x,
                                    x1: v,
                                    y1: f,
                                    x2: a,
                                    y2: k
                                }, n = void 0, D && st(this._eventManager.ghostCtx, v, f, a, k, n, 0, null, !1, !1, !1, !1), (b[x].indexLabel || g.indexLabel || b[x].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stackedBar100",
                                    dataPoint: b[x],
                                    dataSeries: g,
                                    point: {
                                        x: 0 <= b[x].y ? a : v,
                                        y: s
                                    },
                                    direction: 0 > b[x].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: Math.min(v, a),
                                        y1: f,
                                        x2: Math.max(v, a),
                                        y2: k
                                    },
                                    color: n
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xScaleAnimation,
                    easingFunction: tt.easing.easeOutQuart,
                    animationBase: c < t.axisY.bounds.x1 ? t.axisY.bounds.x1 : c > t.axisY.bounds.x2 ? t.axisY.bounds.x2 : c
                }
            }
        }, o.prototype.renderArea = function(t) {
            var e, i;

            function a() {
                T && (0 < m.lineThickness && n.stroke(), t.axisY.logarithmic || 0 >= t.axisY.viewportMinimum && 0 <= t.axisY.viewportMaximum ? f = M : 0 > t.axisY.viewportMaximum ? f = h.y1 : 0 < t.axisY.viewportMinimum && (f = r.y2), n.lineTo(b, f), n.lineTo(T.x, f), n.closePath(), n.globalAlpha = m.fillOpacity, n.fill(), n.globalAlpha = 1, D && (l.lineTo(b, f), l.lineTo(T.x, f), l.closePath(), l.fill()), n.beginPath(), n.moveTo(b, y), l.beginPath(), l.moveTo(b, y), T = {
                    x: b,
                    y: y
                })
            }
            var s = t.targetCanvasCtx || this.plotArea.ctx,
                n = D ? this._preRenderCtx : s;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var o, l = this._eventManager.ghostCtx,
                    r = t.axisX.lineCoordinates,
                    h = t.axisY.lineCoordinates,
                    x = [],
                    c = this.plotArea;
                n.save(), D && l.save(), n.beginPath(), n.rect(c.x1, c.y1, c.width, c.height), n.clip(), D && (l.beginPath(), l.rect(c.x1, c.y1, c.width, c.height), l.clip());
                for (var p = 0; p < t.dataSeriesIndexes.length; p++) {
                    var u = t.dataSeriesIndexes[p],
                        m = this.data[u],
                        g = m.dataPoints;
                    x = m.id;
                    this._eventManager.objectMap[x] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: u
                    }, x = void 0, l.fillStyle = x, x = [], e = !0;
                    var b, y, v, f, k = 0,
                        M = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                        T = null;
                    if (0 < g.length) {
                        var P = m._colorSet[k % m._colorSet.length],
                            w = m.lineColor = m.options.lineColor || P,
                            C = w;
                        if (n.fillStyle = P, n.strokeStyle = w, n.lineWidth = m.lineThickness, i = "solid", n.setLineDash) {
                            var S = d(m.nullDataLineDashType, m.lineThickness),
                                _ = d(i = m.lineDashType, m.lineThickness);
                            n.setLineDash(_)
                        }
                        for (var B = !0; k < g.length; k++)
                            if (!((v = g[k].x.getTime ? g[k].x.getTime() : g[k].x) < t.axisX.dataInfo.viewPortMin || v > t.axisX.dataInfo.viewPortMax && (!m.connectNullData || !B)))
                                if ("number" != typeof g[k].y) m.connectNullData || B || e || a(), B = !0;
                                else {
                                    b = t.axisX.convertValueToPixel(v), y = t.axisY.convertValueToPixel(g[k].y), e || B ? (!e && m.connectNullData ? (n.setLineDash && (m.options.nullDataLineDashType || i === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (e = b, i = y, b = o.x, y = o.y, a(), n.moveTo(o.x, o.y), b = e, y = i, T = o, i = m.nullDataLineDashType, n.setLineDash(S)), n.lineTo(b, y), D && l.lineTo(b, y)) : (n.beginPath(), n.moveTo(b, y), D && (l.beginPath(), l.moveTo(b, y)), T = {
                                        x: b,
                                        y: y
                                    }), B = e = !1) : (n.lineTo(b, y), D && l.lineTo(b, y), 0 == k % 250 && a()), o = {
                                        x: b,
                                        y: y
                                    }, k < g.length - 1 && (C !== (g[k].lineColor || w) || i !== (g[k].lineDashType || m.lineDashType)) && (a(), C = g[k].lineColor || w, n.strokeStyle = C, n.setLineDash && (g[k].lineDashType ? (i = g[k].lineDashType, n.setLineDash(d(i, m.lineThickness))) : (i = m.lineDashType, n.setLineDash(_))));
                                    var F = m.dataPointIds[k];
                                    this._eventManager.objectMap[F] = {
                                        id: F,
                                        objectType: "dataPoint",
                                        dataSeriesIndex: u,
                                        dataPointIndex: k,
                                        x1: b,
                                        y1: y
                                    }, 0 !== g[k].markerSize && (0 < g[k].markerSize || 0 < m.markerSize) && (v = m.getMarkerProperties(k, b, y, n), x.push(v), F = void 0, D && x.push({
                                        x: b,
                                        y: y,
                                        ctx: l,
                                        type: v.type,
                                        size: v.size,
                                        color: F,
                                        borderColor: F,
                                        borderThickness: v.borderThickness
                                    })), (g[k].indexLabel || m.indexLabel || g[k].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "area",
                                        dataPoint: g[k],
                                        dataSeries: m,
                                        point: {
                                            x: b,
                                            y: y
                                        },
                                        direction: 0 > g[k].y === t.axisY.reversed ? 1 : -1,
                                        color: P
                                    })
                                }
                        a(), et.drawMarkers(x)
                    }
                }
                return D && (s.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), n.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && n.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && n.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), n.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore()), n.restore(), {
                    source: s,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderSplineArea = function(t) {
            function e() {
                var e = _(f, 2);
                if (0 < e.length) {
                    if (0 < c.lineThickness) {
                        a.beginPath(), a.moveTo(e[0].x, e[0].y), e[0].newStrokeStyle && (a.strokeStyle = e[0].newStrokeStyle), e[0].newLineDashArray && a.setLineDash(e[0].newLineDashArray);
                        for (var i = 0; i < e.length - 3; i += 3) a.bezierCurveTo(e[i + 1].x, e[i + 1].y, e[i + 2].x, e[i + 2].y, e[i + 3].x, e[i + 3].y), D && s.bezierCurveTo(e[i + 1].x, e[i + 1].y, e[i + 2].x, e[i + 2].y, e[i + 3].x, e[i + 3].y), (e[i + 3].newStrokeStyle || e[i + 3].newLineDashArray) && (a.stroke(), a.beginPath(), a.moveTo(e[i + 3].x, e[i + 3].y), e[i + 3].newStrokeStyle && (a.strokeStyle = e[i + 3].newStrokeStyle), e[i + 3].newLineDashArray && a.setLineDash(e[i + 3].newLineDashArray));
                        a.stroke()
                    }
                    for (a.beginPath(), a.moveTo(e[0].x, e[0].y), D && (s.beginPath(), s.moveTo(e[0].x, e[0].y)), i = 0; i < e.length - 3; i += 3) a.bezierCurveTo(e[i + 1].x, e[i + 1].y, e[i + 2].x, e[i + 2].y, e[i + 3].x, e[i + 3].y), D && s.bezierCurveTo(e[i + 1].x, e[i + 1].y, e[i + 2].x, e[i + 2].y, e[i + 3].x, e[i + 3].y);
                    t.axisY.logarithmic || 0 >= t.axisY.viewportMinimum && 0 <= t.axisY.viewportMaximum ? g = y : 0 > t.axisY.viewportMaximum ? g = o.y1 : 0 < t.axisY.viewportMinimum && (g = n.y2), v = {
                        x: e[0].x,
                        y: e[0].y
                    }, a.lineTo(e[e.length - 1].x, g), a.lineTo(v.x, g), a.closePath(), a.globalAlpha = c.fillOpacity, a.fill(), a.globalAlpha = 1, D && (s.lineTo(e[e.length - 1].x, g), s.lineTo(v.x, g), s.closePath(), s.fill())
                }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
                a = D ? this._preRenderCtx : i;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s = this._eventManager.ghostCtx,
                    n = t.axisX.lineCoordinates,
                    o = t.axisY.lineCoordinates,
                    l = [],
                    r = this.plotArea;
                a.save(), D && s.save(), a.beginPath(), a.rect(r.x1, r.y1, r.width, r.height), a.clip(), D && (s.beginPath(), s.rect(r.x1, r.y1, r.width, r.height), s.clip());
                for (var h = 0; h < t.dataSeriesIndexes.length; h++) {
                    var x = t.dataSeriesIndexes[h],
                        c = this.data[x],
                        p = c.dataPoints;
                    l = c.id;
                    this._eventManager.objectMap[l] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: x
                    }, l = void 0, s.fillStyle = l;
                    l = [];
                    var u, m, g, b = 0,
                        y = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                        v = null,
                        f = [];
                    if (0 < p.length) {
                        var k = c._colorSet[b % c._colorSet.length],
                            M = c.lineColor = c.options.lineColor || k,
                            T = M;
                        a.fillStyle = k, a.strokeStyle = M, a.lineWidth = c.lineThickness;
                        var P = "solid";
                        if (a.setLineDash) {
                            var w = d(c.nullDataLineDashType, c.lineThickness),
                                C = d(P = c.lineDashType, c.lineThickness);
                            a.setLineDash(C)
                        }
                        for (m = !1; b < p.length; b++)
                            if (!((u = p[b].x.getTime ? p[b].x.getTime() : p[b].x) < t.axisX.dataInfo.viewPortMin || u > t.axisX.dataInfo.viewPortMax && (!c.connectNullData || !m)))
                                if ("number" != typeof p[b].y) 0 < b && !m && (c.connectNullData ? a.setLineDash && 0 < f.length && (c.options.nullDataLineDashType || !p[b - 1].lineDashType) && (f[f.length - 1].newLineDashArray = w, P = c.nullDataLineDashType) : (e(), f = [])), m = !0;
                                else {
                                    u = t.axisX.convertValueToPixel(u), m = t.axisY.convertValueToPixel(p[b].y);
                                    var S = c.dataPointIds[b];
                                    if (this._eventManager.objectMap[S] = {
                                            id: S,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: x,
                                            dataPointIndex: b,
                                            x1: u,
                                            y1: m
                                        }, f[f.length] = {
                                            x: u,
                                            y: m
                                        }, b < p.length - 1 && (T !== (p[b].lineColor || M) || P !== (p[b].lineDashType || c.lineDashType)) && (T = p[b].lineColor || M, f[f.length - 1].newStrokeStyle = T, a.setLineDash && (p[b].lineDashType ? (P = p[b].lineDashType, f[f.length - 1].newLineDashArray = d(P, c.lineThickness)) : (P = c.lineDashType, f[f.length - 1].newLineDashArray = C))), 0 !== p[b].markerSize && (0 < p[b].markerSize || 0 < c.markerSize)) {
                                        var B = c.getMarkerProperties(b, u, m, a);
                                        l.push(B), S = void 0, D && l.push({
                                            x: u,
                                            y: m,
                                            ctx: s,
                                            type: B.type,
                                            size: B.size,
                                            color: S,
                                            borderColor: S,
                                            borderThickness: B.borderThickness
                                        })
                                    }(p[b].indexLabel || c.indexLabel || p[b].indexLabelFormatter || c.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "splineArea",
                                        dataPoint: p[b],
                                        dataSeries: c,
                                        point: {
                                            x: u,
                                            y: m
                                        },
                                        direction: 0 > p[b].y === t.axisY.reversed ? 1 : -1,
                                        color: k
                                    }), m = !1
                                }
                        e(), et.drawMarkers(l)
                    }
                }
                return D && (i.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore()), a.restore(), {
                    source: i,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderStepArea = function(t) {
            var e, i;

            function a() {
                T && (0 < m.lineThickness && n.stroke(), t.axisY.logarithmic || 0 >= t.axisY.viewportMinimum && 0 <= t.axisY.viewportMaximum ? f = M : 0 > t.axisY.viewportMaximum ? f = h.y1 : 0 < t.axisY.viewportMinimum && (f = r.y2), n.lineTo(b, f), n.lineTo(T.x, f), n.closePath(), n.globalAlpha = m.fillOpacity, n.fill(), n.globalAlpha = 1, D && (l.lineTo(b, f), l.lineTo(T.x, f), l.closePath(), l.fill()), n.beginPath(), n.moveTo(b, y), l.beginPath(), l.moveTo(b, y), T = {
                    x: b,
                    y: y
                })
            }
            var s = t.targetCanvasCtx || this.plotArea.ctx,
                n = D ? this._preRenderCtx : s;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var o, l = this._eventManager.ghostCtx,
                    r = t.axisX.lineCoordinates,
                    h = t.axisY.lineCoordinates,
                    x = [],
                    c = this.plotArea;
                n.save(), D && l.save(), n.beginPath(), n.rect(c.x1, c.y1, c.width, c.height), n.clip(), D && (l.beginPath(), l.rect(c.x1, c.y1, c.width, c.height), l.clip());
                for (var p = 0; p < t.dataSeriesIndexes.length; p++) {
                    var u = t.dataSeriesIndexes[p],
                        m = this.data[u],
                        g = m.dataPoints;
                    x = m.id;
                    this._eventManager.objectMap[x] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: u
                    }, x = void 0, l.fillStyle = x, x = [], e = !0;
                    var b, y, v, f, k = 0,
                        M = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                        T = null;
                    if (i = !1, 0 < g.length) {
                        var P = m._colorSet[k % m._colorSet.length],
                            w = m.lineColor = m.options.lineColor || P,
                            C = w;
                        n.fillStyle = P, n.strokeStyle = w, n.lineWidth = m.lineThickness;
                        var S = "solid";
                        if (n.setLineDash) {
                            var _ = d(m.nullDataLineDashType, m.lineThickness),
                                B = d(S = m.lineDashType, m.lineThickness);
                            n.setLineDash(B)
                        }
                        for (; k < g.length; k++)
                            if (!((v = g[k].x.getTime ? g[k].x.getTime() : g[k].x) < t.axisX.dataInfo.viewPortMin || v > t.axisX.dataInfo.viewPortMax && (!m.connectNullData || !i))) {
                                var F = y;
                                "number" != typeof g[k].y ? (m.connectNullData || i || e || a(), i = !0) : (b = t.axisX.convertValueToPixel(v), y = t.axisY.convertValueToPixel(g[k].y), e || i ? (!e && m.connectNullData ? (n.setLineDash && (m.options.nullDataLineDashType || S === m.lineDashType && m.lineDashType !== m.nullDataLineDashType) && (e = b, i = y, b = o.x, y = o.y, a(), n.moveTo(o.x, o.y), b = e, y = i, T = o, S = m.nullDataLineDashType, n.setLineDash(_)), n.lineTo(b, F), n.lineTo(b, y), D && (l.lineTo(b, F), l.lineTo(b, y))) : (n.beginPath(), n.moveTo(b, y), D && (l.beginPath(), l.moveTo(b, y)), T = {
                                    x: b,
                                    y: y
                                }), i = e = !1) : (n.lineTo(b, F), D && l.lineTo(b, F), n.lineTo(b, y), D && l.lineTo(b, y), 0 == k % 250 && a()), o = {
                                    x: b,
                                    y: y
                                }, k < g.length - 1 && (C !== (g[k].lineColor || w) || S !== (g[k].lineDashType || m.lineDashType)) && (a(), C = g[k].lineColor || w, n.strokeStyle = C, n.setLineDash && (g[k].lineDashType ? (S = g[k].lineDashType, n.setLineDash(d(S, m.lineThickness))) : (S = m.lineDashType, n.setLineDash(B)))), v = m.dataPointIds[k], this._eventManager.objectMap[v] = {
                                    id: v,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: u,
                                    dataPointIndex: k,
                                    x1: b,
                                    y1: y
                                }, 0 !== g[k].markerSize && (0 < g[k].markerSize || 0 < m.markerSize) && (F = m.getMarkerProperties(k, b, y, n), x.push(F), v = void 0, D && x.push({
                                    x: b,
                                    y: y,
                                    ctx: l,
                                    type: F.type,
                                    size: F.size,
                                    color: v,
                                    borderColor: v,
                                    borderThickness: F.borderThickness
                                })), (g[k].indexLabel || m.indexLabel || g[k].indexLabelFormatter || m.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "stepArea",
                                    dataPoint: g[k],
                                    dataSeries: m,
                                    point: {
                                        x: b,
                                        y: y
                                    },
                                    direction: 0 > g[k].y === t.axisY.reversed ? 1 : -1,
                                    color: P
                                }))
                            }
                        a(), et.drawMarkers(x)
                    }
                }
                return D && (s.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), n.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && n.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && n.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), n.clearRect(c.x1, c.y1, c.width, c.height), this._eventManager.ghostCtx.restore()), n.restore(), {
                    source: s,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderStackedArea = function(t) {
            function e() {
                if (!(1 > g.length)) {
                    for (0 < P.lineThickness && a.stroke(); 0 < g.length;) {
                        var t = g.pop();
                        a.lineTo(t.x, t.y), D && k.lineTo(t.x, t.y)
                    }
                    a.closePath(), a.globalAlpha = P.fillOpacity, a.fill(), a.globalAlpha = 1, a.beginPath(), D && (k.closePath(), k.fill(), k.beginPath()), g = []
                }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
                a = D ? this._preRenderCtx : i;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s, o, l, r, h, x = null,
                    c = null,
                    p = [],
                    u = this.plotArea,
                    m = [],
                    g = [],
                    b = [],
                    y = [],
                    v = 0,
                    f = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                    k = this._eventManager.ghostCtx;
                D && k.beginPath(), a.save(), D && k.save(), a.beginPath(), a.rect(u.x1, u.y1, u.width, u.height), a.clip(), D && (k.beginPath(), k.rect(u.x1, u.y1, u.width, u.height), k.clip());
                x = [];
                for (var M = 0; M < t.dataSeriesIndexes.length; M++) {
                    var T = t.dataSeriesIndexes[M],
                        P = this.data[T],
                        w = P.dataPoints;
                    for (P.dataPointIndexes = [], v = 0; v < w.length; v++) T = w[v].x.getTime ? w[v].x.getTime() : w[v].x, P.dataPointIndexes[T] = v, x[T] || (b.push(T), x[T] = !0);
                    b.sort(n)
                }
                for (M = 0; M < t.dataSeriesIndexes.length; M++) {
                    if (T = t.dataSeriesIndexes[M], w = (P = this.data[T]).dataPoints, r = !0, g = [], v = P.id, this._eventManager.objectMap[v] = {
                            objectType: "dataSeries",
                            dataSeriesIndex: T
                        }, v = void 0, k.fillStyle = v, 0 < b.length) {
                        x = P._colorSet[0];
                        var C = P.lineColor = P.options.lineColor || x,
                            S = C;
                        if (a.fillStyle = x, a.strokeStyle = C, a.lineWidth = P.lineThickness, h = "solid", a.setLineDash) {
                            var _ = d(P.nullDataLineDashType, P.lineThickness),
                                B = d(h = P.lineDashType, P.lineThickness);
                            a.setLineDash(B)
                        }
                        var F = !0;
                        for (v = 0; v < b.length; v++) {
                            c = b[v];
                            var A = 0 <= P.dataPointIndexes[c] ? w[P.dataPointIndexes[c]] : {
                                x: c,
                                y: null
                            };
                            if (!(c < t.axisX.dataInfo.viewPortMin || c > t.axisX.dataInfo.viewPortMax && (!P.connectNullData || !F)))
                                if ("number" != typeof A.y) P.connectNullData || F || r || e(), F = !0;
                                else {
                                    s = t.axisX.convertValueToPixel(c);
                                    var L = m[c] ? m[c] : 0;
                                    if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length) {
                                        if (y[c] = A.y + (y[c] ? y[c] : 0), 0 >= y[c] && t.axisY.logarithmic) continue;
                                        o = t.axisY.convertValueToPixel(y[c])
                                    } else o = t.axisY.convertValueToPixel(A.y), o -= L;
                                    if (g.push({
                                            x: s,
                                            y: f - L
                                        }), m[c] = f - o, r || F ? (!r && P.connectNullData ? (a.setLineDash && (P.options.nullDataLineDashType || h === P.lineDashType && P.lineDashType !== P.nullDataLineDashType) && (r = g.pop(), h = g[g.length - 1], e(), a.moveTo(l.x, l.y), g.push(h), g.push(r), h = P.nullDataLineDashType, a.setLineDash(_)), a.lineTo(s, o), D && k.lineTo(s, o)) : (a.beginPath(), a.moveTo(s, o), D && (k.beginPath(), k.moveTo(s, o))), F = r = !1) : (a.lineTo(s, o), D && k.lineTo(s, o), 0 == v % 250 && (e(), a.moveTo(s, o), D && k.moveTo(s, o), g.push({
                                            x: s,
                                            y: f - L
                                        }))), l = {
                                            x: s,
                                            y: o
                                        }, v < w.length - 1 && (S !== (w[v].lineColor || C) || h !== (w[v].lineDashType || P.lineDashType)) && (e(), a.beginPath(), a.moveTo(s, o), g.push({
                                            x: s,
                                            y: f - L
                                        }), S = w[v].lineColor || C, a.strokeStyle = S, a.setLineDash && (w[v].lineDashType ? (h = w[v].lineDashType, a.setLineDash(d(h, P.lineThickness))) : (h = P.lineDashType, a.setLineDash(B)))), 0 <= P.dataPointIndexes[c]) {
                                        var I = P.dataPointIds[P.dataPointIndexes[c]];
                                        this._eventManager.objectMap[I] = {
                                            id: I,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: T,
                                            dataPointIndex: P.dataPointIndexes[c],
                                            x1: s,
                                            y1: o
                                        }
                                    }
                                    0 <= P.dataPointIndexes[c] && 0 !== A.markerSize && (0 < A.markerSize || 0 < P.markerSize) && (L = P.getMarkerProperties(P.dataPointIndexes[c], s, o, a), p.push(L), c = void 0, D && p.push({
                                        x: s,
                                        y: o,
                                        ctx: k,
                                        type: L.type,
                                        size: L.size,
                                        color: c,
                                        borderColor: c,
                                        borderThickness: L.borderThickness
                                    })), (A.indexLabel || P.indexLabel || A.indexLabelFormatter || P.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "stackedArea",
                                        dataPoint: A,
                                        dataSeries: P,
                                        point: {
                                            x: s,
                                            y: o
                                        },
                                        direction: 0 > w[v].y === t.axisY.reversed ? 1 : -1,
                                        color: x
                                    })
                                }
                        }
                        e(), a.moveTo(s, o), D && k.moveTo(s, o)
                    }
                    delete P.dataPointIndexes
                }
                return et.drawMarkers(p), D && (i.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(u.x1, u.y1, u.width, u.height), k.restore()), a.restore(), {
                    source: i,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderStackedArea100 = function(t) {
            function e() {
                for (0 < P.lineThickness && a.stroke(); 0 < g.length;) {
                    var t = g.pop();
                    a.lineTo(t.x, t.y), D && k.lineTo(t.x, t.y)
                }
                a.closePath(), a.globalAlpha = P.fillOpacity, a.fill(), a.globalAlpha = 1, a.beginPath(), D && (k.closePath(), k.fill(), k.beginPath()), g = []
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
                a = D ? this._preRenderCtx : i;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s, o, l, r, h, x = null,
                    c = null,
                    p = this.plotArea,
                    u = [],
                    m = [],
                    g = [],
                    b = [],
                    y = [],
                    v = 0,
                    f = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0),
                    k = this._eventManager.ghostCtx;
                a.save(), D && k.save(), a.beginPath(), a.rect(p.x1, p.y1, p.width, p.height), a.clip(), D && (k.beginPath(), k.rect(p.x1, p.y1, p.width, p.height), k.clip());
                x = [];
                for (var M = 0; M < t.dataSeriesIndexes.length; M++) {
                    var T = t.dataSeriesIndexes[M],
                        P = this.data[T],
                        w = P.dataPoints;
                    for (P.dataPointIndexes = [], v = 0; v < w.length; v++) T = w[v].x.getTime ? w[v].x.getTime() : w[v].x, P.dataPointIndexes[T] = v, x[T] || (b.push(T), x[T] = !0);
                    b.sort(n)
                }
                for (M = 0; M < t.dataSeriesIndexes.length; M++) {
                    if (T = t.dataSeriesIndexes[M], w = (P = this.data[T]).dataPoints, r = !0, x = P.id, this._eventManager.objectMap[x] = {
                            objectType: "dataSeries",
                            dataSeriesIndex: T
                        }, x = void 0, k.fillStyle = x, g = [], 0 < b.length) {
                        x = P._colorSet[v % P._colorSet.length];
                        var C = P.lineColor = P.options.lineColor || x,
                            S = C;
                        if (a.fillStyle = x, a.strokeStyle = C, a.lineWidth = P.lineThickness, h = "solid", a.setLineDash) {
                            var _ = d(P.nullDataLineDashType, P.lineThickness),
                                B = d(h = P.lineDashType, P.lineThickness);
                            a.setLineDash(B)
                        }
                        var F = !0;
                        for (v = 0; v < b.length; v++) {
                            c = b[v];
                            var A = 0 <= P.dataPointIndexes[c] ? w[P.dataPointIndexes[c]] : {
                                x: c,
                                y: null
                            };
                            if (!(c < t.axisX.dataInfo.viewPortMin || c > t.axisX.dataInfo.viewPortMax && (!P.connectNullData || !F)))
                                if ("number" != typeof A.y) P.connectNullData || F || r || e(), F = !0;
                                else {
                                    var L;
                                    L = 0 !== t.dataPointYSums[c] ? A.y / t.dataPointYSums[c] * 100 : 0, s = t.axisX.convertValueToPixel(c);
                                    var I = m[c] ? m[c] : 0;
                                    if (t.axisY.logarithmic || t.axisY.scaleBreaks && 0 < t.axisY.scaleBreaks._appliedBreaks.length) {
                                        if (y[c] = L + (y[c] ? y[c] : 0), 0 >= y[c] && t.axisY.logarithmic) continue;
                                        o = t.axisY.convertValueToPixel(y[c])
                                    } else o = t.axisY.convertValueToPixel(L), o -= I;
                                    if (g.push({
                                            x: s,
                                            y: f - I
                                        }), m[c] = f - o, r || F ? (!r && P.connectNullData ? (a.setLineDash && (P.options.nullDataLineDashType || h === P.lineDashType && P.lineDashType !== P.nullDataLineDashType) && (r = g.pop(), h = g[g.length - 1], e(), a.moveTo(l.x, l.y), g.push(h), g.push(r), h = P.nullDataLineDashType, a.setLineDash(_)), a.lineTo(s, o), D && k.lineTo(s, o)) : (a.beginPath(), a.moveTo(s, o), D && (k.beginPath(), k.moveTo(s, o))), F = r = !1) : (a.lineTo(s, o), D && k.lineTo(s, o), 0 == v % 250 && (e(), a.moveTo(s, o), D && k.moveTo(s, o), g.push({
                                            x: s,
                                            y: f - I
                                        }))), l = {
                                            x: s,
                                            y: o
                                        }, v < w.length - 1 && (S !== (w[v].lineColor || C) || h !== (w[v].lineDashType || P.lineDashType)) && (e(), a.beginPath(), a.moveTo(s, o), g.push({
                                            x: s,
                                            y: f - I
                                        }), S = w[v].lineColor || C, a.strokeStyle = S, a.setLineDash && (w[v].lineDashType ? (h = w[v].lineDashType, a.setLineDash(d(h, P.lineThickness))) : (h = P.lineDashType, a.setLineDash(B)))), 0 <= P.dataPointIndexes[c]) {
                                        var V = P.dataPointIds[P.dataPointIndexes[c]];
                                        this._eventManager.objectMap[V] = {
                                            id: V,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: T,
                                            dataPointIndex: P.dataPointIndexes[c],
                                            x1: s,
                                            y1: o
                                        }
                                    }
                                    0 <= P.dataPointIndexes[c] && 0 !== A.markerSize && (0 < A.markerSize || 0 < P.markerSize) && (I = P.getMarkerProperties(v, s, o, a), u.push(I), c = void 0, D && u.push({
                                        x: s,
                                        y: o,
                                        ctx: k,
                                        type: I.type,
                                        size: I.size,
                                        color: c,
                                        borderColor: c,
                                        borderThickness: I.borderThickness
                                    })), (A.indexLabel || P.indexLabel || A.indexLabelFormatter || P.indexLabelFormatter) && this._indexLabels.push({
                                        chartType: "stackedArea100",
                                        dataPoint: A,
                                        dataSeries: P,
                                        point: {
                                            x: s,
                                            y: o
                                        },
                                        direction: 0 > w[v].y === t.axisY.reversed ? 1 : -1,
                                        color: x
                                    })
                                }
                        }
                        e(), a.moveTo(s, o), D && k.moveTo(s, o)
                    }
                    delete P.dataPointIndexes
                }
                return et.drawMarkers(u), D && (i.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(p.x1, p.y1, p.width, p.height), k.restore()), a.restore(), {
                    source: i,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderBubble = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n = this.plotArea,
                    o = 0;
                i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(n.x1, n.y1, n.width, n.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(n.x1, n.y1, n.width, n.height), this._eventManager.ghostCtx.clip());
                for (var l = -1 / 0, r = 1 / 0, h = 0; h < t.dataSeriesIndexes.length; h++) {
                    var d = t.dataSeriesIndexes[h],
                        x = this.data[d],
                        c = x.dataPoints,
                        p = 0;
                    for (o = 0; o < c.length; o++)(a = a = c[o].getTime ? c[o].x.getTime() : c[o].x) < t.axisX.dataInfo.viewPortMin || a > t.axisX.dataInfo.viewPortMax || void 0 === c[o].z || ((p = c[o].z) > l && (l = p), p < r && (r = p))
                }
                var u = 25 * Math.PI,
                    m = Math.max(Math.pow(.25 * Math.min(n.height, n.width) / 2, 2) * Math.PI, u);
                for (h = 0; h < t.dataSeriesIndexes.length; h++)
                    if (d = t.dataSeriesIndexes[h], 0 < (c = (x = this.data[d]).dataPoints).length)
                        for (i.strokeStyle = "#4572A7 ", o = 0; o < c.length; o++)
                            if (!((a = a = c[o].getTime ? c[o].x.getTime() : c[o].x) < t.axisX.dataInfo.viewPortMin || a > t.axisX.dataInfo.viewPortMax) && "number" == typeof c[o].y) {
                                a = t.axisX.convertValueToPixel(a), s = t.axisY.convertValueToPixel(c[o].y);
                                p = c[o].z;
                                var g = 2 * Math.max(Math.sqrt((l === r ? m / 2 : u + (m - u) / (l - r) * (p - r)) / Math.PI) << 0, 1);
                                (p = x.getMarkerProperties(o, i)).size = g, i.globalAlpha = x.fillOpacity, et.drawMarker(a, s, i, p.type, p.size, p.color, p.borderColor, p.borderThickness), i.globalAlpha = 1;
                                var b = x.dataPointIds[o];
                                this._eventManager.objectMap[b] = {
                                    id: b,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: d,
                                    dataPointIndex: o,
                                    x1: a,
                                    y1: s,
                                    size: g
                                }, g = void 0, D && et.drawMarker(a, s, this._eventManager.ghostCtx, p.type, p.size, g, g, p.borderThickness), (c[o].indexLabel || x.indexLabel || c[o].indexLabelFormatter || x.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "bubble",
                                    dataPoint: c[o],
                                    dataSeries: x,
                                    point: {
                                        x: a,
                                        y: s
                                    },
                                    direction: 1,
                                    bounds: {
                                        x1: a - p.size / 2,
                                        y1: s - p.size / 2,
                                        x2: a + p.size / 2,
                                        y2: s + p.size / 2
                                    },
                                    color: null
                                })
                            }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(n.x1, n.y1, n.width, n.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderScatter = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n = this.plotArea,
                    o = 0;
                i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(n.x1, n.y1, n.width, n.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(n.x1, n.y1, n.width, n.height), this._eventManager.ghostCtx.clip());
                for (var l = 0; l < t.dataSeriesIndexes.length; l++) {
                    var r = t.dataSeriesIndexes[l],
                        h = this.data[r],
                        d = h.dataPoints;
                    if (0 < d.length) {
                        i.strokeStyle = "#4572A7 ", Math.pow(.3 * Math.min(n.height, n.width) / 2, 2);
                        var x = 0,
                            c = 0;
                        for (o = 0; o < d.length; o++)
                            if (!((a = a = d[o].getTime ? d[o].x.getTime() : d[o].x) < t.axisX.dataInfo.viewPortMin || a > t.axisX.dataInfo.viewPortMax) && "number" == typeof d[o].y) {
                                a = t.axisX.convertValueToPixel(a), s = t.axisY.convertValueToPixel(d[o].y);
                                var p = h.getMarkerProperties(o, a, s, i);
                                i.globalAlpha = h.fillOpacity, et.drawMarker(p.x, p.y, p.ctx, p.type, p.size, p.color, p.borderColor, p.borderThickness), i.globalAlpha = 1, Math.sqrt((x - a) * (x - a) + (c - s) * (c - s)) < Math.min(p.size, 5) && d.length > Math.min(this.plotArea.width, this.plotArea.height) || (x = h.dataPointIds[o], this._eventManager.objectMap[x] = {
                                    id: x,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: r,
                                    dataPointIndex: o,
                                    x1: a,
                                    y1: s
                                }, x = void 0, D && et.drawMarker(p.x, p.y, this._eventManager.ghostCtx, p.type, p.size, x, x, p.borderThickness), (d[o].indexLabel || h.indexLabel || d[o].indexLabelFormatter || h.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "scatter",
                                    dataPoint: d[o],
                                    dataSeries: h,
                                    point: {
                                        x: a,
                                        y: s
                                    },
                                    direction: 1,
                                    bounds: {
                                        x1: a - p.size / 2,
                                        y1: s - p.size / 2,
                                        x2: a + p.size / 2,
                                        y2: s + p.size / 2
                                    },
                                    color: null
                                }), x = a, c = s)
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(n.x1, n.y1, n.width, n.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderCandlestick = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e,
                a = this._eventManager.ghostCtx;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s, n, o, r, h, d, x = null,
                    c = null,
                    p = this.plotArea,
                    u = 0,
                    m = (x = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, c = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .015 * this.width, t.axisX.dataInfo.minDiff);
                isFinite(m) || (m = .3 * Math.abs(t.axisX.range)), m = this.options.dataPointWidth ? this.dataPointWidth : .7 * p.width * (t.axisX.logarithmic ? Math.log(m) / Math.log(t.axisX.range) : Math.abs(m) / Math.abs(t.axisX.range)) << 0, this.dataPointMaxWidth && x > c && (x = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, c)), !this.dataPointMaxWidth && this.dataPointMinWidth && c < x && (c = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, x)), m < x && (m = x), m > c && (m = c), i.save(), D && a.save(), i.beginPath(), i.rect(p.x1, p.y1, p.width, p.height), i.clip(), D && (a.beginPath(), a.rect(p.x1, p.y1, p.width, p.height), a.clip());
                for (var g = 0; g < t.dataSeriesIndexes.length; g++) {
                    var b = t.dataSeriesIndexes[g],
                        y = this.data[b],
                        v = y.dataPoints;
                    if (0 < v.length) {
                        var f = !!(5 < m && y.bevelEnabled);
                        for (u = 0; u < v.length; u++)
                            if (!((d = v[u].getTime ? v[u].x.getTime() : v[u].x) < t.axisX.dataInfo.viewPortMin || d > t.axisX.dataInfo.viewPortMax) && !l(v[u].y) && v[u].y.length && "number" == typeof v[u].y[0] && "number" == typeof v[u].y[1] && "number" == typeof v[u].y[2] && "number" == typeof v[u].y[3]) {
                                s = t.axisX.convertValueToPixel(d), n = t.axisY.convertValueToPixel(v[u].y[0]), o = t.axisY.convertValueToPixel(v[u].y[1]), r = t.axisY.convertValueToPixel(v[u].y[2]), h = t.axisY.convertValueToPixel(v[u].y[3]);
                                var k = s - m / 2 << 0,
                                    M = k + m << 0,
                                    T = (c = y.options.fallingColor ? y.fallingColor : y._colorSet[0], x = v[u].color ? v[u].color : y._colorSet[0], Math.round(Math.max(1, .15 * m))),
                                    P = 0 == T % 2 ? 0 : .5,
                                    w = y.dataPointIds[u];
                                this._eventManager.objectMap[w] = {
                                    id: w,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: b,
                                    dataPointIndex: u,
                                    x1: k,
                                    y1: n,
                                    x2: M,
                                    y2: o,
                                    x3: s,
                                    y3: r,
                                    x4: s,
                                    y4: h,
                                    borderThickness: T,
                                    color: x
                                }, i.strokeStyle = x, i.beginPath(), i.lineWidth = T, a.lineWidth = Math.max(T, 4), "candlestick" === y.type ? (i.moveTo(s - P, o), i.lineTo(s - P, Math.min(n, h)), i.stroke(), i.moveTo(s - P, Math.max(n, h)), i.lineTo(s - P, r), i.stroke(), st(i, k, Math.min(n, h), M, Math.max(n, h), v[u].y[0] <= v[u].y[3] ? y.risingColor : c, T, x, f, f, !1, !1, y.fillOpacity), D && (x = void 0, a.strokeStyle = x, a.moveTo(s - P, o), a.lineTo(s - P, Math.min(n, h)), a.stroke(), a.moveTo(s - P, Math.max(n, h)), a.lineTo(s - P, r), a.stroke(), st(a, k, Math.min(n, h), M, Math.max(n, h), x, 0, null, !1, !1, !1, !1))) : "ohlc" === y.type && (i.moveTo(s - P, o), i.lineTo(s - P, r), i.stroke(), i.beginPath(), i.moveTo(s, n), i.lineTo(k, n), i.stroke(), i.beginPath(), i.moveTo(s, h), i.lineTo(M, h), i.stroke(), D && (x = void 0, a.strokeStyle = x, a.moveTo(s - P, o), a.lineTo(s - P, r), a.stroke(), a.beginPath(), a.moveTo(s, n), a.lineTo(k, n), a.stroke(), a.beginPath(), a.moveTo(s, h), a.lineTo(M, h), a.stroke())), (v[u].indexLabel || y.indexLabel || v[u].indexLabelFormatter || y.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: y.type,
                                    dataPoint: v[u],
                                    dataSeries: y,
                                    point: {
                                        x: k + (M - k) / 2,
                                        y: t.axisY.reversed ? r : o
                                    },
                                    direction: 1,
                                    bounds: {
                                        x1: k,
                                        y1: Math.min(o, r),
                                        x2: M,
                                        y2: Math.max(o, r)
                                    },
                                    color: x
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(p.x1, p.y1, p.width, p.height), a.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderBoxAndWhisker = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e,
                a = this._eventManager.ghostCtx;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s, n, o, r, h, x, c, p = null,
                    u = this.plotArea,
                    m = 0,
                    g = (p = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .015 * this.width, t.axisX.dataInfo.minDiff);
                isFinite(g) || (g = .3 * Math.abs(t.axisX.range)), g = this.options.dataPointWidth ? this.dataPointWidth : .7 * u.width * (t.axisX.logarithmic ? Math.log(g) / Math.log(t.axisX.range) : Math.abs(g) / Math.abs(t.axisX.range)) << 0, this.dataPointMaxWidth && p > m && (p = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, m)), !this.dataPointMaxWidth && this.dataPointMinWidth && m < p && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, p)), g < p && (g = p), g > m && (g = m), i.save(), D && a.save(), i.beginPath(), i.rect(u.x1, u.y1, u.width, u.height), i.clip(), D && (a.beginPath(), a.rect(u.x1, u.y1, u.width, u.height), a.clip());
                for (var b = !!t.axisY.reversed, y = 0; y < t.dataSeriesIndexes.length; y++) {
                    var v = t.dataSeriesIndexes[y],
                        f = this.data[v],
                        k = f.dataPoints;
                    if (0 < k.length) {
                        var M = !!(5 < g && f.bevelEnabled);
                        for (m = 0; m < k.length; m++)
                            if (!((c = k[m].getTime ? k[m].x.getTime() : k[m].x) < t.axisX.dataInfo.viewPortMin || c > t.axisX.dataInfo.viewPortMax) && !l(k[m].y) && k[m].y.length && "number" == typeof k[m].y[0] && "number" == typeof k[m].y[1] && "number" == typeof k[m].y[2] && "number" == typeof k[m].y[3] && "number" == typeof k[m].y[4] && 5 === k[m].y.length) {
                                s = t.axisX.convertValueToPixel(c), n = t.axisY.convertValueToPixel(k[m].y[0]), o = t.axisY.convertValueToPixel(k[m].y[1]), r = t.axisY.convertValueToPixel(k[m].y[2]), h = t.axisY.convertValueToPixel(k[m].y[3]), x = t.axisY.convertValueToPixel(k[m].y[4]);
                                var T = s - g / 2 << 0,
                                    P = s + g / 2 << 0,
                                    w = (p = k[m].color ? k[m].color : f._colorSet[0], Math.round(Math.max(1, .15 * g))),
                                    C = 0 == w % 2 ? 0 : .5,
                                    S = k[m].whiskerColor ? k[m].whiskerColor : k[m].color ? f.whiskerColor ? f.whiskerColor : k[m].color : f.whiskerColor ? f.whiskerColor : p,
                                    _ = "number" == typeof k[m].whiskerThickness ? k[m].whiskerThickness : "number" == typeof f.options.whiskerThickness ? f.whiskerThickness : w,
                                    B = k[m].whiskerDashType ? k[m].whiskerDashType : f.whiskerDashType,
                                    F = "number" == typeof(F = l(k[m].whiskerLength) ? l(f.options.whiskerLength) ? g : f.whiskerLength : k[m].whiskerLength) ? 0 >= F ? 0 : F >= g ? g : F : "string" == typeof F ? parseInt(F) * g / 100 > g ? g : parseInt(F) * g / 100 : g,
                                    A = 1 == Math.round(_) % 2 ? .5 : 0,
                                    L = k[m].stemColor ? k[m].stemColor : k[m].color ? f.stemColor ? f.stemColor : k[m].color : f.stemColor ? f.stemColor : p,
                                    I = "number" == typeof k[m].stemThickness ? k[m].stemThickness : "number" == typeof f.options.stemThickness ? f.stemThickness : w,
                                    V = 1 == Math.round(I) % 2 ? .5 : 0,
                                    W = k[m].stemDashType ? k[m].stemDashType : f.stemDashType,
                                    z = k[m].lineColor ? k[m].lineColor : k[m].color ? f.lineColor ? f.lineColor : k[m].color : f.lineColor ? f.lineColor : p,
                                    X = "number" == typeof k[m].lineThickness ? k[m].lineThickness : "number" == typeof f.options.lineThickness ? f.lineThickness : w,
                                    Y = k[m].lineDashType ? k[m].lineDashType : f.lineDashType,
                                    E = 1 == Math.round(X) % 2 ? .5 : 0,
                                    O = f.upperBoxColor,
                                    R = f.lowerBoxColor,
                                    N = l(f.options.fillOpacity) ? 1 : f.fillOpacity,
                                    H = f.dataPointIds[m];
                                this._eventManager.objectMap[H] = {
                                    id: H,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: v,
                                    dataPointIndex: m,
                                    x1: T,
                                    y1: n,
                                    x2: P,
                                    y2: o,
                                    x3: s,
                                    y3: r,
                                    x4: s,
                                    y4: h,
                                    y5: x,
                                    borderThickness: w,
                                    color: p,
                                    stemThickness: I,
                                    stemColor: L,
                                    whiskerThickness: _,
                                    whiskerLength: F,
                                    whiskerColor: S,
                                    lineThickness: X,
                                    lineColor: z
                                }, i.save(), 0 < I && (i.beginPath(), i.strokeStyle = L, i.lineWidth = I, i.setLineDash && i.setLineDash(d(W, I)), i.moveTo(s - V, o), i.lineTo(s - V, n), i.stroke(), i.moveTo(s - V, h), i.lineTo(s - V, r), i.stroke()), i.restore(), a.lineWidth = Math.max(w, 4), i.beginPath(), st(i, T, Math.min(x, o), P, Math.max(o, x), R, 0, p, !!b && M, !b && M, !1, !1, N), i.beginPath(), st(i, T, Math.min(r, x), P, Math.max(x, r), O, 0, p, !b && M, !!b && M, !1, !1, N), i.beginPath(), i.lineWidth = w, i.strokeStyle = p, i.rect(T - C, Math.min(o, r) - C, P - T + 2 * C, Math.max(o, r) - Math.min(o, r) + 2 * C), i.stroke(), i.save(), 0 < X && (i.beginPath(), i.globalAlpha = 1, i.setLineDash && i.setLineDash(d(Y, X)), i.strokeStyle = z, i.lineWidth = X, i.moveTo(T, x - E), i.lineTo(P, x - E), i.stroke()), i.restore(), i.save(), 0 < _ && (i.beginPath(), i.setLineDash && i.setLineDash(d(B, _)), i.strokeStyle = S, i.lineWidth = _, i.moveTo(s - F / 2 << 0, h - A), i.lineTo(s + F / 2 << 0, h - A), i.stroke(), i.moveTo(s - F / 2 << 0, n + A), i.lineTo(s + F / 2 << 0, n + A), i.stroke()), i.restore(), D && (p = void 0, a.strokeStyle = p, a.lineWidth = I, 0 < I && (a.moveTo(s - C - V, o), a.lineTo(s - C - V, Math.max(n, h)), a.stroke(), a.moveTo(s - C - V, Math.min(n, h)), a.lineTo(s - C - V, r), a.stroke()), st(a, T, Math.max(o, r), P, Math.min(o, r), p, 0, null, !1, !1, !1, !1), 0 < _ && (a.beginPath(), a.lineWidth = _, a.moveTo(s + F / 2, h - A), a.lineTo(s - F / 2, h - A), a.stroke(), a.moveTo(s + F / 2, n + A), a.lineTo(s - F / 2, n + A), a.stroke())), (k[m].indexLabel || f.indexLabel || k[m].indexLabelFormatter || f.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: f.type,
                                    dataPoint: k[m],
                                    dataSeries: f,
                                    point: {
                                        x: T + (P - T) / 2,
                                        y: t.axisY.reversed ? n : h
                                    },
                                    direction: 1,
                                    bounds: {
                                        x1: T,
                                        y1: Math.min(n, h),
                                        x2: P,
                                        y2: Math.max(n, h)
                                    },
                                    color: p
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(u.x1, u.y1, u.width, u.height), a.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderRangeColumn = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n, o = null,
                    r = this.plotArea,
                    h = 0;
                h = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                a = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : .03 * this.width;
                var d = t.axisX.dataInfo.minDiff;
                isFinite(d) || (d = .3 * Math.abs(t.axisX.range)), d = this.options.dataPointWidth ? this.dataPointWidth : r.width * (t.axisX.logarithmic ? Math.log(d) / Math.log(t.axisX.range) : Math.abs(d) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && h > a && (h = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, a)), !this.dataPointMaxWidth && this.dataPointMinWidth && a < h && (a = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, h)), d < h && (d = h), d > a && (d = a), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(r.x1, r.y1, r.width, r.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.clip());
                for (var x = 0; x < t.dataSeriesIndexes.length; x++) {
                    var c = t.dataSeriesIndexes[x],
                        p = this.data[c],
                        u = p.dataPoints;
                    if (0 < u.length) {
                        var m = !!(5 < d && p.bevelEnabled);
                        for (h = 0; h < u.length; h++)
                            if (!((n = u[h].getTime ? u[h].x.getTime() : u[h].x) < t.axisX.dataInfo.viewPortMin || n > t.axisX.dataInfo.viewPortMax) && !l(u[h].y) && u[h].y.length && "number" == typeof u[h].y[0] && "number" == typeof u[h].y[1]) {
                                o = t.axisX.convertValueToPixel(n), a = t.axisY.convertValueToPixel(u[h].y[0]), s = t.axisY.convertValueToPixel(u[h].y[1]);
                                var g = t.axisX.reversed ? o + t.plotType.totalDataSeries * d / 2 - (t.previousDataSeriesCount + x) * d << 0 : o - t.plotType.totalDataSeries * d / 2 + (t.previousDataSeriesCount + x) * d << 0,
                                    b = t.axisX.reversed ? g - d << 0 : g + d << 0;
                                o = u[h].color ? u[h].color : p._colorSet[h % p._colorSet.length];
                                if (a > s) {
                                    var y = a;
                                    a = s, s = y
                                }
                                y = p.dataPointIds[h], this._eventManager.objectMap[y] = {
                                    id: y,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: c,
                                    dataPointIndex: h,
                                    x1: g,
                                    y1: a,
                                    x2: b,
                                    y2: s
                                }, st(i, g, a, b, s, o, 0, o, m, m, !1, !1, p.fillOpacity), o = void 0, D && st(this._eventManager.ghostCtx, g, a, b, s, o, 0, null, !1, !1, !1, !1), (u[h].indexLabel || p.indexLabel || u[h].indexLabelFormatter || p.indexLabelFormatter) && (this._indexLabels.push({
                                    chartType: "rangeColumn",
                                    dataPoint: u[h],
                                    dataSeries: p,
                                    indexKeyword: 0,
                                    point: {
                                        x: g + (b - g) / 2,
                                        y: u[h].y[1] >= u[h].y[0] ? s : a
                                    },
                                    direction: u[h].y[1] >= u[h].y[0] ? -1 : 1,
                                    bounds: {
                                        x1: g,
                                        y1: Math.min(a, s),
                                        x2: b,
                                        y2: Math.max(a, s)
                                    },
                                    color: o
                                }), this._indexLabels.push({
                                    chartType: "rangeColumn",
                                    dataPoint: u[h],
                                    dataSeries: p,
                                    indexKeyword: 1,
                                    point: {
                                        x: g + (b - g) / 2,
                                        y: u[h].y[1] >= u[h].y[0] ? a : s
                                    },
                                    direction: u[h].y[1] >= u[h].y[0] ? 1 : -1,
                                    bounds: {
                                        x1: g,
                                        y1: Math.min(a, s),
                                        x2: b,
                                        y2: Math.max(a, s)
                                    },
                                    color: o
                                }))
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(r.x1, r.y1, r.width, r.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderError = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e,
                a = !!t.axisY._position && ("left" !== t.axisY._position && "right" !== t.axisY._position);
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s, n, o, r, h, d, x, c = null,
                    p = !1,
                    u = this.plotArea,
                    m = 0,
                    g = t.axisX.dataInfo.minDiff;
                isFinite(g) || (g = .3 * Math.abs(t.axisX.range)), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(u.x1, u.y1, u.width, u.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(u.x1, u.y1, u.width, u.height), this._eventManager.ghostCtx.clip());
                for (var b = 0, y = 0; y < this.data.length; y++) !this.data[y].type.match(/(bar|column)/gi) || !this.data[y].visible || this.data[y].type.match(/(stacked)/gi) && b || b++;
                for (var v = 0; v < t.dataSeriesIndexes.length; v++) {
                    var f = t.dataSeriesIndexes[v],
                        k = this.data[f],
                        M = k.dataPoints,
                        T = !l(k._linkedSeries) && !(!k._linkedSeries.type.match(/(bar|column)/gi) || !k._linkedSeries.visible),
                        P = 0;
                    if (T)
                        for (c = k._linkedSeries.id, y = 0; y < c; y++) !this.data[y].type.match(/(bar|column)/gi) || !this.data[y].visible || this.data[y].type.match(/(stacked)/gi) && P || (this.data[y].type.match(/(range)/gi) && (p = !0), P++);
                    if (c = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1, m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : a ? Math.min(.15 * this.height, this.plotArea.height / (T ? b : 1) * .9) << 0 : .3 * this.width, p && (m = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : a ? Math.min(.15 * this.height, this.plotArea.height / (T ? b : 1) * .9) << 0 : .03 * this.width), y = this.options.dataPointWidth ? this.dataPointWidth : (a ? u.height : u.width) * (t.axisX.logarithmic ? Math.log(g) / Math.log(t.axisX.range) : Math.abs(g) / Math.abs(t.axisX.range)) / (T ? b : 1) * .9 << 0, this.dataPointMaxWidth && c > m && (c = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, m)), !this.dataPointMaxWidth && this.dataPointMinWidth && m < c && (m = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, c)), y < c && (y = c), y > m && (y = m), 0 < M.length) {
                        var w = k._colorSet;
                        for (m = 0; m < M.length; m++) {
                            c = k.lineColor = k.options.color ? k.options.color : w[0];
                            var C = {
                                color: M[m].whiskerColor ? M[m].whiskerColor : M[m].color ? k.whiskerColor ? k.whiskerColor : M[m].color : k.whiskerColor ? k.whiskerColor : c,
                                thickness: l(M[m].whiskerThickness) ? k.whiskerThickness : M[m].whiskerThickness,
                                dashType: M[m].whiskerDashType ? M[m].whiskerDashType : k.whiskerDashType,
                                length: l(M[m].whiskerLength) ? l(k.options.whiskerLength) ? y : k.options.whiskerLength : M[m].whiskerLength,
                                trimLength: l(M[m].whiskerLength) && l(k.options.whiskerLength) ? 50 : 0
                            };
                            C.length = "number" == typeof C.length ? 0 >= C.length ? 0 : C.length >= y ? y : C.length : "string" == typeof C.length ? parseInt(C.length) * y / 100 > y ? y : parseInt(C.length) * y / 100 > y : y, C.thickness = "number" == typeof C.thickness ? 0 > C.thickness ? 0 : Math.round(C.thickness) : 2;
                            var S = {
                                color: M[m].stemColor ? M[m].stemColor : M[m].color ? k.stemColor ? k.stemColor : M[m].color : k.stemColor ? k.stemColor : c,
                                thickness: M[m].stemThickness ? M[m].stemThickness : k.stemThickness,
                                dashType: M[m].stemDashType ? M[m].stemDashType : k.stemDashType
                            };
                            if (S.thickness = "number" == typeof S.thickness ? 0 > S.thickness ? 0 : Math.round(S.thickness) : 2, !((x = M[m].getTime ? M[m].x.getTime() : M[m].x) < t.axisX.dataInfo.viewPortMin || x > t.axisX.dataInfo.viewPortMax) && !l(M[m].y) && M[m].y.length && "number" == typeof M[m].y[0] && "number" == typeof M[m].y[1]) {
                                var _ = t.axisX.convertValueToPixel(x);
                                a ? n = _ : s = _, _ = t.axisY.convertValueToPixel(M[m].y[0]), a ? o = _ : h = _, _ = t.axisY.convertValueToPixel(M[m].y[1]), a ? r = _ : d = _, a ? (h = t.axisX.reversed ? n + (T ? b : 1) * y / 2 - (T ? P - 1 : 0) * y << 0 : n - (T ? b : 1) * y / 2 + (T ? P - 1 : 0) * y << 0, d = t.axisX.reversed ? h - y << 0 : h + y << 0) : (o = t.axisX.reversed ? s + (T ? b : 1) * y / 2 - (T ? P - 1 : 0) * y << 0 : s - (T ? b : 1) * y / 2 + (T ? P - 1 : 0) * y << 0, r = t.axisX.reversed ? o - y << 0 : o + y << 0), !a && h > d && (_ = h, h = d, d = _), a && o > r && (_ = o, o = r, r = _), _ = k.dataPointIds[m], this._eventManager.objectMap[_] = {
                                    id: _,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: f,
                                    dataPointIndex: m,
                                    x1: Math.min(o, r),
                                    y1: Math.min(h, d),
                                    x2: Math.max(r, o),
                                    y2: Math.max(d, h),
                                    isXYSwapped: a,
                                    stemProperties: S,
                                    whiskerProperties: C
                                }, B(i, Math.min(o, r), Math.min(h, d), Math.max(r, o), Math.max(d, h), c, C, S, a), D && B(this._eventManager.ghostCtx, o, h, r, d, c, C, S, a), (M[m].indexLabel || k.indexLabel || M[m].indexLabelFormatter || k.indexLabelFormatter) && (this._indexLabels.push({
                                    chartType: "error",
                                    dataPoint: M[m],
                                    dataSeries: k,
                                    indexKeyword: 0,
                                    point: {
                                        x: a ? M[m].y[1] >= M[m].y[0] ? o : r : o + (r - o) / 2,
                                        y: a ? h + (d - h) / 2 : M[m].y[1] >= M[m].y[0] ? d : h
                                    },
                                    direction: M[m].y[1] >= M[m].y[0] ? -1 : 1,
                                    bounds: {
                                        x1: a ? Math.min(o, r) : o,
                                        y1: a ? h : Math.min(h, d),
                                        x2: a ? Math.max(o, r) : r,
                                        y2: a ? d : Math.max(h, d)
                                    },
                                    color: c,
                                    axisSwapped: a
                                }), this._indexLabels.push({
                                    chartType: "error",
                                    dataPoint: M[m],
                                    dataSeries: k,
                                    indexKeyword: 1,
                                    point: {
                                        x: a ? M[m].y[1] >= M[m].y[0] ? r : o : o + (r - o) / 2,
                                        y: a ? h + (d - h) / 2 : M[m].y[1] >= M[m].y[0] ? h : d
                                    },
                                    direction: M[m].y[1] >= M[m].y[0] ? 1 : -1,
                                    bounds: {
                                        x1: a ? Math.min(o, r) : o,
                                        y1: a ? h : Math.min(h, d),
                                        x2: a ? Math.max(o, r) : r,
                                        y2: a ? d : Math.max(h, d)
                                    },
                                    color: c,
                                    axisSwapped: a
                                }))
                            }
                        }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(u.x1, u.y1, u.width, u.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderRangeBar = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n, o, r = null,
                    h = this.plotArea,
                    d = 0;
                d = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                a = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.height, this.plotArea.height / t.plotType.totalDataSeries * .9) << 0;
                var x = t.axisX.dataInfo.minDiff;
                isFinite(x) || (x = .3 * Math.abs(t.axisX.range)), x = this.options.dataPointWidth ? this.dataPointWidth : h.height * (t.axisX.logarithmic ? Math.log(x) / Math.log(t.axisX.range) : Math.abs(x) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .9 << 0, this.dataPointMaxWidth && d > a && (d = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, a)), !this.dataPointMaxWidth && this.dataPointMinWidth && a < d && (a = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, d)), x < d && (x = d), x > a && (x = a), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(h.x1, h.y1, h.width, h.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip());
                for (var c = 0; c < t.dataSeriesIndexes.length; c++) {
                    var p = t.dataSeriesIndexes[c],
                        u = this.data[p],
                        m = u.dataPoints;
                    if (0 < m.length) {
                        var g = !!(5 < x && u.bevelEnabled);
                        for (i.strokeStyle = "#4572A7 ", d = 0; d < m.length; d++)
                            if (!((o = m[d].getTime ? m[d].x.getTime() : m[d].x) < t.axisX.dataInfo.viewPortMin || o > t.axisX.dataInfo.viewPortMax) && !l(m[d].y) && m[d].y.length && "number" == typeof m[d].y[0] && "number" == typeof m[d].y[1]) {
                                a = t.axisY.convertValueToPixel(m[d].y[0]), s = t.axisY.convertValueToPixel(m[d].y[1]), n = t.axisX.convertValueToPixel(o), n = t.axisX.reversed ? n + t.plotType.totalDataSeries * x / 2 - (t.previousDataSeriesCount + c) * x << 0 : n - t.plotType.totalDataSeries * x / 2 + (t.previousDataSeriesCount + c) * x << 0;
                                var b = t.axisX.reversed ? n - x << 0 : n + x << 0;
                                a > s && (r = a, a = s, s = r), r = m[d].color ? m[d].color : u._colorSet[d % u._colorSet.length], st(i, a, n, s, b, r, 0, null, g, !1, !1, !1, u.fillOpacity), r = u.dataPointIds[d], this._eventManager.objectMap[r] = {
                                    id: r,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: p,
                                    dataPointIndex: d,
                                    x1: a,
                                    y1: n,
                                    x2: s,
                                    y2: b
                                }, r = void 0, D && st(this._eventManager.ghostCtx, a, n, s, b, r, 0, null, !1, !1, !1, !1), (m[d].indexLabel || u.indexLabel || m[d].indexLabelFormatter || u.indexLabelFormatter) && (this._indexLabels.push({
                                    chartType: "rangeBar",
                                    dataPoint: m[d],
                                    dataSeries: u,
                                    indexKeyword: 0,
                                    point: {
                                        x: m[d].y[1] >= m[d].y[0] ? a : s,
                                        y: n + (b - n) / 2
                                    },
                                    direction: m[d].y[1] >= m[d].y[0] ? -1 : 1,
                                    bounds: {
                                        x1: Math.min(a, s),
                                        y1: n,
                                        x2: Math.max(a, s),
                                        y2: b
                                    },
                                    color: r
                                }), this._indexLabels.push({
                                    chartType: "rangeBar",
                                    dataPoint: m[d],
                                    dataSeries: u,
                                    indexKeyword: 1,
                                    point: {
                                        x: m[d].y[1] >= m[d].y[0] ? s : a,
                                        y: n + (b - n) / 2
                                    },
                                    direction: m[d].y[1] >= m[d].y[0] ? 1 : -1,
                                    bounds: {
                                        x1: Math.min(a, s),
                                        y1: n,
                                        x2: Math.max(a, s),
                                        y2: b
                                    },
                                    color: r
                                }))
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        }, o.prototype.renderRangeArea = function(t) {
            function e() {
                if (v) {
                    var t = null;
                    0 < x.lineThickness && a.stroke();
                    for (var e = r.length - 1; 0 <= e; e--) t = r[e], a.lineTo(t.x, t.y), s.lineTo(t.x, t.y);
                    if (a.closePath(), a.globalAlpha = x.fillOpacity, a.fill(), a.globalAlpha = 1, s.fill(), 0 < x.lineThickness) {
                        for (a.beginPath(), a.moveTo(t.x, t.y), e = 0; e < r.length; e++) t = r[e], a.lineTo(t.x, t.y);
                        a.stroke()
                    }
                    a.beginPath(), a.moveTo(p, u), s.beginPath(), s.moveTo(p, u), v = {
                        x: p,
                        y: u
                    }, (r = []).push({
                        x: p,
                        y: m
                    })
                }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
                a = D ? this._preRenderCtx : i;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s = this._eventManager.ghostCtx,
                    n = [],
                    o = this.plotArea;
                a.save(), D && s.save(), a.beginPath(), a.rect(o.x1, o.y1, o.width, o.height), a.clip(), D && (s.beginPath(), s.rect(o.x1, o.y1, o.width, o.height), s.clip());
                for (var l = 0; l < t.dataSeriesIndexes.length; l++) {
                    var r = [],
                        h = t.dataSeriesIndexes[l],
                        x = this.data[h],
                        c = x.dataPoints;
                    n = x.id;
                    this._eventManager.objectMap[n] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: h
                    }, n = void 0, s.fillStyle = n;
                    n = [];
                    var p, u, m, g, b = !0,
                        y = 0,
                        v = null;
                    if (0 < c.length) {
                        var f = x._colorSet[y % x._colorSet.length],
                            k = x.lineColor = x.options.lineColor || f,
                            M = k;
                        a.fillStyle = f, a.strokeStyle = k, a.lineWidth = x.lineThickness;
                        var T = "solid";
                        if (a.setLineDash) {
                            var P = d(x.nullDataLineDashType, x.lineThickness),
                                w = d(T = x.lineDashType, x.lineThickness);
                            a.setLineDash(w)
                        }
                        for (var C = !0; y < c.length; y++)
                            if (!((g = c[y].x.getTime ? c[y].x.getTime() : c[y].x) < t.axisX.dataInfo.viewPortMin || g > t.axisX.dataInfo.viewPortMax && (!x.connectNullData || !C)))
                                if (null !== c[y].y && c[y].y.length && "number" == typeof c[y].y[0] && "number" == typeof c[y].y[1]) {
                                    if (p = t.axisX.convertValueToPixel(g), u = t.axisY.convertValueToPixel(c[y].y[0]), m = t.axisY.convertValueToPixel(c[y].y[1]), b || C ? (x.connectNullData && !b ? (a.setLineDash && (x.options.nullDataLineDashType || T === x.lineDashType && x.lineDashType !== x.nullDataLineDashType) && (r[r.length - 1].newLineDashArray = w, T = x.nullDataLineDashType, a.setLineDash(P)), a.lineTo(p, u), D && s.lineTo(p, u), r.push({
                                            x: p,
                                            y: m
                                        })) : (a.beginPath(), a.moveTo(p, u), v = {
                                            x: p,
                                            y: u
                                        }, (r = []).push({
                                            x: p,
                                            y: m
                                        }), D && (s.beginPath(), s.moveTo(p, u))), C = b = !1) : (a.lineTo(p, u), r.push({
                                            x: p,
                                            y: m
                                        }), D && s.lineTo(p, u), 0 == y % 250 && e()), g = x.dataPointIds[y], this._eventManager.objectMap[g] = {
                                            id: g,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: h,
                                            dataPointIndex: y,
                                            x1: p,
                                            y1: u,
                                            y2: m
                                        }, y < c.length - 1 && (M !== (c[y].lineColor || k) || T !== (c[y].lineDashType || x.lineDashType)) && (e(), M = c[y].lineColor || k, r[r.length - 1].newStrokeStyle = M, a.strokeStyle = M, a.setLineDash && (c[y].lineDashType ? (T = c[y].lineDashType, r[r.length - 1].newLineDashArray = d(T, x.lineThickness), a.setLineDash(r[r.length - 1].newLineDashArray)) : (T = x.lineDashType, r[r.length - 1].newLineDashArray = w, a.setLineDash(w)))), 0 !== c[y].markerSize && (0 < c[y].markerSize || 0 < x.markerSize)) {
                                        var S = x.getMarkerProperties(y, p, m, a);
                                        n.push(S);
                                        var _ = void 0;
                                        D && n.push({
                                            x: p,
                                            y: m,
                                            ctx: s,
                                            type: S.type,
                                            size: S.size,
                                            color: _,
                                            borderColor: _,
                                            borderThickness: S.borderThickness
                                        }), S = x.getMarkerProperties(y, p, u, a), n.push(S), _ = void 0, D && n.push({
                                            x: p,
                                            y: u,
                                            ctx: s,
                                            type: S.type,
                                            size: S.size,
                                            color: _,
                                            borderColor: _,
                                            borderThickness: S.borderThickness
                                        })
                                    }(c[y].indexLabel || x.indexLabel || c[y].indexLabelFormatter || x.indexLabelFormatter) && (this._indexLabels.push({
                                        chartType: "rangeArea",
                                        dataPoint: c[y],
                                        dataSeries: x,
                                        indexKeyword: 0,
                                        point: {
                                            x: p,
                                            y: u
                                        },
                                        direction: c[y].y[0] > c[y].y[1] === t.axisY.reversed ? -1 : 1,
                                        color: f
                                    }), this._indexLabels.push({
                                        chartType: "rangeArea",
                                        dataPoint: c[y],
                                        dataSeries: x,
                                        indexKeyword: 1,
                                        point: {
                                            x: p,
                                            y: m
                                        },
                                        direction: c[y].y[0] > c[y].y[1] === t.axisY.reversed ? 1 : -1,
                                        color: f
                                    }))
                                } else C || b || e(), C = !0;
                        e(), et.drawMarkers(n)
                    }
                }
                return D && (i.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), a.restore(), {
                    source: i,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderRangeSplineArea = function(t) {
            function e(t, e) {
                var i = _(g, 2);
                if (0 < i.length) {
                    if (0 < h.lineThickness) {
                        a.strokeStyle = e, a.setLineDash && a.setLineDash(t), a.beginPath(), a.moveTo(i[0].x, i[0].y);
                        for (var n = 0; n < i.length - 3; n += 3)(i[n].newStrokeStyle || i[n].newLineDashArray) && (a.stroke(), a.beginPath(), a.moveTo(i[n].x, i[n].y), i[n].newStrokeStyle && (a.strokeStyle = i[n].newStrokeStyle), i[n].newLineDashArray && a.setLineDash(i[n].newLineDashArray)), a.bezierCurveTo(i[n + 1].x, i[n + 1].y, i[n + 2].x, i[n + 2].y, i[n + 3].x, i[n + 3].y);
                        a.stroke()
                    }
                    for (a.beginPath(), a.moveTo(i[0].x, i[0].y), D && (s.beginPath(), s.moveTo(i[0].x, i[0].y)), n = 0; n < i.length - 3; n += 3) a.bezierCurveTo(i[n + 1].x, i[n + 1].y, i[n + 2].x, i[n + 2].y, i[n + 3].x, i[n + 3].y), D && s.bezierCurveTo(i[n + 1].x, i[n + 1].y, i[n + 2].x, i[n + 2].y, i[n + 3].x, i[n + 3].y);
                    for (i = _(b, 2), a.lineTo(b[b.length - 1].x, b[b.length - 1].y), n = i.length - 1; 2 < n; n -= 3) a.bezierCurveTo(i[n - 1].x, i[n - 1].y, i[n - 2].x, i[n - 2].y, i[n - 3].x, i[n - 3].y), D && s.bezierCurveTo(i[n - 1].x, i[n - 1].y, i[n - 2].x, i[n - 2].y, i[n - 3].x, i[n - 3].y);
                    if (a.closePath(), a.globalAlpha = h.fillOpacity, a.fill(), D && (s.closePath(), s.fill()), a.globalAlpha = 1, 0 < h.lineThickness) {
                        a.strokeStyle = e, a.setLineDash && a.setLineDash(t), a.beginPath(), a.moveTo(i[0].x, i[0].y);
                        for (var o = n = 0; n < i.length - 3; n += 3, o++)(g[o].newStrokeStyle || g[o].newLineDashArray) && (a.stroke(), a.beginPath(), a.moveTo(i[n].x, i[n].y), g[o].newStrokeStyle && (a.strokeStyle = g[o].newStrokeStyle), g[o].newLineDashArray && a.setLineDash(g[o].newLineDashArray)), a.bezierCurveTo(i[n + 1].x, i[n + 1].y, i[n + 2].x, i[n + 2].y, i[n + 3].x, i[n + 3].y);
                        a.stroke()
                    }
                    a.beginPath()
                }
            }
            var i = t.targetCanvasCtx || this.plotArea.ctx,
                a = D ? this._preRenderCtx : i;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var s = this._eventManager.ghostCtx,
                    n = [],
                    o = this.plotArea;
                a.save(), D && s.save(), a.beginPath(), a.rect(o.x1, o.y1, o.width, o.height), a.clip(), D && (s.beginPath(), s.rect(o.x1, o.y1, o.width, o.height), s.clip());
                for (var l = 0; l < t.dataSeriesIndexes.length; l++) {
                    var r = t.dataSeriesIndexes[l],
                        h = this.data[r],
                        x = h.dataPoints;
                    n = h.id;
                    this._eventManager.objectMap[n] = {
                        objectType: "dataSeries",
                        dataSeriesIndex: r
                    }, n = void 0, s.fillStyle = n;
                    n = [];
                    var c, p, u, m = 0,
                        g = [],
                        b = [];
                    if (0 < x.length) {
                        var y = h._colorSet[m % h._colorSet.length],
                            v = h.lineColor = h.options.lineColor || y,
                            f = v;
                        a.fillStyle = y, a.lineWidth = h.lineThickness;
                        var k, M = "solid";
                        if (a.setLineDash) {
                            var T = d(h.nullDataLineDashType, h.lineThickness);
                            k = d(M = h.lineDashType, h.lineThickness)
                        }
                        for (p = !1; m < x.length; m++)
                            if (!((c = x[m].x.getTime ? x[m].x.getTime() : x[m].x) < t.axisX.dataInfo.viewPortMin || c > t.axisX.dataInfo.viewPortMax && (!h.connectNullData || !p)))
                                if (null !== x[m].y && x[m].y.length && "number" == typeof x[m].y[0] && "number" == typeof x[m].y[1]) {
                                    c = t.axisX.convertValueToPixel(c), p = t.axisY.convertValueToPixel(x[m].y[0]), u = t.axisY.convertValueToPixel(x[m].y[1]);
                                    var P = h.dataPointIds[m];
                                    if (this._eventManager.objectMap[P] = {
                                            id: P,
                                            objectType: "dataPoint",
                                            dataSeriesIndex: r,
                                            dataPointIndex: m,
                                            x1: c,
                                            y1: p,
                                            y2: u
                                        }, g[g.length] = {
                                            x: c,
                                            y: p
                                        }, b[b.length] = {
                                            x: c,
                                            y: u
                                        }, m < x.length - 1 && (f !== (x[m].lineColor || v) || M !== (x[m].lineDashType || h.lineDashType)) && (f = x[m].lineColor || v, g[g.length - 1].newStrokeStyle = f, a.setLineDash && (x[m].lineDashType ? (M = x[m].lineDashType, g[g.length - 1].newLineDashArray = d(M, h.lineThickness)) : (M = h.lineDashType, g[g.length - 1].newLineDashArray = k))), 0 !== x[m].markerSize && (0 < x[m].markerSize || 0 < h.markerSize)) {
                                        var w = h.getMarkerProperties(m, c, p, a);
                                        n.push(w);
                                        var C = void 0;
                                        D && n.push({
                                            x: c,
                                            y: p,
                                            ctx: s,
                                            type: w.type,
                                            size: w.size,
                                            color: C,
                                            borderColor: C,
                                            borderThickness: w.borderThickness
                                        }), w = h.getMarkerProperties(m, c, u, a), n.push(w), C = void 0, D && n.push({
                                            x: c,
                                            y: u,
                                            ctx: s,
                                            type: w.type,
                                            size: w.size,
                                            color: C,
                                            borderColor: C,
                                            borderThickness: w.borderThickness
                                        })
                                    }(x[m].indexLabel || h.indexLabel || x[m].indexLabelFormatter || h.indexLabelFormatter) && (this._indexLabels.push({
                                        chartType: "rangeSplineArea",
                                        dataPoint: x[m],
                                        dataSeries: h,
                                        indexKeyword: 0,
                                        point: {
                                            x: c,
                                            y: p
                                        },
                                        direction: x[m].y[0] <= x[m].y[1] ? -1 : 1,
                                        color: y
                                    }), this._indexLabels.push({
                                        chartType: "rangeSplineArea",
                                        dataPoint: x[m],
                                        dataSeries: h,
                                        indexKeyword: 1,
                                        point: {
                                            x: c,
                                            y: u
                                        },
                                        direction: x[m].y[0] <= x[m].y[1] ? 1 : -1,
                                        color: y
                                    })), p = !1
                                } else 0 < m && !p && (h.connectNullData ? a.setLineDash && 0 < g.length && (h.options.nullDataLineDashType || !x[m - 1].lineDashType) && (g[g.length - 1].newLineDashArray = T, M = h.nullDataLineDashType) : (e(k, v), g = [], b = [])), p = !0;
                        e(k, v), et.drawMarkers(n)
                    }
                }
                return D && (i.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && a.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && a.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), a.clearRect(o.x1, o.y1, o.width, o.height), this._eventManager.ghostCtx.restore()), a.restore(), {
                    source: i,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.xClipAnimation,
                    easingFunction: tt.easing.linear,
                    animationBase: 0
                }
            }
        }, o.prototype.renderWaterfall = function(t) {
            var e = t.targetCanvasCtx || this.plotArea.ctx,
                i = D ? this._preRenderCtx : e;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var a, s, n, o, l = this._eventManager.ghostCtx,
                    r = null,
                    h = this.plotArea,
                    x = 0,
                    c = t.axisY.convertValueToPixel(t.axisY.logarithmic ? t.axisY.viewportMinimum : 0);
                x = this.options.dataPointMinWidth ? this.dataPointMinWidth : this.options.dataPointWidth ? this.dataPointWidth : 1;
                s = this.options.dataPointMaxWidth ? this.dataPointMaxWidth : this.options.dataPointWidth ? this.dataPointWidth : Math.min(.15 * this.width, this.plotArea.width / t.plotType.totalDataSeries * .9) << 0;
                var p = t.axisX.dataInfo.minDiff;
                isFinite(p) || (p = .3 * Math.abs(t.axisX.range)), p = this.options.dataPointWidth ? this.dataPointWidth : h.width * (t.axisX.logarithmic ? Math.log(p) / Math.log(t.axisX.range) : Math.abs(p) / Math.abs(t.axisX.range)) / t.plotType.totalDataSeries * .6 << 0, this.dataPointMaxWidth && x > s && (x = Math.min(this.options.dataPointWidth ? this.dataPointWidth : 1 / 0, s)), !this.dataPointMaxWidth && this.dataPointMinWidth && s < x && (s = Math.max(this.options.dataPointWidth ? this.dataPointWidth : -1 / 0, x)), p < x && (p = x), p > s && (p = s), i.save(), D && this._eventManager.ghostCtx.save(), i.beginPath(), i.rect(h.x1, h.y1, h.width, h.height), i.clip(), D && (this._eventManager.ghostCtx.beginPath(), this._eventManager.ghostCtx.rect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.clip());
                for (var u = 0; u < t.dataSeriesIndexes.length; u++) {
                    var m = t.dataSeriesIndexes[u],
                        g = this.data[m],
                        b = g.dataPoints;
                    r = g._colorSet[0];
                    g.risingColor = g.options.risingColor ? g.options.risingColor : r, g.fallingColor = g.options.fallingColor ? g.options.fallingColor : "#e40a0a";
                    var y = "number" == typeof g.options.lineThickness ? Math.round(g.lineThickness) : 1,
                        v = 1 == Math.round(y) % 2 ? -.5 : 0;
                    if (0 < b.length) {
                        var f = !!(5 < p && g.bevelEnabled),
                            k = !1,
                            M = null,
                            T = null;
                        for (x = 0; x < b.length; x++)
                            if (o = b[x].getTime ? b[x].x.getTime() : b[x].x, "number" != typeof b[x].y) {
                                if (0 < x && !k && g.connectNullData) var P = g.options.nullDataLineDashType || !b[x - 1].lineDashType ? g.nullDataLineDashType : b[x - 1].lineDashType;
                                k = !0
                            } else {
                                a = t.axisX.convertValueToPixel(o), s = 0 === g.dataPointEOs[x].cumulativeSum ? c : t.axisY.convertValueToPixel(g.dataPointEOs[x].cumulativeSum), n = 0 === g.dataPointEOs[x].cumulativeSumYStartValue ? c : t.axisY.convertValueToPixel(g.dataPointEOs[x].cumulativeSumYStartValue), a = t.axisX.reversed ? a + t.plotType.totalDataSeries * p / 2 - (t.previousDataSeriesCount + u) * p << 0 : a - t.plotType.totalDataSeries * p / 2 + (t.previousDataSeriesCount + u) * p << 0;
                                var w = t.axisX.reversed ? a - p << 0 : a + p << 0;
                                s > n && (r = s, s = n, n = r), t.axisY.reversed && (r = s, s = n, n = r), r = g.dataPointIds[x], this._eventManager.objectMap[r] = {
                                    id: r,
                                    objectType: "dataPoint",
                                    dataSeriesIndex: m,
                                    dataPointIndex: x,
                                    x1: a,
                                    y1: s,
                                    x2: w,
                                    y2: n
                                };
                                var C = b[x].color ? b[x].color : 0 < b[x].y ? g.risingColor : g.fallingColor;
                                st(i, a, s, w, n, C, 0, C, f, f, !1, !1, g.fillOpacity), r = void 0, D && st(this._eventManager.ghostCtx, a, s, w, n, r, 0, null, !1, !1, !1, !1);
                                var S;
                                C = a;
                                S = void 0 !== b[x].isIntermediateSum && !0 === b[x].isIntermediateSum || void 0 !== b[x].isCumulativeSum && !0 === b[x].isCumulativeSum ? 0 < b[x].y ? s : n : 0 < b[x].y ? n : s, 0 < x && M && (!k || g.connectNullData) && (k && i.setLineDash && i.setLineDash(d(P, y)), i.beginPath(), i.moveTo(M, T - v), i.lineTo(C, S - v), 0 < y && i.stroke(), D && (l.beginPath(), l.moveTo(M, T - v), l.lineTo(C, S - v), 0 < y && l.stroke())), k = !1, M = w, T = 0 < b[x].y ? s : n, C = b[x].lineDashType ? b[x].lineDashType : g.options.lineDashType ? g.options.lineDashType : "shortDash", i.strokeStyle = b[x].lineColor ? b[x].lineColor : g.options.lineColor ? g.options.lineColor : "#9e9e9e", i.lineWidth = y, i.setLineDash && (C = d(C, y), i.setLineDash(C)), (b[x].indexLabel || g.indexLabel || b[x].indexLabelFormatter || g.indexLabelFormatter) && this._indexLabels.push({
                                    chartType: "waterfall",
                                    dataPoint: b[x],
                                    dataSeries: g,
                                    point: {
                                        x: a + (w - a) / 2,
                                        y: 0 <= b[x].y ? s : n
                                    },
                                    direction: 0 > b[x].y === t.axisY.reversed ? 1 : -1,
                                    bounds: {
                                        x1: a,
                                        y1: Math.min(s, n),
                                        x2: w,
                                        y2: Math.max(s, n)
                                    },
                                    color: r
                                })
                            }
                    }
                }
                return D && (e.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.globalCompositeOperation = "source-atop", t.axisX.maskCanvas && i.drawImage(t.axisX.maskCanvas, 0, 0, this.width, this.height), t.axisY.maskCanvas && i.drawImage(t.axisY.maskCanvas, 0, 0, this.width, this.height), this._breaksCanvasCtx && this._breaksCanvasCtx.drawImage(this._preRenderCanvas, 0, 0, this.width, this.height), i.clearRect(h.x1, h.y1, h.width, h.height), this._eventManager.ghostCtx.restore()), i.restore(), {
                    source: e,
                    dest: this.plotArea.ctx,
                    animationCallback: tt.fadeInAnimation,
                    easingFunction: tt.easing.easeInQuad,
                    animationBase: 0
                }
            }
        };
        var q = function(t, e, i, a, s, n, o, l, r) {
            if (!(0 > i)) {
                if (void 0 === l && (l = 1), !D) {
                    var h = Number((o % (2 * Math.PI)).toFixed(8));
                    Number((n % (2 * Math.PI)).toFixed(8)) === h && (o -= 1e-4)
                }
                t.save(), t.globalAlpha = l, "pie" === s ? (t.beginPath(), t.moveTo(e.x, e.y), t.arc(e.x, e.y, i, n, o, !1), t.fillStyle = a, t.strokeStyle = "white", t.lineWidth = 2, t.closePath(), t.fill()) : "doughnut" === s && (t.beginPath(), t.arc(e.x, e.y, i, n, o, !1), 0 <= r && t.arc(e.x, e.y, r * i, o, n, !0), t.closePath(), t.fillStyle = a, t.strokeStyle = "white", t.lineWidth = 2, t.fill()), t.globalAlpha = 1, t.restore()
            }
        };
        o.prototype.renderPie = function(t) {
            function e(t) {
                var e = r.plotArea.ctx;
                for (e.clearRect(u.x1, u.y1, u.width, u.height), e.fillStyle = r.backgroundColor, e.fillRect(u.x1, u.y1, u.width, u.height), e = 0; e < c.length; e++) {
                    var i = m[e].startAngle,
                        a = m[e].endAngle;
                    if (a > i) {
                        var s = .07 * P * Math.cos(m[e].midAngle),
                            n = .07 * P * Math.sin(m[e].midAngle),
                            o = !1;
                        c[e].exploded ? (1e-9 < Math.abs(m[e].center.x - (f.x + s)) || 1e-9 < Math.abs(m[e].center.y - (f.y + n))) && (m[e].center.x = f.x + s * t, m[e].center.y = f.y + n * t, o = !0) : (0 < Math.abs(m[e].center.x - f.x) || 0 < Math.abs(m[e].center.y - f.y)) && (m[e].center.x = f.x + s * (1 - t), m[e].center.y = f.y + n * (1 - t), o = !0), o && ((s = {}).dataSeries = x, s.dataPoint = x.dataPoints[e], s.index = e, r.toolTip.highlightObjects([s])), q(r.plotArea.ctx, m[e].center, m[e].radius, c[e].color ? c[e].color : x._colorSet[e % x._colorSet.length], x.type, i, a, x.fillOpacity, m[e].percentInnerRadius)
                    }
                }
                for ((t = r.plotArea.ctx).save(), t.fillStyle = "black", t.strokeStyle = "grey", t.textBaseline = "middle", t.lineJoin = "round", e = e = 0; e < c.length; e++)(i = m[e]).indexLabelText && (i.indexLabelTextBlock.y -= i.indexLabelTextBlock.height / 2, a = 0, a = "left" === i.hemisphere ? "inside" !== x.indexLabelPlacement ? -(i.indexLabelTextBlock.width + p) : -i.indexLabelTextBlock.width / 2 : "inside" !== x.indexLabelPlacement ? p : -i.indexLabelTextBlock.width / 2, i.indexLabelTextBlock.x += a, i.indexLabelTextBlock.render(!0), i.indexLabelTextBlock.x -= a, i.indexLabelTextBlock.y += i.indexLabelTextBlock.height / 2, "inside" !== i.indexLabelPlacement && 0 < i.indexLabelLineThickness && (a = i.center.x + P * Math.cos(i.midAngle), s = i.center.y + P * Math.sin(i.midAngle), t.strokeStyle = i.indexLabelLineColor, t.lineWidth = i.indexLabelLineThickness, t.setLineDash && t.setLineDash(d(i.indexLabelLineDashType, i.indexLabelLineThickness)), t.beginPath(), t.moveTo(a, s), t.lineTo(i.indexLabelTextBlock.x, i.indexLabelTextBlock.y), t.lineTo(i.indexLabelTextBlock.x + ("left" === i.hemisphere ? -p : p), i.indexLabelTextBlock.y), t.stroke()), t.lineJoin = "miter");
                t.save()
            }

            function i(t, e) {
                var i = 0,
                    a = (i = t.indexLabelTextBlock.y - t.indexLabelTextBlock.height / 2, t.indexLabelTextBlock.y + t.indexLabelTextBlock.height / 2),
                    s = e.indexLabelTextBlock.y - e.indexLabelTextBlock.height / 2,
                    n = e.indexLabelTextBlock.y + e.indexLabelTextBlock.height / 2;
                return e.indexLabelTextBlock.y > t.indexLabelTextBlock.y ? s - a : i - n
            }

            function a(t) {
                for (var e = null, a = 1; a < c.length; a++) {
                    if (e = (t + a + m.length) % m.length, m[e].hemisphere !== m[t].hemisphere) {
                        e = null;
                        break
                    }
                    if (m[e].indexLabelText && e !== t && (0 > i(m[e], m[t]) || ("right" === m[t].hemisphere ? m[e].indexLabelTextBlock.y >= m[t].indexLabelTextBlock.y : m[e].indexLabelTextBlock.y <= m[t].indexLabelTextBlock.y))) break;
                    e = null
                }
                return e
            }

            function s(t, e, n) {
                if (1e3 < (n = (n || 0) + 1)) return 0;
                e = e || 0;
                var o = 0,
                    l = f.y - 1 * h,
                    r = f.y + 1 * h;
                if (0 <= t && t < c.length) {
                    var d = m[t];
                    if (0 > e && d.indexLabelTextBlock.y < l || 0 < e && d.indexLabelTextBlock.y > r) return 0;
                    var x = 0,
                        p = 0;
                    p = x = x = 0;
                    for (0 > e ? d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 > l && d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 + e < l && (e = -(l - (d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 + e))) : d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 < l && d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 + e > r && (e = d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2 + e - r), e = d.indexLabelTextBlock.y + e, l = 0, l = "right" === d.hemisphere ? f.x + Math.sqrt(Math.pow(h, 2) - Math.pow(e - f.y, 2)) : f.x - Math.sqrt(Math.pow(h, 2) - Math.pow(e - f.y, 2)), p = f.x + P * Math.cos(d.midAngle), x = f.y + P * Math.sin(d.midAngle), x = Math.sqrt(Math.pow(l - p, 2) + Math.pow(e - x, 2)), p = Math.acos(P / h), e = (x = Math.acos((h * h + P * P - x * x) / (2 * P * h))) < p ? e - d.indexLabelTextBlock.y : 0, l = null, r = 1; r < c.length; r++) {
                        if (l = (t - r + m.length) % m.length, m[l].hemisphere !== m[t].hemisphere) {
                            l = null;
                            break
                        }
                        if (m[l].indexLabelText && m[l].hemisphere === m[t].hemisphere && l !== t && (0 > i(m[l], m[t]) || ("right" === m[t].hemisphere ? m[l].indexLabelTextBlock.y <= m[t].indexLabelTextBlock.y : m[l].indexLabelTextBlock.y >= m[t].indexLabelTextBlock.y))) break;
                        l = null
                    }
                    p = l, x = a(t), r = l = 0, 0 > e ? (o = e, null !== (r = "right" === d.hemisphere ? p : x) && (p = -e, (e = d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2 - (m[r].indexLabelTextBlock.y + m[r].indexLabelTextBlock.height / 2)) - p < g && (+(r = s(r, l = -p, n + 1)).toFixed(v) > +l.toFixed(v) && (o = e > g ? -(e - g) : -(p - (r - l)))))) : 0 < e && (o = e, null !== (r = "right" === d.hemisphere ? x : p) && (p = e, (e = m[r].indexLabelTextBlock.y - m[r].indexLabelTextBlock.height / 2 - (d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2)) - p < g && (+(r = s(r, l = p, n + 1)).toFixed(v) < +l.toFixed(v) && (o = e > g ? e - g : p - (l - r))))), o && (n = d.indexLabelTextBlock.y + o, e = 0, e = "right" === d.hemisphere ? f.x + Math.sqrt(Math.pow(h, 2) - Math.pow(n - f.y, 2)) : f.x - Math.sqrt(Math.pow(h, 2) - Math.pow(n - f.y, 2)), d.midAngle > Math.PI / 2 - y && d.midAngle < Math.PI / 2 + y ? (l = (t - 1 + m.length) % m.length, l = m[l], t = m[(t + 1 + m.length) % m.length], "left" === d.hemisphere && "right" === l.hemisphere && e > l.indexLabelTextBlock.x ? e = l.indexLabelTextBlock.x - 15 : "right" === d.hemisphere && "left" === t.hemisphere && e < t.indexLabelTextBlock.x && (e = t.indexLabelTextBlock.x + 15)) : d.midAngle > 3 * Math.PI / 2 - y && d.midAngle < 3 * Math.PI / 2 + y && (l = (t - 1 + m.length) % m.length, l = m[l], t = m[(t + 1 + m.length) % m.length], "right" === d.hemisphere && "left" === l.hemisphere && e < l.indexLabelTextBlock.x ? e = l.indexLabelTextBlock.x + 15 : "left" === d.hemisphere && "right" === t.hemisphere && e > t.indexLabelTextBlock.x && (e = t.indexLabelTextBlock.x - 15)), d.indexLabelTextBlock.y = n, d.indexLabelTextBlock.x = e, d.indexLabelAngle = Math.atan2(d.indexLabelTextBlock.y - f.y, d.indexLabelTextBlock.x - f.x))
                }
                return o
            }

            function n() {
                (d = r.plotArea.ctx).fillStyle = "grey", d.strokeStyle = "grey", d.font = "16px Arial", d.textBaseline = "middle";
                var t = d = 0,
                    e = 0,
                    n = !0;
                for (t = 0; 10 > t && (1 > t || 0 < e); t++) {
                    if ((x.radius || !x.radius && void 0 !== x.innerRadius && null !== x.innerRadius && P - e <= w) && (n = !1), n && (P -= e), e = 0, "inside" !== x.indexLabelPlacement) {
                        for (h = P * b, d = 0; d < c.length; d++) {
                            (y = m[d]).indexLabelTextBlock.x = f.x + h * Math.cos(y.midAngle), y.indexLabelTextBlock.y = f.y + h * Math.sin(y.midAngle), y.indexLabelAngle = y.midAngle, y.radius = P, y.percentInnerRadius = C
                        }
                        for (var o, l, d = 0; d < c.length; d++) {
                            var y = m[d],
                                k = a(d);
                            if (null !== k) {
                                o = m[d], l = m[k];
                                var M = 0;
                                if (0 > (M = i(o, l) - g)) {
                                    for (var T = l = 0, S = 0; S < c.length; S++) S !== d && m[S].hemisphere === y.hemisphere && (m[S].indexLabelTextBlock.y < y.indexLabelTextBlock.y ? l++ : T++);
                                    T = -1 * (M - (l = M / (l + T || 1) * T));
                                    var _ = S = 0;
                                    "right" === y.hemisphere ? (S = s(d, l), +(_ = s(k, T = -1 * (M - S))).toFixed(v) < +T.toFixed(v) && +S.toFixed(v) <= +l.toFixed(v) && s(d, -(T - _))) : (S = s(k, l), +(_ = s(d, T = -1 * (M - S))).toFixed(v) < +T.toFixed(v) && +S.toFixed(v) <= +l.toFixed(v) && s(k, -(T - _)))
                                }
                            }
                        }
                    } else
                        for (d = 0; d < c.length; d++) y = m[d], h = "pie" === x.type ? .7 * P : .8 * P, k = f.x + h * Math.cos(y.midAngle), l = f.y + h * Math.sin(y.midAngle), y.indexLabelTextBlock.x = k, y.indexLabelTextBlock.y = l;
                    for (d = 0; d < c.length; d++) 0 !== (k = (y = m[d]).indexLabelTextBlock.measureText()).height && 0 !== k.width && (k = k = 0, "right" === y.hemisphere ? (k = u.x2 - (y.indexLabelTextBlock.x + y.indexLabelTextBlock.width + p), k *= -1) : k = u.x1 - (y.indexLabelTextBlock.x - y.indexLabelTextBlock.width - p), 0 < k && (!n && y.indexLabelText && (l = "right" === y.hemisphere ? u.x2 - y.indexLabelTextBlock.x : y.indexLabelTextBlock.x - u.x1, .3 * y.indexLabelTextBlock.maxWidth > l ? y.indexLabelText = "" : y.indexLabelTextBlock.maxWidth = .85 * l, .3 * y.indexLabelTextBlock.maxWidth < l && (y.indexLabelTextBlock.x -= "right" === y.hemisphere ? 2 : -2)), Math.abs(y.indexLabelTextBlock.y - y.indexLabelTextBlock.height / 2 - f.y) < P || Math.abs(y.indexLabelTextBlock.y + y.indexLabelTextBlock.height / 2 - f.y) < P) && (9 < (k /= Math.abs(Math.cos(y.indexLabelAngle))) && (k *= .3), k > e && (e = k)), k = k = 0, 0 < y.indexLabelAngle && y.indexLabelAngle < Math.PI ? (k = u.y2 - (y.indexLabelTextBlock.y + y.indexLabelTextBlock.height / 2 + 5), k *= -1) : k = u.y1 - (y.indexLabelTextBlock.y - y.indexLabelTextBlock.height / 2 - 5), 0 < k && (!n && y.indexLabelText && (0 === s(d, k * (l = 0 < y.indexLabelAngle && y.indexLabelAngle < Math.PI ? -1 : 1)) && s(d, 2 * l)), Math.abs(y.indexLabelTextBlock.x - f.x) < P && (9 < (k /= Math.abs(Math.sin(y.indexLabelAngle))) && (k *= .3), k > e && (e = k))));
                    var B = function(t, e, i) {
                        for (var a = [], s = 0; a.push(m[e]), e !== i; e = (e + 1 + c.length) % c.length);
                        for (a.sort(function(t, e) {
                                return t.y - e.y
                            }), e = 0; e < a.length && (i = a[e], s < .7 * t); e++) s += i.indexLabelTextBlock.height, i.indexLabelTextBlock.text = "", i.indexLabelText = "", i.indexLabelTextBlock.measureText()
                    };
                    ! function() {
                        for (var t = -1, e = -1, s = 0, n = !1, l = 0; l < c.length; l++)
                            if (n = !1, (o = m[l]).indexLabelText) {
                                var r = a(l);
                                if (null !== r) {
                                    var h, d = m[r];
                                    if (M = 0, h = 0 > (M = i(o, d))) {
                                        h = o.indexLabelTextBlock.x;
                                        var x = o.indexLabelTextBlock.y - o.indexLabelTextBlock.height / 2,
                                            u = o.indexLabelTextBlock.y + o.indexLabelTextBlock.height / 2,
                                            g = d.indexLabelTextBlock.y - d.indexLabelTextBlock.height / 2,
                                            b = d.indexLabelTextBlock.x + d.indexLabelTextBlock.width,
                                            y = d.indexLabelTextBlock.y + d.indexLabelTextBlock.height / 2;
                                        h = !(o.indexLabelTextBlock.x + o.indexLabelTextBlock.width < d.indexLabelTextBlock.x - p || h > b + p || x > y + p || u < g - p)
                                    }
                                    h ? (0 > t && (t = l), r !== t && (e = r, s += -M), 0 == l % Math.max(c.length / 10, 3) && (n = !0)) : n = !0, n && 0 < s && 0 <= t && 0 <= e && (B(s, t, e), e = t = -1, s = 0)
                                }
                            }
                        0 < s && B(s, t, e)
                    }()
                }
            }

            function o() {
                if (r.plotArea.layoutManager.reset(), r.title && (r.title.dockInsidePlotArea || "center" === r.title.horizontalAlign && "center" === r.title.verticalAlign) && r.title.render(), r.subtitles)
                    for (var t = 0; t < r.subtitles.length; t++) {
                        var e = r.subtitles[t];
                        (e.dockInsidePlotArea || "center" === e.horizontalAlign && "center" === e.verticalAlign) && e.render()
                    }
                r.legend && (r.legend.dockInsidePlotArea || "center" === r.legend.horizontalAlign && "center" === r.legend.verticalAlign) && (r.legend.setLayout(), r.legend.render())
            }
            var r = this;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                var h, x = this.data[t.dataSeriesIndexes[0]],
                    c = x.dataPoints,
                    p = 10,
                    u = this.plotArea,
                    m = x.dataPointEOs,
                    g = 2,
                    b = 1.3,
                    y = 20 / 180 * Math.PI,
                    v = 6,
                    f = {
                        x: (u.x2 + u.x1) / 2,
                        y: (u.y2 + u.y1) / 2
                    },
                    k = 0;
                t = !1;
                for (var T = 0; T < c.length; T++) k += Math.abs(c[T].y), !t && void 0 !== c[T].indexLabel && null !== c[T].indexLabel && 0 < c[T].indexLabel.toString().length && (t = !0), !t && void 0 !== c[T].label && null !== c[T].label && 0 < c[T].label.toString().length && (t = !0);
                if (0 !== k) {
                    t = t || void 0 !== x.indexLabel && null !== x.indexLabel && 0 < x.indexLabel.toString().length;
                    var P = "inside" !== x.indexLabelPlacement && t ? .75 * Math.min(u.width, u.height) / 2 : .92 * Math.min(u.width, u.height) / 2;
                    x.radius && (P = F(x.radius, P));
                    var w = void 0 !== x.innerRadius && null !== x.innerRadius ? F(x.innerRadius, P) : .7 * P;
                    x.radius = P, "doughnut" === x.type && (x.innerRadius = w);
                    var C = Math.min(w / P, (P - 1) / P);
                    this.pieDoughnutClickHandler = function(t) {
                            r.isAnimating || !l(t.dataSeries.explodeOnClick) && !t.dataSeries.explodeOnClick || ((t = t.dataPoint).exploded = !t.exploded, 1 < this.dataPoints.length && r._animator.animate(0, 500, function(t) {
                                e(t), o()
                            }))
                        },
                        function() {
                            if (x && c) {
                                for (var t = 0, e = 0, i = 0, a = 0, s = 0; s < c.length; s++) {
                                    var n = c[s],
                                        o = x.dataPointIds[s];
                                    m[s].id = o, m[s].objectType = "dataPoint", m[s].dataPointIndex = s, m[s].dataSeriesIndex = 0;
                                    var h = m[s],
                                        d = {
                                            percent: null,
                                            total: null
                                        },
                                        p = null;
                                    d = r.getPercentAndTotal(x, n), (x.indexLabelFormatter || n.indexLabelFormatter) && (p = {
                                        chart: r.options,
                                        dataSeries: x,
                                        dataPoint: n,
                                        total: d.total,
                                        percent: d.percent
                                    }), d = n.indexLabelFormatter ? n.indexLabelFormatter(p) : n.indexLabel ? r.replaceKeywordsWithValue(n.indexLabel, n, x, s) : x.indexLabelFormatter ? x.indexLabelFormatter(p) : x.indexLabel ? r.replaceKeywordsWithValue(x.indexLabel, n, x, s) : n.label ? n.label : "", r._eventManager.objectMap[o] = h, h.center = {
                                        x: f.x,
                                        y: f.y
                                    }, h.y = n.y, h.radius = P, h.percentInnerRadius = C, h.indexLabelText = d, h.indexLabelPlacement = x.indexLabelPlacement, h.indexLabelLineColor = n.indexLabelLineColor ? n.indexLabelLineColor : x.options.indexLabelLineColor ? x.options.indexLabelLineColor : n.color ? n.color : x._colorSet[s % x._colorSet.length], h.indexLabelLineThickness = l(n.indexLabelLineThickness) ? x.indexLabelLineThickness : n.indexLabelLineThickness, h.indexLabelLineDashType = n.indexLabelLineDashType ? n.indexLabelLineDashType : x.indexLabelLineDashType, h.indexLabelFontColor = n.indexLabelFontColor ? n.indexLabelFontColor : x.indexLabelFontColor, h.indexLabelFontStyle = n.indexLabelFontStyle ? n.indexLabelFontStyle : x.indexLabelFontStyle, h.indexLabelFontWeight = n.indexLabelFontWeight ? n.indexLabelFontWeight : x.indexLabelFontWeight, h.indexLabelFontSize = l(n.indexLabelFontSize) ? x.indexLabelFontSize : n.indexLabelFontSize, h.indexLabelFontFamily = n.indexLabelFontFamily ? n.indexLabelFontFamily : x.indexLabelFontFamily, h.indexLabelBackgroundColor = n.indexLabelBackgroundColor ? n.indexLabelBackgroundColor : x.options.indexLabelBackgroundColor ? x.options.indexLabelBackgroundColor : x.indexLabelBackgroundColor, h.indexLabelMaxWidth = n.indexLabelMaxWidth ? n.indexLabelMaxWidth : x.indexLabelMaxWidth ? x.indexLabelMaxWidth : .33 * u.width, h.indexLabelWrap = void 0 !== n.indexLabelWrap ? n.indexLabelWrap : x.indexLabelWrap, h.startAngle = 0 === s ? x.startAngle ? x.startAngle / 180 * Math.PI : 0 : m[s - 1].endAngle, h.startAngle = (h.startAngle + 2 * Math.PI) % (2 * Math.PI), h.endAngle = h.startAngle + 2 * Math.PI / k * Math.abs(n.y), n = ((n = (h.endAngle + h.startAngle) / 2) + 2 * Math.PI) % (2 * Math.PI), h.midAngle = n, h.midAngle > Math.PI / 2 - y && h.midAngle < Math.PI / 2 + y ? ((0 === t || m[i].midAngle > h.midAngle) && (i = s), t++) : h.midAngle > 3 * Math.PI / 2 - y && h.midAngle < 3 * Math.PI / 2 + y && ((0 === e || m[a].midAngle > h.midAngle) && (a = s), e++), h.hemisphere = n > Math.PI / 2 && n <= 3 * Math.PI / 2 ? "left" : "right", h.indexLabelTextBlock = new M(r.plotArea.ctx, {
                                        fontSize: h.indexLabelFontSize,
                                        fontFamily: h.indexLabelFontFamily,
                                        fontColor: h.indexLabelFontColor,
                                        fontStyle: h.indexLabelFontStyle,
                                        fontWeight: h.indexLabelFontWeight,
                                        horizontalAlign: "left",
                                        backgroundColor: h.indexLabelBackgroundColor,
                                        maxWidth: h.indexLabelMaxWidth,
                                        maxHeight: h.indexLabelWrap ? 5 * h.indexLabelFontSize : 1.5 * h.indexLabelFontSize,
                                        text: h.indexLabelText,
                                        padding: 0,
                                        textBaseline: "top"
                                    }), h.indexLabelTextBlock.measureText()
                                }
                                for (o = n = 0, d = !1, s = 0; s < c.length; s++) h = m[(i + s) % c.length], 1 < t && h.midAngle > Math.PI / 2 - y && h.midAngle < Math.PI / 2 + y && (n <= t / 2 && !d ? (h.hemisphere = "right", n++) : (h.hemisphere = "left", d = !0));
                                for (d = !1, s = 0; s < c.length; s++) h = m[(a + s) % c.length], 1 < e && h.midAngle > 3 * Math.PI / 2 - y && h.midAngle < 3 * Math.PI / 2 + y && (o <= e / 2 && !d ? (h.hemisphere = "left", o++) : (h.hemisphere = "right", d = !0))
                            }
                        }(), n(), n(), n(), n(), this.disableToolTip = !0, this._animator.animate(0, this.animatedRender ? this.animationDuration : 0, function(t) {
                            var e = r.plotArea.ctx;
                            for (e.clearRect(u.x1, u.y1, u.width, u.height), e.fillStyle = r.backgroundColor, e.fillRect(u.x1, u.y1, u.width, u.height), t = m[0].startAngle + 2 * Math.PI * t, e = 0; e < c.length; e++) {
                                var i = 0 === e ? m[e].startAngle : a,
                                    a = i + (m[e].endAngle - m[e].startAngle),
                                    s = !1;
                                a > t && (a = t, s = !0);
                                var n = c[e].color ? c[e].color : x._colorSet[e % x._colorSet.length];
                                if (a > i && q(r.plotArea.ctx, m[e].center, m[e].radius, n, x.type, i, a, x.fillOpacity, m[e].percentInnerRadius), s) break
                            }
                            o()
                        }, function() {
                            r.disableToolTip = !1, r._animator.animate(0, r.animatedRender ? 500 : 0, function(t) {
                                e(t), o()
                            })
                        })
                }
            }
        };
        var J = function(t, e, i, a) {
            void 0 === i && (i = 1), 0 >= Math.round(e.y4 - e.y1) || (t.save(), t.globalAlpha = i, t.beginPath(), t.moveTo(Math.round(e.x1), Math.round(e.y1)), t.lineTo(Math.round(e.x2), Math.round(e.y2)), t.lineTo(Math.round(e.x3), Math.round(e.y3)), t.lineTo(Math.round(e.x4), Math.round(e.y4)), "undefined" !== e.x5 && (t.lineTo(Math.round(e.x5), Math.round(e.y5)), t.lineTo(Math.round(e.x6), Math.round(e.y6))), t.closePath(), t.fillStyle = a || e.color, t.fill(), t.globalAplha = 1, t.restore())
        };
        o.prototype.renderFunnel = function(t) {
            function e() {
                var t, e, i, a;
                if ("inside" !== m.indexLabelPlacement)
                    for (var s = 0; s < N.length; s++) 0 == K[s].textBlock.text.length ? K[s].isDirty = !0 : (i = void 0 !== (t = N[s]).x5 ? (t.y2 + t.y4) / 2 : (t.y2 + t.y3) / 2, e = m.reversed ? void 0 !== t.x5 && i > E ? x(i).x2 + 1 : (t.x2 + t.x3) / 2 + 1 : void 0 !== t.x5 ? i < E ? x(i).x2 + 1 : (t.x4 + t.x3) / 2 + 1 : (t.x2 + t.x3) / 2 + 1, K[s].textBlock.x = e + L, K[s].textBlock.y = i - K[s].height / 2, m.reversed ? (K[s].textBlock.y + K[s].height > z + y && (K[s].textBlock.y = z + y - K[s].height), K[s].textBlock.y < O - y && (K[s].textBlock.y = O - y)) : (K[s].textBlock.y < z - y && (K[s].textBlock.y = z - y), K[s].textBlock.y + K[s].height > O + y && (K[s].textBlock.y = O + y - K[s].height)));
                else
                    for (s = 0; s < N.length; s++) 0 == K[s].textBlock.text.length ? K[s].isDirty = !0 : (e = (t = N[s]).height, i = K[s].height, a = K[s].width, e >= i ? (e = s != R ? (t.x4 + t.x3) / 2 - a / 2 : (t.x5 + t.x4) / 2 - a / 2, i = s != R ? (t.y1 + t.y3) / 2 - i / 2 : (t.y1 + t.y4) / 2 - i / 2, K[s].textBlock.x = e, K[s].textBlock.y = i) : K[s].isDirty = !0)
            }

            function i(t, e) {
                return (e < N.length ? K[e].textBlock.y : m.reversed ? z + y : O + y) - (0 > t ? m.reversed ? O - y : z - y : K[t].textBlock.y + K[t].height + q)
            }

            function a(t, i, a) {
                var s, o, l, r = [],
                    h = y,
                    d = [];
                if (-1 !== i && (0 <= Q.indexOf(i) ? (o = Q.indexOf(i), Q.splice(o, 1)) : (Q.push(i), Q = Q.sort(function(t, e) {
                        return t - e
                    }))), 0 === Q.length) r = Z;
                else {
                    o = y * (1 != Q.length || 0 != Q[0] && Q[0] != N.length - 1 ? 2 : 1) / function() {
                        for (var t = 0, e = 0; e < N.length - 1; e++)(0 <= Q.indexOf(e) || 0 <= Q.indexOf(e + 1)) && t++;
                        return t
                    }();
                    for (var x = 0; x < N.length; x++) {
                        if (1 == Q.length && 0 == Q[0]) {
                            if (0 === x) {
                                r.push(Z[x]), s = h;
                                continue
                            }
                        } else 0 === x && (s = -1 * h);
                        r.push(Z[x] + s), (0 <= Q.indexOf(x) || x < N.length && 0 <= Q.indexOf(x + 1)) && (s += o)
                    }
                }
                l = function() {
                    for (var t = [], e = 0; e < N.length; e++) t.push(r[e] - N[e].y1);
                    return t
                }();
                (new Date).getTime();
                var u = function(t) {
                    for (var e, i, a = 0; a < N.length; a++) e = l[a], i = N[a], e *= t, void 0 === d[a] && (d[a] = 0), 0 > d && (d *= -1), i.y1 += e - d[a], i.y2 += e - d[a], i.y3 += e - d[a], i.y4 += e - d[a], i.y5 && (i.y5 += e - d[a], i.y6 += e - d[a]), d[a] = e
                };
                t._animator.animate(0, a, function(a) {
                    var s = t.plotArea.ctx || t.ctx;
                    G = !0, s.clearRect(b.x1, b.y1, b.x2 - b.x1, b.y2 - b.y1), s.fillStyle = t.backgroundColor, s.fillRect(b.x1, b.y1, b.width, b.height), u(a, i);
                    var o = {};
                    for (o.dataSeries = m, o.dataPoint = m.reversed ? m.dataPoints[g.length - 1 - i] : m.dataPoints[i], o.index = m.reversed ? g.length - 1 - i : i, t.toolTip.highlightObjects([o]), o = 0; o < N.length; o++) J(s, N[o], m.fillOpacity);
                    p(s), P && ("inside" !== m.indexLabelPlacement ? n(s) : e(), c(s)), 1 <= a && (G = !1)
                }, null, tt.easing.easeOutQuart)
            }

            function n(t) {
                for (var e, i, a, s, n = 0; n < N.length; n++) s = 1 == K[n].lineThickness % 2 ? .5 : 0, e = x(i = ((N[n].y2 + N[n].y4) / 2 << 0) + s).x2 - 1, a = K[n].textBlock.x, s = (K[n].textBlock.y + K[n].height / 2 << 0) + s, K[n].isDirty || 0 == K[n].lineThickness || (t.strokeStyle = K[n].lineColor, t.lineWidth = K[n].lineThickness, t.setLineDash && t.setLineDash(d(K[n].lineDashType, K[n].lineThickness)), t.beginPath(), t.moveTo(e, i), t.lineTo(a, s), t.stroke())
            }

            function o(t) {
                for (t -= 1; - 1 <= t && -1 != t && K[t].isDirty; t--);
                return t
            }

            function h(t) {
                for (t += 1; t <= N.length && t != N.length && K[t].isDirty; t++);
                return t
            }

            function x(t) {
                for (var e, i = 0; i < g.length; i++)
                    if (N[i].y1 < t && N[i].y4 > t) {
                        e = N[i];
                        break
                    }
                return e ? {
                    x1: t = e.y6 && t > e.y6 ? e.x3 + (e.x4 - e.x3) / (e.y4 - e.y3) * (t - e.y3) : e.x2 + (e.x3 - e.x2) / (e.y3 - e.y2) * (t - e.y2),
                    x2: t
                } : -1
            }

            function c(t) {
                for (var e = 0; e < N.length; e++) K[e].isDirty || (t && (K[e].textBlock.ctx = t), K[e].textBlock.render(!0))
            }

            function p(t) {
                if (u.plotArea.layoutManager.reset(), t.roundRect || s(t), u.title && (u.title.dockInsidePlotArea || "center" === u.title.horizontalAlign && "center" === u.title.verticalAlign) && (u.title.ctx = t, u.title.render()), u.subtitles)
                    for (var e = 0; e < u.subtitles.length; e++) {
                        var i = u.subtitles[e];
                        (i.dockInsidePlotArea || "center" === i.horizontalAlign && "center" === i.verticalAlign) && (u.subtitles.ctx = t, i.render())
                    }
                u.legend && (u.legend.dockInsidePlotArea || "center" === u.legend.horizontalAlign && "center" === u.legend.verticalAlign) && (u.legend.ctx = t, u.legend.setLayout(), u.legend.render()), V.fNg && V.fNg(u)
            }
            var u = this;
            if (!(0 >= t.dataSeriesIndexes.length)) {
                for (var m = this.data[t.dataSeriesIndexes[0]], g = m.dataPoints, b = this.plotArea, y = .025 * b.width, v = .01 * b.width, f = 0, k = b.height - 2 * y, T = Math.min(b.width - 2 * v, 2.8 * b.height), P = !1, w = 0; w < g.length; w++) !P && void 0 !== g[w].indexLabel && null !== g[w].indexLabel && 0 < g[w].indexLabel.toString().length && (P = !0), !P && void 0 !== g[w].label && null !== g[w].label && 0 < g[w].label.toString().length && (P = !0), (!P && "function" == typeof m.indexLabelFormatter || "function" == typeof g[w].indexLabelFormatter) && (P = !0);
                P = P || void 0 !== m.indexLabel && null !== m.indexLabel && 0 < m.indexLabel.toString().length, "inside" !== m.indexLabelPlacement && P || (v = (b.width - .75 * T) / 2);
                w = b.x1 + v;
                var C = b.x2 - v,
                    S = b.y1 + y,
                    _ = b.y2 - y,
                    B = t.targetCanvasCtx || this.plotArea.ctx || this.ctx;
                if (0 != m.length && m.dataPoints && m.visible && 0 !== g.length) {
                    var F, A, L = 30 * (C - (t = 75 * T / 100)) / 100;
                    "funnel" === m.type ? (F = l(m.options.neckHeight) ? .35 * k : m.neckHeight, A = l(m.options.neckWidth) ? .25 * t : m.neckWidth, "string" == typeof F && F.match(/%$/) ? F = (F = parseInt(F)) * k / 100 : F = parseInt(F), "string" == typeof A && A.match(/%$/) ? A = (A = parseInt(A)) * t / 100 : A = parseInt(A), F > k ? F = k : 0 >= F && (F = 0), A > t ? A = t - .5 : 0 >= A && (A = 0)) : "pyramid" === m.type && (A = F = 0, m.reversed = !m.reversed);
                    v = w + t / 2;
                    var I = w,
                        W = w + t,
                        z = m.reversed ? _ : S,
                        X = v - A / 2,
                        Y = v + A / 2,
                        E = m.reversed ? S + F : _ - F,
                        O = m.reversed ? S : _;
                    t = [];
                    v = [];
                    var R, N = [],
                        H = (T = [], S),
                        j = (E - z) / (X - I),
                        U = -j;
                    if (-1 !== (w = "area" === (m.valueRepresents ? m.valueRepresents : "height") ? function() {
                            var t, e, i = I,
                                a = W,
                                s = X,
                                n = Y;
                            t = S, e = _ - F, n = Math.abs((e - t) * (a - i + (n - s)) / 2), t = e - t, e = (s = Y - X) * (e - _), e = n + (e = Math.abs(e)), n = [];
                            for (var o = 0, l = 0; l < g.length; l++) {
                                if (void 0 === g[l].y) return -1;
                                g[l].y = "number" == typeof g[l].y ? g[l].y : 0, o += Math.abs(g[l].y)
                            }
                            if (0 === o) return -1;
                            var r, h, d = n[0] = 0,
                                x = 0;
                            for (a -= i, d = !1, l = 0; l < g.length; l++) i = Math.abs(g[l].y) * e / o, d ? r = 0 == Number(s.toFixed(3)) ? 0 : i / s : 0 > (h = j * j * a * a - 4 * Math.abs(j) * i) ? (i -= d = (a + (h = s)) * (t - x) / 2, r = t - x, x += t - x, r += 0 == h ? 0 : i / h, x += i / h, d = !0) : (h = a - 2 * (r = (Math.abs(j) * a - Math.sqrt(h)) / 2) / Math.abs(j), (x += r) > t && (d = (a + (h = s)) * (t - (x -= r)) / 2, r = t - x, x += t - x, r += (i -= d) / h, x += i / h, d = !0), a = h), n.push(r);
                            return n
                        }() : function() {
                            for (var t = 0, e = [], i = 0; i < g.length; i++) {
                                if (void 0 === g[i].y) return -1;
                                g[i].y = "number" == typeof g[i].y ? g[i].y : 0, t += Math.abs(g[i].y)
                            }
                            if (0 === t) return -1;
                            for (i = e[0] = 0; i < g.length; i++) e.push(Math.abs(g[i].y) * k / t);
                            return e
                        }())) {
                        if (m.reversed)
                            for (T.push(H), A = w.length - 1; 0 < A; A--) H += w[A], T.push(H);
                        else
                            for (A = 0; A < w.length; A++) H += w[A], T.push(H);
                        if (m.reversed)
                            for (A = 0; A < w.length; A++) T[A] < E ? (t.push(X), v.push(Y), R = A) : (t.push((T[A] - z + j * I) / j), v.push((T[A] - z + U * W) / U));
                        else
                            for (A = 0; A < w.length; A++) T[A] < E ? (t.push((T[A] - z + j * I) / j), v.push((T[A] - z + U * W) / U), R = A) : (t.push(X), v.push(Y));
                        for (A = 0; A < w.length - 1; A++) H = m.reversed ? g[g.length - 1 - A].color ? g[g.length - 1 - A].color : m._colorSet[(g.length - 1 - A) % m._colorSet.length] : g[A].color ? g[A].color : m._colorSet[A % m._colorSet.length], A === R ? N.push({
                            x1: t[A],
                            y1: T[A],
                            x2: v[A],
                            y2: T[A],
                            x3: Y,
                            y3: E,
                            x4: v[A + 1],
                            y4: T[A + 1],
                            x5: t[A + 1],
                            y5: T[A + 1],
                            x6: X,
                            y6: E,
                            id: A,
                            height: T[A + 1] - T[A],
                            color: H
                        }) : N.push({
                            x1: t[A],
                            y1: T[A],
                            x2: v[A],
                            y2: T[A],
                            x3: v[A + 1],
                            y3: T[A + 1],
                            x4: t[A + 1],
                            y4: T[A + 1],
                            id: A,
                            height: T[A + 1] - T[A],
                            color: H
                        });
                        var q = 2,
                            K = [],
                            G = !1,
                            Q = [],
                            Z = [];
                        w = !1;
                        for (t = t = 0, r(Q), A = 0; A < g.length; A++) g[A].exploded && (w = !0, m.reversed ? Q.push(g.length - 1 - A) : Q.push(A));
                        if (B.clearRect(b.x1, b.y1, b.width, b.height), B.fillStyle = u.backgroundColor, B.fillRect(b.x1, b.y1, b.width, b.height), P && m.visible && (function() {
                                if (m && g) {
                                    for (var t, e, i, a, n, o, r, h, d, c, p, b, y, v, f = [], k = [], T = {
                                            percent: null,
                                            total: null
                                        }, P = null, w = 0; w < g.length; w++) v = x(v = void 0 !== (v = N[w]).x5 ? (v.y2 + v.y4) / 2 : (v.y2 + v.y3) / 2).x2 + 1, f[w] = C - v - L;
                                    v = .5 * L, w = 0;
                                    for (var S = g.length - 1; w < g.length || 0 <= S; w++, S--) t = (e = m.reversed ? g[S] : g[w]).color ? e.color : m.reversed ? m._colorSet[(g.length - 1 - w) % m._colorSet.length] : m._colorSet[w % m._colorSet.length], i = e.indexLabelPlacement || m.indexLabelPlacement || "outside", a = e.indexLabelBackgroundColor || m.indexLabelBackgroundColor || (D ? "transparent" : null), n = e.indexLabelFontColor || m.indexLabelFontColor || "#979797", o = l(e.indexLabelFontSize) ? m.indexLabelFontSize : e.indexLabelFontSize, r = e.indexLabelFontStyle || m.indexLabelFontStyle || "normal", h = e.indexLabelFontFamily || m.indexLabelFontFamily || "arial", d = e.indexLabelFontWeight || m.indexLabelFontWeight || "normal", t = e.indexLabelLineColor || m.options.indexLabelLineColor || t, c = "number" == typeof e.indexLabelLineThickness ? e.indexLabelLineThickness : "number" == typeof m.indexLabelLineThickness ? m.indexLabelLineThickness : 2, p = e.indexLabelLineDashType || m.indexLabelLineDashType || "solid", b = void 0 !== e.indexLabelWrap ? e.indexLabelWrap : void 0 === m.indexLabelWrap || m.indexLabelWrap, y = m.dataPointIds[w], u._eventManager.objectMap[y] = {
                                        id: y,
                                        objectType: "dataPoint",
                                        dataPointIndex: w,
                                        dataSeriesIndex: 0,
                                        funnelSection: N[m.reversed ? g.length - 1 - w : w]
                                    }, "inside" === m.indexLabelPlacement && (f[w] = w !== R ? m.reversed ? N[w].x2 - N[w].x1 : N[w].x3 - N[w].x4 : N[w].x3 - N[w].x6, 20 > f[w] && (f[w] = w !== R && m.reversed ? N[w].x3 - N[w].x4 : N[w].x2 - N[w].x1, f[w] /= 2)), ((y = e.indexLabelMaxWidth ? e.indexLabelMaxWidth : m.options.indexLabelMaxWidth ? m.indexLabelMaxWidth : f[w]) > f[w] || 0 > y) && (y = f[w]), k[w] = "inside" === m.indexLabelPlacement && N[w].height, T = u.getPercentAndTotal(m, e), (m.indexLabelFormatter || e.indexLabelFormatter) && (P = {
                                        chart: u.options,
                                        dataSeries: m,
                                        dataPoint: e,
                                        total: T.total,
                                        percent: T.percent
                                    }), e = e.indexLabelFormatter ? e.indexLabelFormatter(P) : e.indexLabel ? u.replaceKeywordsWithValue(e.indexLabel, e, m, w) : m.indexLabelFormatter ? m.indexLabelFormatter(P) : m.indexLabel ? u.replaceKeywordsWithValue(m.indexLabel, e, m, w) : e.label ? e.label : "", 0 >= c && (c = 0), 1e3 > y && 1e3 - y < v && (y += 1e3 - y), B.roundRect || s(B), (i = new M(B, {
                                        fontSize: o,
                                        fontFamily: h,
                                        fontColor: n,
                                        fontStyle: r,
                                        fontWeight: d,
                                        horizontalAlign: i,
                                        backgroundColor: a,
                                        maxWidth: y,
                                        maxHeight: !1 === k[w] ? b ? 4.28571429 * o : 1.5 * o : k[w],
                                        text: e,
                                        padding: q
                                    })).measureText(), K.push({
                                        textBlock: i,
                                        id: m.reversed ? S : w,
                                        isDirty: !1,
                                        lineColor: t,
                                        lineThickness: c,
                                        lineDashType: p,
                                        height: i.height < i.maxHeight ? i.height : i.maxHeight,
                                        width: i.width < i.maxWidth ? i.width : i.maxWidth
                                    })
                                }
                            }(), e(), function() {
                                var t, e, i, a, s, n = [];
                                s = !1, i = 0;
                                for (var o, l = C - W - L / 2, r = (l = m.options.indexLabelMaxWidth ? m.indexLabelMaxWidth > l ? l : m.indexLabelMaxWidth : l, K.length - 1); 0 <= r; r--) o = g[K[r].id], a = (i = K[r]).textBlock, e = (t = h(r) < N.length ? K[h(r)] : null) ? t.textBlock : null, i = i.height, t && a.y + i + q > e.y && (s = !0), ((i = o.indexLabelMaxWidth || l) > l || 0 > i) && (i = l), n.push(i);
                                if (s)
                                    for (r = K.length - 1; 0 <= r; r--) t = N[r], K[r].textBlock.maxWidth = n[n.length - (r + 1)], K[r].textBlock.measureText(), K[r].textBlock.x = C - l, i = K[r].textBlock.height < K[r].textBlock.maxHeight ? K[r].textBlock.height : K[r].textBlock.maxHeight, s = K[r].textBlock.width < K[r].textBlock.maxWidth ? K[r].textBlock.width : K[r].textBlock.maxWidth, K[r].height = i, K[r].width = s, i = void 0 !== t.x5 ? (t.y2 + t.y4) / 2 : (t.y2 + t.y3) / 2, K[r].textBlock.y = i - K[r].height / 2, m.reversed ? (K[r].textBlock.y + K[r].height > z + y && (K[r].textBlock.y = z + y - K[r].height), K[r].textBlock.y < O - y && (K[r].textBlock.y = O - y)) : (K[r].textBlock.y < z - y && (K[r].textBlock.y = z - y), K[r].textBlock.y + K[r].height > O + y && (K[r].textBlock.y = O + y - K[r].height))
                            }(), "inside" !== m.indexLabelPlacement)) {
                            for (function() {
                                    function t(e, a) {
                                        var s;
                                        if (0 > e || e >= K.length) return 0;
                                        var n, l = K[e].textBlock;
                                        return 0 > a ? (a *= -1, (s = i(n = o(e), e)) >= a ? (l.y -= a, a) : 0 == e ? (0 < s && (l.y -= s), s) : (0 < (s += t(n, -(a - s))) && (l.y -= s), s)) : (s = i(e, n = h(e))) >= a ? (l.y += a, a) : e == N.length - 1 ? (0 < s && (l.y += s), s) : (0 < (s += t(n, a - s)) && (l.y += s), s)
                                    }

                                    function e() {
                                        var t, e, i, s, n, l = 0;
                                        s = (_ - S + 2 * y) / c, n = c;
                                        for (var r, d = 1; d < n; d++) {
                                            i = d * s;
                                            for (var x = K.length - 1; 0 <= x; x--) !K[x].isDirty && K[x].textBlock.y < i && K[x].textBlock.y + K[x].height > i && !((r = h(x)) >= K.length - 1) && K[x].textBlock.y + K[x].height + q > K[r].textBlock.y && (K[x].textBlock.y = K[x].textBlock.y + K[x].height - i > i - K[x].textBlock.y ? i + 1 : i - K[x].height - 1)
                                        }
                                        for (r = N.length - 1; 0 < r; r--)
                                            if (!K[r].isDirty) {
                                                if (0 > (i = o(r)) && K[i = 0].isDirty) break;
                                                if (K[r].textBlock.y < K[i].textBlock.y + K[i].height) {
                                                    for (e = e || r, s = r, n = 0; K[s].textBlock.y < K[i].textBlock.y + K[i].height + q;) {
                                                        if (t = t || K[s].textBlock.y + K[s].height, n += K[s].height, n += q, 0 >= (s = i)) {
                                                            n += K[s = 0].height;
                                                            break
                                                        }
                                                        if (0 > (i = o(s))) {
                                                            n += K[s = 0].height;
                                                            break
                                                        }
                                                    }
                                                    if (s != r) {
                                                        l = a(t = n - (t -= l = K[s].textBlock.y), e, s);
                                                        break
                                                    }
                                                }
                                            }
                                        return l
                                    }

                                    function a(t, e, i) {
                                        var a = [],
                                            s = 0,
                                            n = 0;
                                        for (t = Math.abs(t); i <= e; i++) a.push(N[i]);
                                        for (a.sort(function(t, e) {
                                                return t.height - e.height
                                            }), i = 0; i < a.length && (e = a[i], s < t); i++) n++, s += K[e.id].height + q, K[e.id].textBlock.text = "", K[e.id].indexLabelText = "", K[e.id].isDirty = !0, K[e.id].textBlock.measureText();
                                        return n
                                    }
                                    for (var s, n, l, r, d, x, c = 1, p = 0; p < 2 * c; p++) {
                                        for (var u = K.length - 1; 0 <= u && (0 <= o(u) && o(u), r = (l = K[u]).textBlock, x = (d = h(u) < N.length ? K[h(u)] : null) ? d.textBlock : null, s = +l.height.toFixed(6), n = +r.y.toFixed(6), !(!l.isDirty && d && n + s + q > +x.y.toFixed(6) && (s = r.y + s + q - x.y, n = t(u, -s), n < s && (0 < n && (s -= n), n = t(h(u), s), n != s)))); u--);
                                        e()
                                    }
                                }(), A = 0; A < g.length; A++) K[A].isDirty || (t = K[A].textBlock.x + K[A].width, t = (C - t) / 2, 0 == A && (f = t), f > t && (f = t));
                            for (A = 0; A < N.length; A++) N[A].x1 += f, N[A].x2 += f, N[A].x3 += f, N[A].x4 += f, N[A].x5 && (N[A].x5 += f, N[A].x6 += f), K[A].textBlock.x += f
                        }
                        for (A = 0; A < N.length; A++) f = N[A], J(B, f, m.fillOpacity), Z.push(f.y1);
                        if (p(B), P && m.visible && ("inside" === m.indexLabelPlacement || u.animationEnabled || n(B), u.animationEnabled || c()), !P)
                            for (A = 0; A < g.length; A++) t = {
                                id: f = m.dataPointIds[A],
                                objectType: "dataPoint",
                                dataPointIndex: A,
                                dataSeriesIndex: 0,
                                funnelSection: N[m.reversed ? g.length - 1 - A : A]
                            }, u._eventManager.objectMap[f] = t;
                        return !u.animationEnabled && w ? a(u, -1, 0) : u.animationEnabled && !u.animatedRender && a(u, -1, 0), this.funnelPyramidClickHandler = function(t) {
                            var e = -1;
                            !G && !u.isAnimating && (l(t.dataSeries.explodeOnClick) || t.dataSeries.explodeOnClick) && 0 <= (e = m.reversed ? g.length - 1 - t.dataPointIndex : t.dataPointIndex) && (t = e, "funnel" !== m.type && "pyramid" !== m.type || (m.reversed ? g[g.length - 1 - t].exploded = !g[g.length - 1 - t].exploded : g[t].exploded = !g[t].exploded), a(u, e, 500))
                        }, {
                            source: B,
                            dest: this.plotArea.ctx,
                            animationCallback: function(t, e) {
                                tt.fadeInAnimation(t, e), 1 <= t && (a(u, -1, 500), p(u.plotArea.ctx || u.ctx))
                            },
                            easingFunction: tt.easing.easeInQuad,
                            animationBase: 0
                        }
                    }
                }
            }
        }, o.prototype.requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) {
            window.setTimeout(t, 1e3 / 60)
        }, o.prototype.cancelRequestAnimFrame = window.cancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || clearTimeout, o.prototype.set = function(t, e, i) {
            i = void 0 === i || i, "options" === t ? (this.options = e, i && this.render()) : o.base.set.call(this, t, e, i)
        }, o.prototype.exportChart = function(t) {
            var e = (t = void 0 === t ? {} : t).format ? t.format : "png";
            t.fileName ? t.fileName : this.exportFileName;
            if (t.toDataURL) return this.canvas.toDataURL("image/" + e);
            this.canvas
        }, o.prototype.print = function() {
            var t = this.exportChart({
                    toDataURL: !0
                }),
                e = document.createElement("iframe");
            e.setAttribute("class", "canvasjs-chart-print-frame"), e.setAttribute("style", "position:absolute; width:100%; border: 0px; margin: 0px 0px 0px 0px; padding 0px 0px 0px 0px;"), e.style.height = this.height + "px", this._canvasJSContainer.appendChild(e);
            var i = this,
                a = e.contentWindow || e.contentDocument.document || e.contentDocument;
            a.document.open(), a.document.write('<!DOCTYPE HTML>\n<html><body style="margin: 0px 0px 0px 0px; padding: 0px 0px 0px 0px;"><img src="' + t + '"/><body/></html>'), a.document.close(), setTimeout(function() {
                a.focus(), a.print(), setTimeout(function() {
                    i._canvasJSContainer.removeChild(e)
                }, 1e3)
            }, 500)
        }, o.prototype.getPercentAndTotal = function(t, e) {
            var i = null,
                a = null,
                s = null;
            if (0 <= t.type.indexOf("stacked")) a = 0, (i = e.x.getTime ? e.x.getTime() : e.x) in t.plotUnit.yTotals && (a = t.plotUnit.yTotals[i], s = isNaN(e.y) ? 0 : e.y / a * 100);
            else if ("pie" === t.type || "doughnut" === t.type || "funnel" === t.type || "pyramid" === t.type) {
                for (i = a = 0; i < t.dataPoints.length; i++) isNaN(t.dataPoints[i].y) || (a += t.dataPoints[i].y);
                s = isNaN(e.y) ? 0 : e.y / a * 100
            }
            return {
                percent: s,
                total: a
            }
        }, o.prototype.replaceKeywordsWithValue = function(t, e, i, s, n) {
            var o = this;
            if (n = void 0 === n ? 0 : n, (0 <= i.type.indexOf("stacked") || "pie" === i.type || "doughnut" === i.type || "funnel" === i.type || "pyramid" === i.type) && (0 <= t.indexOf("#percent") || 0 <= t.indexOf("#total"))) {
                var l = "#percent",
                    r = "#total",
                    h = this.getPercentAndTotal(i, e);
                r = isNaN(h.total) ? r : h.total, l = isNaN(h.percent) ? l : h.percent;
                do {
                    if (h = "", i.percentFormatString) h = i.percentFormatString;
                    else {
                        h = "#,##0.";
                        var d = Math.max(Math.ceil(Math.log(1 / Math.abs(l)) / Math.LN10), 2);
                        !isNaN(d) && isFinite(d) || (d = 2);
                        for (var x = 0; x < d; x++) h += "#";
                        i.percentFormatString = h
                    }
                    t = (t = t.replace("#percent", Z(l, h, o._cultureInfo))).replace("#total", Z(r, i.yValueFormatString ? i.yValueFormatString : "#,##0.########", o._cultureInfo))
                } while (0 <= t.indexOf("#percent") || 0 <= t.indexOf("#total"))
            }
            return t.replace(/\{.*?\}|"[^"]*"|'[^']*'/g, function(t) {
                if ('"' === t[0] && '"' === t[t.length - 1] || "'" === t[0] && "'" === t[t.length - 1]) return t.slice(1, t.length - 1);
                t = (t = a(t.slice(1, t.length - 1))).replace("#index", n);
                var l = null;
                try {
                    var r = t.match(/(.*?)\s*\[\s*(.*?)\s*\]/);
                    r && 0 < r.length && (l = a(r[2]), t = a(r[1]))
                } catch (t) {}
                if (r = null, "color" === t) return "waterfall" === i.type ? e.color ? e.color : 0 < e.y ? i.risingColor : i.fallingColor : "error" === i.type ? i.color ? i.color : i._colorSet[l % i._colorSet.length] : e.color ? e.color : i.color ? i.color : i._colorSet[s % i._colorSet.length];
                if (e.hasOwnProperty(t)) r = e;
                else {
                    if (!i.hasOwnProperty(t)) return "";
                    r = i
                }
                return r = r[t], null !== l && (r = r[l]), "x" !== t ? "y" === t ? Z(r, e.yValueFormatString ? e.yValueFormatString : i.yValueFormatString ? i.yValueFormatString : i.yValueFormatString = "#,##0.########", o._cultureInfo) : "z" === t ? Z(r, e.zValueFormatString ? e.zValueFormatString : i.zValueFormatString ? i.zValueFormatString : i.zValueFormatString = "#,##0.########", o._cultureInfo) : r : "dateTime" === i.axisX.valueType || "dateTime" === i.xValueType || e.x && e.x.getTime ? o.plotInfo.plotTypes[0].plotUnits[0].axisX && !o.plotInfo.plotTypes[0].plotUnits[0].axisX.logarithmic ? Q(r, e.xValueFormatString ? e.xValueFormatString : i.xValueFormatString ? i.xValueFormatString : i.xValueFormatString = o.axisX && o.axisX.autoValueFormatString ? o.axisX.autoValueFormatString : "DD MMM YY", o._cultureInfo) : void 0 : Z(r, e.xValueFormatString ? e.xValueFormatString : i.xValueFormatString ? i.xValueFormatString : i.xValueFormatString = "#,##0.########", o._cultureInfo)
            })
        }, t(A, f), A.prototype.setLayout = function() {
            var t = this.dockInsidePlotArea ? this.chart.plotArea : this.chart,
                e = t.layoutManager.getFreeSpace(),
                i = null,
                a = 0,
                s = 0,
                n = 0,
                o = 0,
                r = this.markerMargin = this.chart.options.legend && !l(this.chart.options.legend.markerMargin) ? this.chart.options.legend.markerMargin : .3 * this.fontSize;
            this.height = 0;
            var h = [],
                d = [];
            "top" === this.verticalAlign || "bottom" === this.verticalAlign ? (this.orientation = "horizontal", i = this.verticalAlign, n = this.maxWidth = null !== this.maxWidth ? this.maxWidth : e.width, o = this.maxHeight = null !== this.maxHeight ? this.maxHeight : .5 * e.height) : "center" === this.verticalAlign && (this.orientation = "vertical", i = this.horizontalAlign, n = this.maxWidth = null !== this.maxWidth ? this.maxWidth : .5 * e.width, o = this.maxHeight = null !== this.maxHeight ? this.maxHeight : e.height), this.errorMarkerColor = [];
            for (var x = 0; x < this.dataSeries.length; x++) {
                var c = this.dataSeries[x];
                if (c.dataPoints && c.dataPoints.length)
                    if ("pie" !== c.type && "doughnut" !== c.type && "funnel" !== c.type && "pyramid" !== c.type) {
                        var p = c.legendMarkerType = c.legendMarkerType ? c.legendMarkerType : "line" !== c.type && "stepLine" !== c.type && "spline" !== c.type && "scatter" !== c.type && "bubble" !== c.type || !c.markerType ? "error" === c.type && c._linkedSeries ? c._linkedSeries.legendMarkerType ? c._linkedSeries.legendMarkerType : L.getDefaultLegendMarker(c._linkedSeries.type) : L.getDefaultLegendMarker(c.type) : c.markerType,
                            u = c.legendText ? c.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                                chart: this.chart,
                                legend: this.options,
                                dataSeries: c,
                                dataPoint: null
                            }) : c.name,
                            m = c.legendMarkerColor = c.legendMarkerColor ? c.legendMarkerColor : c.markerColor ? c.markerColor : "error" === c.type ? l(c.whiskerColor) ? c._colorSet[0] : c.whiskerColor : c._colorSet[0],
                            g = c.markerSize || "line" !== c.type && "stepLine" !== c.type && "spline" !== c.type ? .75 * this.lineHeight : 0,
                            b = c.legendMarkerBorderColor ? c.legendMarkerBorderColor : c.markerBorderColor,
                            y = c.legendMarkerBorderThickness ? c.legendMarkerBorderThickness : c.markerBorderThickness ? Math.max(1, Math.round(.2 * g)) : 0;
                        "error" === c.type && this.errorMarkerColor.push(m), p = {
                            markerType: p,
                            markerColor: m,
                            text: u = this.chart.replaceKeywordsWithValue(u, c.dataPoints[0], c, x),
                            textBlock: null,
                            chartType: c.type,
                            markerSize: g,
                            lineColor: c._colorSet[0],
                            dataSeriesIndex: c.index,
                            dataPointIndex: null,
                            markerBorderColor: b,
                            markerBorderThickness: y
                        }, h.push(p)
                    } else
                        for (var v = 0; v < c.dataPoints.length; v++) {
                            var f = c.dataPoints[v];
                            p = f.legendMarkerType ? f.legendMarkerType : c.legendMarkerType ? c.legendMarkerType : L.getDefaultLegendMarker(c.type), u = f.legendText ? f.legendText : c.legendText ? c.legendText : this.itemTextFormatter ? this.itemTextFormatter({
                                chart: this.chart,
                                legend: this.options,
                                dataSeries: c,
                                dataPoint: f
                            }) : f.name ? f.name : "DataPoint: " + (v + 1), m = f.legendMarkerColor ? f.legendMarkerColor : c.legendMarkerColor ? c.legendMarkerColor : f.color ? f.color : c.color ? c.color : c._colorSet[v % c._colorSet.length], g = .75 * this.lineHeight, b = f.legendMarkerBorderColor ? f.legendMarkerBorderColor : c.legendMarkerBorderColor ? c.legendMarkerBorderColor : f.markerBorderColor ? f.markerBorderColor : c.markerBorderColor, y = f.legendMarkerBorderThickness ? f.legendMarkerBorderThickness : c.legendMarkerBorderThickness ? c.legendMarkerBorderThickness : f.markerBorderThickness || c.markerBorderThickness ? Math.max(1, Math.round(.2 * g)) : 0, p = {
                                markerType: p,
                                markerColor: m,
                                text: u = this.chart.replaceKeywordsWithValue(u, f, c, v),
                                textBlock: null,
                                chartType: c.type,
                                markerSize: g,
                                dataSeriesIndex: x,
                                dataPointIndex: v,
                                markerBorderColor: b,
                                markerBorderThickness: y
                            };
                            (f.showInLegend || c.showInLegend && !1 !== f.showInLegend) && h.push(p)
                        }
            }
            if (!0 === this.reversed && h.reverse(), 0 < h.length) {
                for (c = null, m = u = f = v = 0, f = null !== this.itemWidth ? null !== this.itemMaxWidth ? Math.min(this.itemWidth, this.itemMaxWidth, n) : this.itemMaxWidth = Math.min(this.itemWidth, n) : null !== this.itemMaxWidth ? Math.min(this.itemMaxWidth, n) : this.itemMaxWidth = n, f -= (g = 0 === g ? .75 * this.lineHeight : g) + r, x = 0; x < h.length; x++) b = f, "line" !== (p = h[x]).chartType && "spline" !== p.chartType && "stepLine" !== p.chartType || (b -= .2 * this.lineHeight), 0 >= o || void 0 === o || 0 >= b || void 0 === b || ("horizontal" === this.orientation ? (p.textBlock = new M(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: b,
                    maxHeight: this.itemWrap ? o : this.lineHeight,
                    angle: 0,
                    text: p.text,
                    horizontalAlign: "left",
                    fontSize: this.fontSize,
                    fontFamily: this.fontFamily,
                    fontWeight: this.fontWeight,
                    fontColor: this.fontColor,
                    fontStyle: this.fontStyle,
                    textBaseline: "middle"
                }), p.textBlock.measureText(), null !== this.itemWidth && (p.textBlock.width = this.itemWidth - (g + r + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? .2 * this.lineHeight : 0))), (!c || c.width + Math.round(p.textBlock.width + g + r + (0 === c.width ? 0 : this.horizontalSpacing) + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? .2 * this.lineHeight : 0)) > n) && (c = {
                    items: [],
                    width: 0
                }, d.push(c), this.height += u, u = 0), u = Math.max(u, p.textBlock.height)) : (p.textBlock = new M(this.ctx, {
                    x: 0,
                    y: 0,
                    maxWidth: f,
                    maxHeight: !0 === this.itemWrap ? o : 1.5 * this.fontSize,
                    angle: 0,
                    text: p.text,
                    horizontalAlign: "left",
                    fontSize: this.fontSize,
                    fontFamily: this.fontFamily,
                    fontWeight: this.fontWeight,
                    fontColor: this.fontColor,
                    fontStyle: this.fontStyle,
                    textBaseline: "middle"
                }), p.textBlock.measureText(), null !== this.itemWidth && (p.textBlock.width = this.itemWidth - (g + r + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? .2 * this.lineHeight : 0))), this.height < o - this.lineHeight ? (c = {
                    items: [],
                    width: 0
                }, d.push(c)) : (c = d[v], v = (v + 1) % d.length), this.height += p.textBlock.height), p.textBlock.x = c.width, p.textBlock.y = 0, c.width += Math.round(p.textBlock.width + g + r + (0 === c.width ? 0 : this.horizontalSpacing) + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? .2 * this.lineHeight : 0)), c.items.push(p), this.width = Math.max(c.width, this.width), m = p.textBlock.width + (g + r + ("line" === p.chartType || "spline" === p.chartType || "stepLine" === p.chartType ? .2 * this.lineHeight : 0)));
                this.itemWidth = m, this.height = !1 === this.itemWrap ? d.length * this.lineHeight : this.height + u, this.height = Math.min(o, this.height), this.width = Math.min(n, this.width)
            }
            for ("top" === this.verticalAlign ? (s = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, a = e.y1) : "center" === this.verticalAlign ? (s = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, a = e.y1 + e.height / 2 - this.height / 2) : "bottom" === this.verticalAlign && (s = "left" === this.horizontalAlign ? e.x1 : "right" === this.horizontalAlign ? e.x2 - this.width : e.x1 + e.width / 2 - this.width / 2, a = e.y2 - this.height), this.items = h, x = 0; x < this.items.length; x++)(p = h[x]).id = ++this.chart._eventManager.lastObjectId, this.chart._eventManager.objectMap[p.id] = {
                id: p.id,
                objectType: "legendItem",
                legendItemIndex: x,
                dataSeriesIndex: p.dataSeriesIndex,
                dataPointIndex: p.dataPointIndex
            };
            this.markerSize = g, this.rows = d, 0 < h.length && t.layoutManager.registerSpace(i, {
                width: this.width + 2 + 2,
                height: this.height + 5 + 5
            }), this.bounds = {
                x1: s,
                y1: a,
                x2: s + this.width,
                y2: a + this.height
            }
        }, A.prototype.render = function() {
            var t = this.bounds.x1,
                e = this.bounds.y1,
                i = this.markerMargin,
                a = this.maxWidth,
                s = this.maxHeight,
                n = this.markerSize,
                o = this.rows;
            (0 < this.borderThickness && this.borderColor || this.backgroundColor) && this.ctx.roundRect(t, e, this.width, this.height, this.cornerRadius, this.borderThickness, this.backgroundColor, this.borderColor);
            for (var l = 0, r = 0; r < o.length; r++) {
                for (var h = o[r], d = 0, x = 0; x < h.items.length; x++) {
                    var c = h.items[x],
                        p = c.textBlock.x + t + (0 === x ? .2 * n : this.horizontalSpacing),
                        u = e + l,
                        m = p;
                    if (this.chart.data[c.dataSeriesIndex].visible || (this.ctx.globalAlpha = .5), this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(t, e, a, Math.max(s - s % this.lineHeight, 0)), this.ctx.clip(), "line" !== c.chartType && "stepLine" !== c.chartType && "spline" !== c.chartType || (this.ctx.strokeStyle = c.lineColor, this.ctx.lineWidth = Math.ceil(this.lineHeight / 8), this.ctx.beginPath(), this.ctx.moveTo(p - .1 * this.lineHeight, u + this.lineHeight / 2), this.ctx.lineTo(p + .85 * this.lineHeight, u + this.lineHeight / 2), this.ctx.stroke(), m -= .1 * this.lineHeight), "error" === c.chartType) {
                        this.ctx.strokeStyle = this.errorMarkerColor[0], this.ctx.lineWidth = n / 8, this.ctx.beginPath();
                        var g = p - .08 * this.lineHeight + .1 * this.lineHeight,
                            b = u + .15 * this.lineHeight,
                            y = .7 * this.lineHeight,
                            v = y + .02 * this.lineHeight;
                        this.ctx.moveTo(g, b), this.ctx.lineTo(g + y, b), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(g + y / 2, b), this.ctx.lineTo(g + y / 2, b + v), this.ctx.stroke(), this.ctx.beginPath(), this.ctx.moveTo(g, b + v), this.ctx.lineTo(g + y, b + v), this.ctx.stroke(), this.errorMarkerColor.shift()
                    }
                    et.drawMarker(p + n / 2, u + this.lineHeight / 2, this.ctx, c.markerType, "error" === c.chartType || "line" === c.chartType || "spline" === c.chartType ? c.markerSize / 2 : c.markerSize, c.markerColor, c.markerBorderColor, c.markerBorderThickness), c.textBlock.x = p + i + n, "line" !== c.chartType && "stepLine" !== c.chartType && "spline" !== c.chartType || (c.textBlock.x += .1 * this.lineHeight), c.textBlock.y = Math.round(u + this.lineHeight / 2), c.textBlock.render(!0), this.ctx.restore(), d = 0 < x ? Math.max(d, c.textBlock.height) : c.textBlock.height, this.chart.data[c.dataSeriesIndex].visible || (this.ctx.globalAlpha = 1), p = void c.id, this.ghostCtx.fillStyle = p, this.ghostCtx.beginPath(), this.ghostCtx.fillRect(m, c.textBlock.y - this.lineHeight / 2, c.textBlock.x + c.textBlock.width - m, c.textBlock.height), c.x1 = this.chart._eventManager.objectMap[c.id].x1 = m, c.y1 = this.chart._eventManager.objectMap[c.id].y1 = c.textBlock.y - this.lineHeight / 2, c.x2 = this.chart._eventManager.objectMap[c.id].x2 = c.textBlock.x + c.textBlock.width, c.y2 = this.chart._eventManager.objectMap[c.id].y2 = c.textBlock.y + c.textBlock.height - this.lineHeight / 2
                }
                l += d
            }
        }, t(L, f), L.prototype.getDefaultAxisPlacement = function() {
            var t = this.type;
            return "column" === t || "line" === t || "stepLine" === t || "spline" === t || "area" === t || "stepArea" === t || "splineArea" === t || "stackedColumn" === t || "stackedLine" === t || "bubble" === t || "scatter" === t || "stackedArea" === t || "stackedColumn100" === t || "stackedLine100" === t || "stackedArea100" === t || "candlestick" === t || "ohlc" === t || "rangeColumn" === t || "rangeArea" === t || "rangeSplineArea" === t || "boxAndWhisker" === t || "waterfall" === t ? "normal" : "bar" === t || "stackedBar" === t || "stackedBar100" === t || "rangeBar" === t ? "xySwapped" : "pie" === t || "doughnut" === t || "funnel" === t || "pyramid" === t ? "none" : ("error" !== t && window.console.log("Unknown Chart Type: " + t), null)
        }, L.getDefaultLegendMarker = function(t) {
            return "column" === t || "stackedColumn" === t || "stackedLine" === t || "bar" === t || "stackedBar" === t || "stackedBar100" === t || "bubble" === t || "scatter" === t || "stackedColumn100" === t || "stackedLine100" === t || "stepArea" === t || "candlestick" === t || "ohlc" === t || "rangeColumn" === t || "rangeBar" === t || "rangeArea" === t || "rangeSplineArea" === t || "boxAndWhisker" === t || "waterfall" === t ? "square" : "line" === t || "stepLine" === t || "spline" === t || "pie" === t || "doughnut" === t ? "circle" : "area" === t || "splineArea" === t || "stackedArea" === t || "stackedArea100" === t || "funnel" === t || "pyramid" === t ? "triangle" : "error" === t ? "none" : (window.console.log("Unknown Chart Type: " + t), null)
        }, L.prototype.getDataPointAtX = function(t, e) {
            if (!this.dataPoints || 0 === this.dataPoints.length) return null;
            var i = {
                    dataPoint: null,
                    distance: 1 / 0,
                    index: NaN
                },
                a = null,
                s = 0,
                n = 0,
                o = 1,
                l = 1 / 0,
                r = 0,
                h = 0,
                d = 0;
            for ("none" !== this.chart.plotInfo.axisPlacement && (this.axisX.logarithmic ? d = 1 < (d = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x)) ? Math.min(Math.max((this.dataPoints.length - 1) / d * Math.log(t / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0 : d = 0 < (d = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) ? Math.min(Math.max((this.dataPoints.length - 1) / d * (t - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0);;) {
                if (0 <= (n = 0 < o ? d + s : d - s) && n < this.dataPoints.length) {
                    a = this.dataPoints[n];
                    var x = this.axisX.logarithmic ? a.x > t ? a.x / t : t / a.x : Math.abs(a.x - t);
                    if (x < i.distance && (i.dataPoint = a, i.distance = x, i.index = n), (a = x) <= l ? l = a : 0 < o ? r++ : h++, 1e3 < r && 1e3 < h) break
                } else if (0 > d - s && d + s >= this.dataPoints.length) break; - 1 === o ? (s++, o = 1) : o = -1
            }
            return e || i.dataPoint.x !== t ? e && null !== i.dataPoint ? i : null : i
        }, L.prototype.getDataPointAtXY = function(t, e, i) {
            if (!this.dataPoints || 0 === this.dataPoints.length || t < this.chart.plotArea.x1 || t > this.chart.plotArea.x2 || e < this.chart.plotArea.y1 || e > this.chart.plotArea.y2) return null;
            i = i || !1;
            var a = [],
                s = 0,
                n = 0,
                o = 1,
                l = !1,
                r = 1 / 0,
                h = 0,
                d = 0,
                x = 0;
            if ("none" !== this.chart.plotInfo.axisPlacement)
                if (x = (this.chart.axisX[0] ? this.chart.axisX[0] : this.chart.axisX2[0]).getXValueAt({
                        x: t,
                        y: e
                    }), this.axisX.logarithmic) x = 1 < (c = Math.log(this.dataPoints[this.dataPoints.length - 1].x / this.dataPoints[0].x)) ? Math.min(Math.max((this.dataPoints.length - 1) / c * Math.log(x / this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
                else x = 0 < (c = this.dataPoints[this.dataPoints.length - 1].x - this.dataPoints[0].x) ? Math.min(Math.max((this.dataPoints.length - 1) / c * (x - this.dataPoints[0].x) >> 0, 0), this.dataPoints.length) : 0;
            for (;;) {
                if (0 <= (n = 0 < o ? x + s : x - s) && n < this.dataPoints.length) {
                    var c = this.chart._eventManager.objectMap[this.dataPointIds[n]],
                        u = this.dataPoints[n],
                        m = null;
                    if (c) {
                        switch (this.type) {
                            case "column":
                            case "stackedColumn":
                            case "stackedColumn100":
                            case "bar":
                            case "stackedBar":
                            case "stackedBar100":
                            case "rangeColumn":
                            case "rangeBar":
                            case "waterfall":
                            case "error":
                                t >= c.x1 && t <= c.x2 && e >= c.y1 && e <= c.y2 && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(c.x1 - t), Math.abs(c.x2 - t), Math.abs(c.y1 - e), Math.abs(c.y2 - e))
                                }), l = !0);
                                break;
                            case "line":
                            case "stepLine":
                            case "spline":
                            case "area":
                            case "stepArea":
                            case "stackedArea":
                            case "stackedArea100":
                            case "splineArea":
                            case "scatter":
                                var g = p("markerSize", u, this) || 4,
                                    b = i ? 20 : g;
                                (m = Math.sqrt(Math.pow(c.x1 - t, 2) + Math.pow(c.y1 - e, 2))) <= b && a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: m
                                }), (c = Math.abs(c.x1 - t)) <= r ? r = c : 0 < o ? h++ : d++, m <= g / 2 && (l = !0);
                                break;
                            case "rangeArea":
                            case "rangeSplineArea":
                                g = p("markerSize", u, this) || 4, b = i ? 20 : g, (m = Math.min(Math.sqrt(Math.pow(c.x1 - t, 2) + Math.pow(c.y1 - e, 2)), Math.sqrt(Math.pow(c.x1 - t, 2) + Math.pow(c.y2 - e, 2)))) <= b && a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: m
                                }), (c = Math.abs(c.x1 - t)) <= r ? r = c : 0 < o ? h++ : d++, m <= g / 2 && (l = !0);
                                break;
                            case "bubble":
                                g = c.size, (m = Math.sqrt(Math.pow(c.x1 - t, 2) + Math.pow(c.y1 - e, 2))) <= g / 2 && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: m
                                }), l = !0);
                                break;
                            case "pie":
                            case "doughnut":
                                g = c.center, b = "doughnut" === this.type ? c.percentInnerRadius * c.radius : 0, (m = Math.sqrt(Math.pow(g.x - t, 2) + Math.pow(g.y - e, 2))) < c.radius && m > b && (0 > (m = Math.atan2(e - g.y, t - g.x)) && (m += 2 * Math.PI), m = Number(((m / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), g = Number(((c.startAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12)), 0 === (b = Number(((c.endAngle / Math.PI * 180 % 360 + 360) % 360).toFixed(12))) && 1 < c.endAngle && (b = 360), g >= b && 0 !== u.y && (b += 360, m < g && (m += 360)), m > g && m < b && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: 0
                                }), l = !0));
                                break;
                            case "funnel":
                            case "pyramid":
                                e > (m = c.funnelSection).y1 && e < m.y4 && (m.y6 ? e > m.y6 ? (n = m.x6 + (m.x5 - m.x6) / (m.y5 - m.y6) * (e - m.y6), m = m.x3 + (m.x4 - m.x3) / (m.y4 - m.y3) * (e - m.y3)) : (n = m.x1 + (m.x6 - m.x1) / (m.y6 - m.y1) * (e - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (e - m.y2)) : (n = m.x1 + (m.x4 - m.x1) / (m.y4 - m.y1) * (e - m.y1), m = m.x2 + (m.x3 - m.x2) / (m.y3 - m.y2) * (e - m.y2)), t > n && t < m && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: c.dataPointIndex,
                                    dataSeries: this,
                                    distance: 0
                                }), l = !0));
                                break;
                            case "boxAndWhisker":
                                (t >= c.x1 - c.borderThickness / 2 && t <= c.x2 + c.borderThickness / 2 && e >= c.y4 - c.borderThickness / 2 && e <= c.y1 + c.borderThickness / 2 || Math.abs(c.x2 - t + c.x1 - t) < c.borderThickness && e >= c.y1 && e <= c.y4) && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(c.x1 - t), Math.abs(c.x2 - t), Math.abs(c.y2 - e), Math.abs(c.y3 - e))
                                }), l = !0);
                                break;
                            case "candlestick":
                                (t >= c.x1 - c.borderThickness / 2 && t <= c.x2 + c.borderThickness / 2 && e >= c.y2 - c.borderThickness / 2 && e <= c.y3 + c.borderThickness / 2 || Math.abs(c.x2 - t + c.x1 - t) < c.borderThickness && e >= c.y1 && e <= c.y4) && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(c.x1 - t), Math.abs(c.x2 - t), Math.abs(c.y2 - e), Math.abs(c.y3 - e))
                                }), l = !0);
                                break;
                            case "ohlc":
                                (Math.abs(c.x2 - t + c.x1 - t) < c.borderThickness && e >= c.y2 && e <= c.y3 || t >= c.x1 && t <= (c.x2 + c.x1) / 2 && e >= c.y1 - c.borderThickness / 2 && e <= c.y1 + c.borderThickness / 2 || t >= (c.x1 + c.x2) / 2 && t <= c.x2 && e >= c.y4 - c.borderThickness / 2 && e <= c.y4 + c.borderThickness / 2) && (a.push({
                                    dataPoint: u,
                                    dataPointIndex: n,
                                    dataSeries: this,
                                    distance: Math.min(Math.abs(c.x1 - t), Math.abs(c.x2 - t), Math.abs(c.y2 - e), Math.abs(c.y3 - e))
                                }), l = !0)
                        }
                        if (l || 1e3 < h && 1e3 < d) break
                    }
                } else if (0 > x - s && x + s >= this.dataPoints.length) break; - 1 === o ? (s++, o = 1) : o = -1
            }
            for (t = null, e = 0; e < a.length; e++) t ? a[e].distance <= t.distance && (t = a[e]) : t = a[e];
            return t
        }, L.prototype.getMarkerProperties = function(t, e, i, a) {
            var s = this.dataPoints;
            return {
                x: e,
                y: i,
                ctx: a,
                type: s[t].markerType ? s[t].markerType : this.markerType,
                size: s[t].markerSize ? s[t].markerSize : this.markerSize,
                color: s[t].markerColor ? s[t].markerColor : this.markerColor ? this.markerColor : s[t].color ? s[t].color : this.color ? this.color : this._colorSet[t % this._colorSet.length],
                borderColor: s[t].markerBorderColor ? s[t].markerBorderColor : this.markerBorderColor ? this.markerBorderColor : null,
                borderThickness: s[t].markerBorderThickness ? s[t].markerBorderThickness : this.markerBorderThickness ? this.markerBorderThickness : null
            }
        }, t(W, f), W.prototype.createExtraLabelsForLog = function(t) {
            if (!(5 < (t = (t || 0) + 1))) {
                var e = this.logLabelValues[0] || this.intervalStartPosition;
                if (Math.log(this.range) / Math.log(e / this.viewportMinimum) < this.noTicks - 1) {
                    for (var i = W.getNiceNumber((e - this.viewportMinimum) / Math.min(Math.max(2, this.noTicks - this.logLabelValues.length), 3), !0), a = Math.ceil(this.viewportMinimum / i) * i; a < e; a += i) a < this.viewportMinimum || this.logLabelValues.push(a);
                    this.logLabelValues.sort(n), this.createExtraLabelsForLog(t)
                }
            }
        }, W.prototype.createLabels = function() {
            var t, i, a, s, n, o = 0,
                r = 0,
                h = 0,
                d = 0,
                x = (r = 0, r = this.interval, 0),
                c = .6 * this.chart.height;
            t = !1;
            var p = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [],
                u = p.length ? l(this.scaleBreaks.firstBreakIndex) ? 0 : this.scaleBreaks.firstBreakIndex : 0;
            if ("axisX" !== this.type || "dateTime" !== this.valueType || this.logarithmic) {
                if (a = this.viewportMaximum, this.labels) {
                    t = Math.ceil(r);
                    var m = !1;
                    for (o = r = Math.ceil(this.intervalStartPosition); o < this.viewportMaximum; o += t) {
                        if (!this.labels[o]) {
                            m = !1;
                            break
                        }
                        m = !0
                    }
                    m && (this.interval = t, this.intervalStartPosition = r)
                }
                if (this.logarithmic && !this.equidistantInterval)
                    for (this.logLabelValues || (this.logLabelValues = [], this.createExtraLabelsForLog()), r = 0, m = u; r < this.logLabelValues.length; r++)
                        if ((o = this.logLabelValues[r]) < this.viewportMinimum) r++;
                        else {
                            for (; m < p.length && o > p[m].endValue; m++);
                            n = o, (t = m < p.length && o >= p[m].startValue && o <= p[m].endValue) || (t = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.options,
                                value: n,
                                label: this.labels[n] ? this.labels[n] : null
                            }) : "axisX" === this.type && this.labels[n] ? this.labels[n] : Z(n, this.valueFormatString, this.chart._cultureInfo), t = new M(this.ctx, {
                                x: 0,
                                y: 0,
                                maxWidth: h,
                                maxHeight: d,
                                angle: this.labelAngle,
                                text: this.prefix + t + this.suffix,
                                backgroundColor: this.labelBackgroundColor,
                                borderColor: this.labelBorderColor,
                                borderThickness: this.labelBorderThickness,
                                cornerRadius: this.labelCornerRadius,
                                horizontalAlign: "left",
                                fontSize: this.labelFontSize,
                                fontFamily: this.labelFontFamily,
                                fontWeight: this.labelFontWeight,
                                fontColor: this.labelFontColor,
                                fontStyle: this.labelFontStyle,
                                textBaseline: "middle",
                                borderThickness: 0
                            }), this._labels.push({
                                position: n,
                                textBlock: t,
                                effectiveHeight: null
                            }))
                        }
                for (m = u, o = this.intervalStartPosition; o <= a; o = parseFloat(1e-12 > this.interval ? this.logarithmic && this.equidistantInterval ? o * Math.pow(this.logarithmBase, this.interval) : o + this.interval : (this.logarithmic && this.equidistantInterval ? o * Math.pow(this.logarithmBase, this.interval) : o + this.interval).toFixed(12))) {
                    for (; m < p.length && o > p[m].endValue; m++);
                    n = o, (t = m < p.length && o >= p[m].startValue && o <= p[m].endValue) || (t = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.options,
                        value: n,
                        label: this.labels[n] ? this.labels[n] : null
                    }) : "axisX" === this.type && this.labels[n] ? this.labels[n] : Z(n, this.valueFormatString, this.chart._cultureInfo), t = new M(this.ctx, {
                        x: 0,
                        y: 0,
                        maxWidth: h,
                        maxHeight: d,
                        angle: this.labelAngle,
                        text: this.prefix + t + this.suffix,
                        horizontalAlign: "left",
                        backgroundColor: this.labelBackgroundColor,
                        borderColor: this.labelBorderColor,
                        borderThickness: this.labelBorderThickness,
                        cornerRadius: this.labelCornerRadius,
                        fontSize: this.labelFontSize,
                        fontFamily: this.labelFontFamily,
                        fontWeight: this.labelFontWeight,
                        fontColor: this.labelFontColor,
                        fontStyle: this.labelFontStyle,
                        textBaseline: "middle"
                    }), this._labels.push({
                        position: n,
                        textBlock: t,
                        effectiveHeight: null
                    }))
                }
            } else
                for (this.intervalStartPosition = this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval), a = e(new Date(this.viewportMaximum), this.interval, this.intervalType), m = u, o = this.intervalStartPosition; o < a; e(o, r, this.intervalType)) {
                    for (t = o.getTime(); m < p.length && t > p[m].endValue; m++);
                    n = t, (t = m < p.length && t >= p[m].startValue && t <= p[m].endValue) || (t = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.options,
                        value: new Date(n),
                        label: this.labels[n] ? this.labels[n] : null
                    }) : "axisX" === this.type && this.labels[n] ? this.labels[n] : Q(n, this.valueFormatString, this.chart._cultureInfo), t = new M(this.ctx, {
                        x: 0,
                        y: 0,
                        maxWidth: h,
                        backgroundColor: this.labelBackgroundColor,
                        borderColor: this.labelBorderColor,
                        borderThickness: this.labelBorderThickness,
                        cornerRadius: this.labelCornerRadius,
                        maxHeight: d,
                        angle: this.labelAngle,
                        text: this.prefix + t + this.suffix,
                        horizontalAlign: "left",
                        fontSize: this.labelFontSize,
                        fontFamily: this.labelFontFamily,
                        fontWeight: this.labelFontWeight,
                        fontColor: this.labelFontColor,
                        fontStyle: this.labelFontStyle,
                        textBaseline: "middle"
                    }), this._labels.push({
                        position: n,
                        textBlock: t,
                        effectiveHeight: null,
                        breaksLabelType: void 0
                    }))
                }
            for ("bottom" === this._position || "top" === this._position ? (x = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.width * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.width / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, h = void 0 === this.options.labelMaxWidth ? .5 * this.chart.width >> 0 : this.options.labelMaxWidth, this.chart.panEnabled || (d = void 0 === this.options.labelWrap || this.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize)) : "left" !== this._position && "right" !== this._position || (x = this.logarithmic && !this.equidistantInterval && 2 <= this._labels.length ? this.lineCoordinates.height * Math.log(Math.min(this._labels[this._labels.length - 1].position / this._labels[this._labels.length - 2].position, this._labels[1].position / this._labels[0].position)) / Math.log(this.range) : this.lineCoordinates.height / (this.logarithmic && this.equidistantInterval ? Math.log(this.range) / Math.log(this.logarithmBase) : Math.abs(this.range)) * U[this.intervalType + "Duration"] * this.interval, this.chart.panEnabled || (h = void 0 === this.options.labelMaxWidth ? .3 * this.chart.width >> 0 : this.options.labelMaxWidth), d = void 0 === this.options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize), r = 0; r < this._labels.length; r++) {
                (t = this._labels[r].textBlock).maxWidth = h, t.maxHeight = d;
                var g = t.measureText();
                s = g.height
            }
            if (a = [], u = p = 0, this.labelAutoFit || this.options.labelAutoFit)
                if (l(this.labelAngle) || (this.labelAngle = (this.labelAngle % 360 + 360) % 360, 90 < this.labelAngle && 270 > this.labelAngle ? this.labelAngle -= 180 : 270 <= this.labelAngle && 360 >= this.labelAngle && (this.labelAngle -= 360)), "bottom" === this._position || "top" === this._position)
                    if (h = .9 * x >> 0, u = 0, !this.chart.panEnabled && 1 <= this._labels.length) {
                        for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, o = 0; o < this._labels.length; o++)
                            if (!this._labels[o].breaksLabelType) {
                                var b;
                                for (m = (t = this._labels[o].textBlock).text.split(" "), r = 0; r < m.length; r++) n = m[r], this.ctx.font = t.fontStyle + " " + t.fontWeight + " " + t.fontSize + "px " + t.fontFamily, (n = this.ctx.measureText(n)).width > u && (b = o, u = n.width)
                            }
                        for (o = 0, o = this.intervalStartPosition < this.viewportMinimum ? 1 : 0; o < this._labels.length; o++)
                            if (!this._labels[o].breaksLabelType) {
                                for (g = (t = this._labels[o].textBlock).measureText(), m = o + 1; m < this._labels.length; m++)
                                    if (!this._labels[m].breaksLabelType) {
                                        i = (i = this._labels[m].textBlock).measureText();
                                        break
                                    }
                                if (a.push(t.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, a), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), r = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d - t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), l(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle)
                                    if (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : Math.min((r - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), r), n = (c - (s + t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(-25))) / Math.sin(Math.PI / 180 * Math.abs(-25)), l(this.options.labelWrap)) {
                                        if (l(this.options.labelWrap))
                                            if (l(this.options.labelMaxWidth)) {
                                                if (!l(i))
                                                    if (r = g.width + i.width >> 0, m = this.labelFontSize, u < h) r - 2 * h > p && (p = r - 2 * h, r >= 2 * h && r < 2.2 * h ? (this.sessionVariables.labelMaxWidth = h, l(this.options.labelFontSize) && 12 < m && (m = Math.floor(12 / 13 * m), t.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? m : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : r >= 2.2 * h && r < 2.8 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n, this.sessionVariables.labelFontSize = m) : r >= 2.8 * h && r < 3.2 * h ? (this.sessionVariables.labelMaxWidth = Math.max(h, u), this.sessionVariables.labelWrap = !0, l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? m : this.options.labelFontSize, this.sessionVariables.labelAngle = this.labelAngle) : r >= 3.2 * h && r < 3.6 * h ? (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = n, this.sessionVariables.labelFontSize = this.labelFontSize) : r > 3.6 * h && r < 5 * h ? (l(this.options.labelFontSize) && 12 < m && (m = Math.floor(12 / 13 * m), t.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? m : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n) : r > 5 * h && (this.sessionVariables.labelWrap = !0, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelFontSize = m, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = this.labelAngle));
                                                    else if (b === o && (0 === b && u + this._labels[b + 1].textBlock.measureText().width - 2 * h > p || b === this._labels.length - 1 && u + this._labels[b - 1].textBlock.measureText().width - 2 * h > p || 0 < b && b < this._labels.length - 1 && u + this._labels[b + 1].textBlock.measureText().width - 2 * h > p && u + this._labels[b - 1].textBlock.measureText().width - 2 * h > p)) p = 0 === b ? u + this._labels[b + 1].textBlock.measureText().width - 2 * h : u + this._labels[b - 1].textBlock.measureText().width - 2 * h, this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? m : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n;
                                                else if (0 === p)
                                                    for (this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? m : this.options.labelFontSize, this.sessionVariables.labelWrap = !0, r = 0; r < this._labels.length; r++)(t = this._labels[r].textBlock).maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, u), n), g = t.measureText(), r < this._labels.length - 1 && (m = r + 1, (i = this._labels[m].textBlock).maxWidth = this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, u), n), i = i.measureText(), g.width + i.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25))
                                            } else this.options.labelMaxWidth < h ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = r) : (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d)
                                    } else this.labelWrap ? l(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = Math.min(Math.max(h, u), n), this.sessionVariables.labelWrap = this.labelWrap, g.width + i.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25)) : (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle) : l(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = h, g.width + i.width >> 0 > 2 * h && (this.sessionVariables.labelAngle = -25, this.sessionVariables.labelMaxWidth = n)) : (this.sessionVariables.labelAngle = this.sessionVariables.labelMaxWidth > h ? -25 : this.sessionVariables.labelAngle, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelWrap = this.labelWrap);
                                else this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : Math.min((r - h * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), r), n = 0 != this.labelAngle ? (c - (s + t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) : h, this.sessionVariables.labelMaxHeight = d = this.labelWrap ? (c - n * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) : 1.5 * this.labelFontSize, l(this.options.labelWrap) ? l(this.options.labelWrap) && (this.labelWrap && !l(this.options.labelMaxWidth) ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : n, this.sessionVariables.labelMaxHeight = d) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = n, this.sessionVariables.labelMaxHeight = r < .9 * x ? .9 * x : r, this.sessionVariables.labelWrap = this.labelWrap)) : (this.options.labelWrap ? (this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : n) : (l(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : n, this.sessionVariables.labelWrap = this.labelWrap), this.sessionVariables.labelMaxHeight = d)
                            }
                        for (r = 0; r < this._labels.length; r++)(t = this._labels[r].textBlock).maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, t.fontSize = this.sessionVariables.labelFontSize, t.angle = this.labelAngle = this.sessionVariables.labelAngle, t.wrap = this.labelWrap = this.sessionVariables.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText()
                    } else
                        for (o = 0; o < this._labels.length; o++)(t = this._labels[o].textBlock).maxWidth = this.labelMaxWidth = l(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, t.fontSize = this.labelFontSize = l(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, t.angle = this.labelAngle = l(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, t.wrap = this.labelWrap = l(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText();
            else if ("left" === this._position || "right" === this._position)
                if (h = l(this.options.labelMaxWidth) ? .3 * this.chart.width >> 0 : this.options.labelMaxWidth, d = void 0 === this.options.labelWrap || this.labelWrap ? .3 * this.chart.height >> 0 : 1.5 * this.labelFontSize, !this.chart.panEnabled && 1 <= this._labels.length) {
                    for (this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle, this.sessionVariables.labelWrap = this.labelWrap, o = 0; o < this._labels.length; o++)
                        if (!this._labels[o].breaksLabelType) {
                            for (g = (t = this._labels[o].textBlock).measureText(), m = o + 1; m < this._labels.length; m++)
                                if (!this._labels[m].breaksLabelType) {
                                    i = (i = this._labels[m].textBlock).measureText();
                                    break
                                }
                            a.push(t.height), this.sessionVariables.labelMaxHeight = Math.max.apply(Math, a), r = h * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (d - t.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)), l(this.options.labelAngle) && isNaN(this.options.labelAngle) && 0 !== this.options.labelAngle ? l(this.options.labelWrap) ? l(this.options.labelWrap) && (l(this.options.labelMaxWidth) ? l(i) || (x = g.height + i.height >> 0) - 2 * d > u && (u = x - 2 * d, x >= 2 * d && x < 2.4 * d ? (l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize) : x >= 2.4 * d && x < 2.8 * d ? (this.sessionVariables.labelMaxHeight = r, this.sessionVariables.labelFontSize = this.labelFontSize, this.sessionVariables.labelWrap = !0) : x >= 2.8 * d && x < 3.2 * d ? (this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelWrap = !0, l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : x >= 3.2 * d && x < 3.6 * d ? (this.sessionVariables.labelMaxHeight = r, this.sessionVariables.labelWrap = !0, this.sessionVariables.labelFontSize = this.labelFontSize) : x > 3.6 * d && x < 10 * d ? (l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle) : x > 10 * d && x < 50 * d && (l(this.options.labelFontSize) && 12 < this.labelFontSize && (this.labelFontSize = Math.floor(12 / 13 * this.labelFontSize), t.measureText()), this.sessionVariables.labelFontSize = l(this.options.labelFontSize) ? this.labelFontSize : this.options.labelFontSize, this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = h, this.sessionVariables.labelAngle = l(this.sessionVariables.labelAngle) ? 0 : this.sessionVariables.labelAngle)) : (this.sessionVariables.labelMaxHeight = d, this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth)) : (this.sessionVariables.labelMaxWidth = this.labelWrap ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : this.labelMaxWidth ? this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = d) : (this.sessionVariables.labelAngle = this.labelAngle, this.sessionVariables.labelMaxWidth = 0 === this.labelAngle ? h : Math.min((r - d * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) / Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)), d), l(this.options.labelWrap) ? l(this.options.labelWrap) && (this.labelWrap && !l(this.options.labelMaxWidth) ? (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth > this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxHeight = r) : (this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : h, this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : r, l(this.options.labelMaxWidth) && (this.sessionVariables.labelAngle = this.labelAngle))) : this.options.labelWrap ? (this.sessionVariables.labelMaxHeight = 0 === this.labelAngle ? d : r, this.sessionVariables.labelWrap = this.labelWrap, this.sessionVariables.labelMaxWidth = h) : (this.sessionVariables.labelMaxHeight = d, l(this.options.labelMaxWidth), this.sessionVariables.labelMaxWidth = this.options.labelMaxWidth ? this.options.labelMaxWidth : this.sessionVariables.labelMaxWidth, this.sessionVariables.labelWrap = this.labelWrap))
                        }
                    for (r = 0; r < this._labels.length; r++)(t = this._labels[r].textBlock).maxWidth = this.labelMaxWidth = this.sessionVariables.labelMaxWidth, t.fontSize = this.labelFontSize = this.sessionVariables.labelFontSize, t.angle = this.labelAngle = this.sessionVariables.labelAngle, t.wrap = this.labelWrap = this.sessionVariables.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText()
                } else
                    for (o = 0; o < this._labels.length; o++)(t = this._labels[o].textBlock).maxWidth = this.labelMaxWidth = l(this.options.labelMaxWidth) ? this.sessionVariables.labelMaxWidth : this.options.labelMaxWidth, t.fontSize = this.labelFontSize = l(this.options.labelFontSize) ? this.sessionVariables.labelFontSize : this.options.labelFontSize, t.angle = this.labelAngle = l(this.options.labelAngle) ? this.sessionVariables.labelAngle : this.labelAngle, t.wrap = this.labelWrap = l(this.options.labelWrap) ? this.sessionVariables.labelWrap : this.options.labelWrap, t.maxHeight = this.sessionVariables.labelMaxHeight, t.measureText();
            for (o = 0; o < this.stripLines.length; o++) {
                var y;
                "outside" === (h = this.stripLines[o]).labelPlacement ? (d = this.sessionVariables.labelMaxWidth, "bottom" !== this._position && "top" !== this._position || (y = l(h.options.labelWrap) ? this.sessionVariables.labelMaxHeight : h.labelWrap ? .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize), "left" !== this._position && "right" !== this._position || (y = l(h.options.labelWrap) ? this.sessionVariables.labelMaxHeight : h.labelWrap ? .8 * this.chart.width >> 0 : 1.5 * this.labelFontSize), l(h.labelBackgroundColor) && (h.labelBackgroundColor = "#EEEEEE")) : (d = "bottom" === this._position || "top" === this._position ? .9 * this.chart.width >> 0 : .9 * this.chart.height >> 0, y = l(h.options.labelWrap) || h.labelWrap ? "bottom" === this._position || "top" === this._position ? .8 * this.chart.width >> 0 : .8 * this.chart.height >> 0 : 1.5 * this.labelFontSize, l(h.labelBackgroundColor) && (l(h.startValue) && 0 !== h.startValue ? h.labelBackgroundColor = D ? "transparent" : null : h.labelBackgroundColor = "#EEEEEE")), t = new M(this.ctx, {
                    x: 0,
                    y: 0,
                    backgroundColor: h.labelBackgroundColor,
                    borderColor: h.labelBorderColor,
                    borderThickness: h.labelBorderThickness,
                    cornerRadius: h.labelCornerRadius,
                    maxWidth: h.options.labelMaxWidth ? h.options.labelMaxWidth : d,
                    maxHeight: y,
                    angle: this.labelAngle,
                    text: h.labelFormatter ? h.labelFormatter({
                        chart: this.chart,
                        axis: this,
                        stripLine: h
                    }) : h.label,
                    horizontalAlign: "left",
                    fontSize: "outside" === h.labelPlacement ? h.options.labelFontSize ? h.labelFontSize : this.labelFontSize : h.labelFontSize,
                    fontFamily: "outside" === h.labelPlacement ? h.options.labelFontFamily ? h.labelFontFamily : this.labelFontFamily : h.labelFontFamily,
                    fontWeight: "outside" === h.labelPlacement ? h.options.labelFontWeight ? h.labelFontWeight : this.labelFontWeight : h.labelFontWeight,
                    fontColor: h.labelFontColor || h.color,
                    fontStyle: "outside" === h.labelPlacement ? h.options.labelFontStyle ? h.labelFontStyle : this.fontWeight : h.labelFontStyle,
                    textBaseline: "middle"
                }), this._stripLineLabels.push({
                    position: h.value,
                    textBlock: t,
                    effectiveHeight: null,
                    stripLine: h
                })
            }
        }, W.prototype.createLabelsAndCalculateWidth = function() {
            var t = 0,
                e = 0;
            this._labels = [], this._stripLineLabels = [];
            var i = this.chart.isNavigator ? 0 : 5;
            if ("left" === this._position || "right" === this._position) {
                for (this.createLabels(), e = 0; e < this._labels.length; e++) {
                    var a = this._labels[e].textBlock,
                        s = a.measureText(),
                        n = 0;
                    t < (n = 0 === this.labelAngle ? s.width : s.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (s.height - a.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = n), this._labels[e].effectiveWidth = n
                }
                for (e = 0; e < this._stripLineLabels.length; e++) "outside" === this._stripLineLabels[e].stripLine.labelPlacement && this._stripLineLabels[e].stripLine.value >= this.viewportMinimum && this._stripLineLabels[e].stripLine.value <= this.viewportMaximum && (s = (a = this._stripLineLabels[e].textBlock).measureText(), t < (n = 0 === this.labelAngle ? s.width : s.width * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle)) + (s.height - a.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = n), this._stripLineLabels[e].effectiveWidth = n)
            }
            return e = this.title ? this._titleTextBlock.measureText().height + 2 : 0, "inside" === this.labelPlacement ? a = e + i : e + t + this.tickLength + i
        }, W.prototype.createLabelsAndCalculateHeight = function() {
            var t = 0;
            this._labels = [], this._stripLineLabels = [];
            var e, i = 0,
                a = this.chart.isNavigator ? 0 : 5;
            if (this.createLabels(), "bottom" === this._position || "top" === this._position) {
                for (i = 0; i < this._labels.length; i++) {
                    var s = (e = this._labels[i].textBlock).measureText(),
                        n = 0;
                    t < (n = 0 === this.labelAngle ? s.height : s.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (s.height - e.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = n), this._labels[i].effectiveHeight = n
                }
                for (i = 0; i < this._stripLineLabels.length; i++) "outside" === this._stripLineLabels[i].stripLine.labelPlacement && this._stripLineLabels[i].stripLine.value >= this.viewportMinimum && this._stripLineLabels[i].stripLine.value <= this.viewportMaximum && (s = (e = this._stripLineLabels[i].textBlock).measureText(), t < (n = 0 === this.labelAngle ? s.height : s.width * Math.sin(Math.PI / 180 * Math.abs(this.labelAngle)) + (s.height - e.fontSize / 2) * Math.cos(Math.PI / 180 * Math.abs(this.labelAngle))) && (t = n), this._stripLineLabels[i].effectiveHeight = n)
            }
            return e = this.title ? this._titleTextBlock.measureText().height + 2 : 0, "inside" === this.labelPlacement ? i = e + a : e + t + this.tickLength + a
        }, W.setLayout = function(t, e, i, a, s, n) {
            var o, r, h, d, x = t[0] ? t[0].chart : e[0].chart,
                c = x.isNavigator ? 0 : 10,
                p = x._axes;
            if (t && 0 < t.length)
                for (var u = 0; u < t.length; u++) t[u] && t[u].calculateAxisParameters();
            if (e && 0 < e.length)
                for (u = 0; u < e.length; u++) e[u].calculateAxisParameters();
            if (i && 0 < i.length)
                for (u = 0; u < i.length; u++) i[u].calculateAxisParameters();
            if (a && 0 < a.length)
                for (u = 0; u < a.length; u++) a[u].calculateAxisParameters();
            for (u = 0; u < p.length; u++)
                if (p[u] && p[u].scaleBreaks && p[u].scaleBreaks._appliedBreaks.length)
                    for (var m = p[u].scaleBreaks._appliedBreaks, g = 0; g < m.length && !(m[g].startValue > p[u].viewportMaximum); g++) m[g].endValue < p[u].viewportMinimum || (l(p[u].scaleBreaks.firstBreakIndex) && (p[u].scaleBreaks.firstBreakIndex = g), m[g].startValue >= p[u].viewPortMinimum && (p[u].scaleBreaks.lastBreakIndex = g));
            var b, y, v, f, k, T = g = 0,
                P = 0,
                w = 0,
                C = 0,
                S = 0,
                _ = 0,
                B = r = 0;
            for (m = v = f = k = !1, u = 0; u < p.length; u++) p[u] && p[u].title && (p[u]._titleTextBlock = new M(p[u].ctx, {
                text: p[u].title,
                horizontalAlign: "center",
                fontSize: p[u].titleFontSize,
                fontFamily: p[u].titleFontFamily,
                fontWeight: p[u].titleFontWeight,
                fontColor: p[u].titleFontColor,
                fontStyle: p[u].titleFontStyle,
                borderColor: p[u].titleBorderColor,
                borderThickness: p[u].titleBorderThickness,
                backgroundColor: p[u].titleBackgroundColor,
                cornerRadius: p[u].titleCornerRadius,
                textBaseline: "top"
            }));
            for (u = 0; u < p.length; u++)
                if (p[u].title) switch (p[u]._position) {
                    case "left":
                        p[u]._titleTextBlock.maxWidth = p[u].titleMaxWidth || n.height, p[u]._titleTextBlock.maxHeight = p[u].titleWrap ? .8 * n.width : 1.5 * p[u].titleFontSize, p[u]._titleTextBlock.angle = -90;
                        break;
                    case "right":
                        p[u]._titleTextBlock.maxWidth = p[u].titleMaxWidth || n.height, p[u]._titleTextBlock.maxHeight = p[u].titleWrap ? .8 * n.width : 1.5 * p[u].titleFontSize, p[u]._titleTextBlock.angle = 90;
                        break;
                    default:
                        p[u]._titleTextBlock.maxWidth = p[u].titleMaxWidth || n.width, p[u]._titleTextBlock.maxHeight = p[u].titleWrap ? .8 * n.height : 1.5 * p[u].titleFontSize, p[u]._titleTextBlock.angle = 0
                }
                if ("normal" === s) {
                    w = [], C = [], S = [], _ = [];
                    for (var F = [], A = [], L = [], I = []; 4 > g;) {
                        var V = 0,
                            D = 0,
                            W = 0,
                            z = 0,
                            X = s = 0,
                            Y = 0,
                            E = 0,
                            O = 0,
                            R = 0,
                            N = 0,
                            H = 0;
                        if (i && 0 < i.length)
                            for (S = [], u = N = 0; u < i.length; u++) S.push(Math.ceil(i[u] ? i[u].createLabelsAndCalculateWidth() : 0)), N += S[u], Y += i[u] && !x.isNavigator ? i[u].margin : 0;
                        else S.push(Math.ceil(i[0] ? i[0].createLabelsAndCalculateWidth() : 0));
                        if (L.push(S), a && 0 < a.length)
                            for (_ = [], u = H = 0; u < a.length; u++) _.push(Math.ceil(a[u] ? a[u].createLabelsAndCalculateWidth() : 0)), H += _[u], E += a[u] ? a[u].margin : 0;
                        else _.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateWidth() : 0));
                        if (I.push(_), o = Math.round(n.x1 + N + Y), h = Math.round(n.x2 - H - E > x.width - c ? x.width - c : n.x2 - H - E), t && 0 < t.length)
                            for (w = [], u = O = 0; u < t.length; u++) t[u] && (t[u].lineCoordinates = {}), t[u].lineCoordinates.width = Math.abs(h - o), t[u].title && (t[u]._titleTextBlock.maxWidth = 0 < t[u].titleMaxWidth && t[u].titleMaxWidth < t[u].lineCoordinates.width ? t[u].titleMaxWidth : t[u].lineCoordinates.width), w.push(Math.ceil(t[u] ? t[u].createLabelsAndCalculateHeight() : 0)), O += w[u], s += t[u] && !x.isNavigator ? t[u].margin : 0;
                        else w.push(Math.ceil(t[0] ? t[0].createLabelsAndCalculateHeight() : 0));
                        if (F.push(w), e && 0 < e.length)
                            for (C = [], u = R = 0; u < e.length; u++) e[u] && (e[u].lineCoordinates = {}), e[u].lineCoordinates.width = Math.abs(h - o), e[u].title && (e[u]._titleTextBlock.maxWidth = 0 < e[u].titleMaxWidth && e[u].titleMaxWidth < e[u].lineCoordinates.width ? e[u].titleMaxWidth : e[u].lineCoordinates.width), C.push(Math.ceil(e[u] ? e[u].createLabelsAndCalculateHeight() : 0)), R += C[u], X += e[u] && !x.isNavigator ? e[u].margin : 0;
                        else C.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateHeight() : 0));
                        if (A.push(C), t && 0 < t.length)
                            for (u = 0; u < t.length; u++) t[u] && (t[u].lineCoordinates.x1 = o, h = Math.round(n.x2 - H - E > x.width - c ? x.width - c : n.x2 - H - E), t[u]._labels && 1 < t[u]._labels.length && (r = d = 0, d = t[u]._labels[1], r = "dateTime" === t[u].valueType ? t[u]._labels[t[u]._labels.length - 2] : t[u]._labels[t[u]._labels.length - 1], T = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle)), P = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle))), !t[u] || !t[u].labelAutoFit || l(b) || l(y) || x.isNavigator || (r = 0, 0 < t[u].labelAngle ? y + P > h && (r += 0 < t[u].labelAngle ? y + P - h - H : 0) : 0 > t[u].labelAngle ? b - T < o && b - T < t[u].viewportMinimum && (B = o - (Y + t[u].tickLength + S + b - T + t[u].labelFontSize / 2)) : 0 === t[u].labelAngle && (y + P > h && (r = y + P / 2 - h - H), b - T < o && b - T < t[u].viewportMinimum && (B = o - Y - t[u].tickLength - S - b + T / 2)), t[u].viewportMaximum === t[u].maximum && t[u].viewportMinimum === t[u].minimum && 0 < t[u].labelAngle && 0 < r ? h -= r : t[u].viewportMaximum === t[u].maximum && t[u].viewportMinimum === t[u].minimum && 0 > t[u].labelAngle && 0 < B ? o += B : t[u].viewportMaximum === t[u].maximum && t[u].viewportMinimum === t[u].minimum && 0 === t[u].labelAngle && (0 < B && (o += B), 0 < r && (h -= r))), x.panEnabled ? O = x.sessionVariables.axisX.height : x.sessionVariables.axisX.height = O, r = Math.round(n.y2 - O - s + V), d = Math.round(n.y2), t[u].lineCoordinates.x2 = h, t[u].lineCoordinates.width = h - o, t[u].lineCoordinates.y1 = r, t[u].lineCoordinates.y2 = r, t[u].bounds = {
                                x1: o,
                                y1: r,
                                x2: h,
                                y2: d - (O + s - w[u] - V),
                                width: h - o,
                                height: d - r
                            }), V += w[u] + t[u].margin;
                        if (e && 0 < e.length)
                            for (u = 0; u < e.length; u++) e[u].lineCoordinates.x1 = Math.round(n.x1 + N + Y), e[u].lineCoordinates.x2 = Math.round(n.x2 - H - E > x.width - c ? x.width - c : n.x2 - H - E), e[u].lineCoordinates.width = Math.abs(h - o), e[u]._labels && 1 < e[u]._labels.length && (d = e[u]._labels[1], r = "dateTime" === e[u].valueType ? e[u]._labels[e[u]._labels.length - 2] : e[u]._labels[e[u]._labels.length - 1], T = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle)), P = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle))), x.panEnabled ? R = x.sessionVariables.axisX2.height : x.sessionVariables.axisX2.height = R, r = Math.round(n.y1), d = Math.round(n.y2 + e[u].margin), e[u].lineCoordinates.y1 = r + R + X - D, e[u].lineCoordinates.y2 = r, e[u].bounds = {
                                x1: o,
                                y1: r + (R + X - C[u] - D),
                                x2: h,
                                y2: d,
                                width: h - o,
                                height: d - r
                            }, D += C[u] + e[u].margin;
                        if (i && 0 < i.length)
                            for (u = 0; u < i.length; u++) Y = x.isNavigator ? 0 : 10, i[u] && (o = Math.round(t[0] ? t[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), Y = i[u]._labels && 0 < i[u]._labels.length ? i[u]._labels[i[u]._labels.length - 1].textBlock.height / 2 : c, r = Math.round(n.y1 + R + X < Math.max(Y, c) ? Math.max(Y, c) : n.y1 + R + X), h = Math.round(t[0] ? t[0].lineCoordinates.x1 : e[0].lineCoordinates.x1), Y = 0 < t.length ? 0 : i[u]._labels && 0 < i[u]._labels.length ? i[u]._labels[0].textBlock.height / 2 : c, d = Math.round(n.y2 - O - s - Y), i[u].lineCoordinates = {
                                x1: h - W,
                                y1: r,
                                x2: h - W,
                                y2: d,
                                height: Math.abs(d - r)
                            }, i[u].bounds = {
                                x1: o - (S[u] + W),
                                y1: r,
                                x2: h,
                                y2: d,
                                width: h - o,
                                height: d - r
                            }, i[u].title && (i[u]._titleTextBlock.maxWidth = 0 < i[u].titleMaxWidth && i[u].titleMaxWidth < i[u].lineCoordinates.height ? i[u].titleMaxWidth : i[u].lineCoordinates.height), W += S[u] + i[u].margin);
                        if (a && 0 < a.length)
                            for (u = 0; u < a.length; u++) a[u] && (o = Math.round(t[0] ? t[0].lineCoordinates.x2 : e[0].lineCoordinates.x2), h = Math.round(o), Y = a[u]._labels && 0 < a[u]._labels.length ? a[u]._labels[a[u]._labels.length - 1].textBlock.height / 2 : 0, r = Math.round(n.y1 + R + X < Math.max(Y, c) ? Math.max(Y, c) : n.y1 + R + X), Y = 0 < t.length ? 0 : a[u]._labels && 0 < a[u]._labels.length ? a[u]._labels[0].textBlock.height / 2 : 0, d = Math.round(n.y2 - (O + s + Y)), a[u].lineCoordinates = {
                                x1: o + z,
                                y1: r,
                                x2: o + z,
                                y2: d,
                                height: Math.abs(d - r)
                            }, a[u].bounds = {
                                x1: o,
                                y1: r,
                                x2: h + (_[u] + z),
                                y2: d,
                                width: h - o,
                                height: d - r
                            }, a[u].title && (a[u]._titleTextBlock.maxWidth = 0 < a[u].titleMaxWidth && a[u].titleMaxWidth < a[u].lineCoordinates.height ? a[u].titleMaxWidth : a[u].lineCoordinates.height), z += _[u] + a[u].margin);
                        if (t && 0 < t.length)
                            for (u = 0; u < t.length; u++) t[u] && (t[u].calculateValueToPixelConversionParameters(), t[u].calculateBreaksSizeInValues(), t[u]._labels && 1 < t[u]._labels.length && (b = (t[u].logarithmic ? Math.log(t[u]._labels[1].position / t[u].viewportMinimum) / t[u].conversionParameters.lnLogarithmBase : t[u]._labels[1].position - t[u].viewportMinimum) * Math.abs(t[u].conversionParameters.pixelPerUnit) + t[u].lineCoordinates.x1, o = t[u]._labels[t[u]._labels.length - ("dateTime" === t[u].valueType ? 2 : 1)].position, o = t[u].getApparentDifference(t[u].viewportMinimum, o), y = t[u].logarithmic ? (1 < o ? Math.log(o) / t[u].conversionParameters.lnLogarithmBase * Math.abs(t[u].conversionParameters.pixelPerUnit) : 0) + t[u].lineCoordinates.x1 : (0 < o ? o * Math.abs(t[u].conversionParameters.pixelPerUnit) : 0) + t[u].lineCoordinates.x1));
                        if (e && 0 < e.length)
                            for (u = 0; u < e.length; u++) e[u].calculateValueToPixelConversionParameters(), e[u].calculateBreaksSizeInValues(), e[u]._labels && 1 < e[u]._labels.length && (b = (e[u].logarithmic ? Math.log(e[u]._labels[1].position / e[u].viewportMinimum) / e[u].conversionParameters.lnLogarithmBase : e[u]._labels[1].position - e[u].viewportMinimum) * Math.abs(e[u].conversionParameters.pixelPerUnit) + e[u].lineCoordinates.x1, o = e[u]._labels[e[u]._labels.length - ("dateTime" === e[u].valueType ? 2 : 1)].position, o = e[u].getApparentDifference(e[u].viewportMinimum, o), y = e[u].logarithmic ? (1 < o ? Math.log(o) / e[u].conversionParameters.lnLogarithmBase * Math.abs(e[u].conversionParameters.pixelPerUnit) : 0) + e[u].lineCoordinates.x1 : (0 < o ? o * Math.abs(e[u].conversionParameters.pixelPerUnit) : 0) + e[u].lineCoordinates.x1);
                        for (u = 0; u < p.length; u++) "axisY" === p[u].type && (p[u].calculateValueToPixelConversionParameters(), p[u].calculateBreaksSizeInValues());
                        if (0 < g) {
                            if (t && 0 < t.length)
                                for (u = 0; u < t.length; u++) m = F[g - 1][u] === F[g][u];
                            else m = !0;
                            if (e && 0 < e.length)
                                for (u = 0; u < e.length; u++) v = A[g - 1][u] === A[g][u];
                            else v = !0;
                            if (i && 0 < i.length)
                                for (u = 0; u < i.length; u++) f = L[g - 1][u] === L[g][u];
                            else f = !0;
                            if (a && 0 < a.length)
                                for (u = 0; u < a.length; u++) k = I[g - 1][u] === I[g][u];
                            else k = !0
                        }
                        if (m && v && f && k) break;
                        g++
                    }
                    if (t && 0 < t.length)
                        for (u = 0; u < t.length; u++) t[u].calculateStripLinesThicknessInValues(), t[u].calculateBreaksInPixels();
                    if (e && 0 < e.length)
                        for (u = 0; u < e.length; u++) e[u].calculateStripLinesThicknessInValues(), e[u].calculateBreaksInPixels();
                    if (i && 0 < i.length)
                        for (u = 0; u < i.length; u++) i[u].calculateStripLinesThicknessInValues(), i[u].calculateBreaksInPixels();
                    if (a && 0 < a.length)
                        for (u = 0; u < a.length; u++) a[u].calculateStripLinesThicknessInValues(), a[u].calculateBreaksInPixels()
                } else {
                    for (c = [], b = [], B = [], T = [], y = [], P = [], F = [], A = []; 4 > g;) {
                        if (O = z = D = W = E = Y = X = s = I = L = V = R = 0, t && 0 < t.length)
                            for (B = [], u = z = 0; u < t.length; u++) B.push(Math.ceil(t[u] ? t[u].createLabelsAndCalculateWidth() : 0)), z += B[u], s += t[u] && !x.isNavigator ? t[u].margin : 0;
                        else B.push(Math.ceil(t[0] ? t[0].createLabelsAndCalculateWidth() : 0));
                        if (F.push(B), e && 0 < e.length)
                            for (T = [], u = O = 0; u < e.length; u++) T.push(Math.ceil(e[u] ? e[u].createLabelsAndCalculateWidth() : 0)), O += T[u], X += e[u] ? e[u].margin : 0;
                        else T.push(Math.ceil(e[0] ? e[0].createLabelsAndCalculateWidth() : 0));
                        if (A.push(T), i && 0 < i.length)
                            for (u = 0; u < i.length; u++) i[u].lineCoordinates = {}, o = Math.round(n.x1 + z + s), h = Math.round(n.x2 - O - X > x.width - 10 ? x.width - 10 : n.x2 - O - X), i[u].labelAutoFit && !l(w) && (0 < !t.length && (o = 0 > i[u].labelAngle ? Math.max(o, w) : 0 === i[u].labelAngle ? Math.max(o, w / 2) : o), 0 < !e.length && (h = 0 < i[u].labelAngle ? h - C / 2 : 0 === i[u].labelAngle ? h - C / 2 : h)), i[u].lineCoordinates.x1 = o, i[u].lineCoordinates.x2 = h, i[u].lineCoordinates.width = Math.abs(h - o), i[u].title && (i[u]._titleTextBlock.maxWidth = 0 < i[u].titleMaxWidth && i[u].titleMaxWidth < i[u].lineCoordinates.width ? i[u].titleMaxWidth : i[u].lineCoordinates.width);
                        if (a && 0 < a.length)
                            for (u = 0; u < a.length; u++) a[u].lineCoordinates = {}, o = Math.round(n.x1 + z + s), h = Math.round(n.x2 - O - X > a[u].chart.width - 10 ? a[u].chart.width - 10 : n.x2 - O - X), a[u] && a[u].labelAutoFit && !l(S) && (0 < !t.length && (o = 0 < a[u].labelAngle ? Math.max(o, S) : 0 === a[u].labelAngle ? Math.max(o, S / 2) : o), 0 < !e.length && (h -= _ / 2)), a[u].lineCoordinates.x1 = o, a[u].lineCoordinates.x2 = h, a[u].lineCoordinates.width = Math.abs(h - o), a[u].title && (a[u]._titleTextBlock.maxWidth = 0 < a[u].titleMaxWidth && a[u].titleMaxWidth < a[u].lineCoordinates.width ? a[u].titleMaxWidth : a[u].lineCoordinates.width);
                        if (i && 0 < i.length)
                            for (c = [], u = W = 0; u < i.length; u++) c.push(Math.ceil(i[u] ? i[u].createLabelsAndCalculateHeight() : 0)), W += c[u] + i[u].margin, Y += i[u].margin;
                        else c.push(Math.ceil(i[0] ? i[0].createLabelsAndCalculateHeight() : 0));
                        if (y.push(c), a && 0 < a.length)
                            for (b = [], u = D = 0; u < a.length; u++) b.push(Math.ceil(a[u] ? a[u].createLabelsAndCalculateHeight() : 0)), D += b[u], E += a[u].margin;
                        else b.push(Math.ceil(a[0] ? a[0].createLabelsAndCalculateHeight() : 0));
                        if (P.push(b), i && 0 < i.length)
                            for (u = 0; u < i.length; u++) 0 < i[u]._labels.length && (d = i[u]._labels[0], r = i[u]._labels[i[u]._labels.length - 1], w = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle)), C = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle)));
                        if (a && 0 < a.length)
                            for (u = 0; u < a.length; u++) a[u] && 0 < a[u]._labels.length && (d = a[u]._labels[0], r = a[u]._labels[a[u]._labels.length - 1], S = d.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(d.textBlock.angle)) + (d.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(d.textBlock.angle)), _ = r.textBlock.width * Math.cos(Math.PI / 180 * Math.abs(r.textBlock.angle)) + (r.textBlock.height - r.textBlock.fontSize / 2) * Math.sin(Math.PI / 180 * Math.abs(r.textBlock.angle)));
                        if (x.panEnabled)
                            for (u = 0; u < i.length; u++) c[u] = x.sessionVariables.axisY.height;
                        else
                            for (u = 0; u < i.length; u++) x.sessionVariables.axisY.height = c[u];
                        if (i && 0 < i.length)
                            for (u = i.length - 1; 0 <= u; u--) r = Math.round(n.y2), d = Math.round(n.y2 > i[u].chart.height - 10 ? i[u].chart.height - 10 : n.y2), i[u].lineCoordinates.y1 = r - (c[u] + i[u].margin + R), i[u].lineCoordinates.y2 = r - (c[u] + i[u].margin + R), i[u].bounds = {
                                x1: o,
                                y1: r - (c[u] + R + i[u].margin),
                                x2: h,
                                y2: d - (R + i[u].margin),
                                width: h - o,
                                height: c[u]
                            }, i[u].title && (i[u]._titleTextBlock.maxWidth = 0 < i[u].titleMaxWidth && i[u].titleMaxWidth < i[u].lineCoordinates.width ? i[u].titleMaxWidth : i[u].lineCoordinates.width), R += c[u] + i[u].margin;
                        if (a && 0 < a.length)
                            for (u = a.length - 1; 0 <= u; u--) a[u] && (r = Math.round(n.y1), d = Math.round(n.y1 + (b[u] + a[u].margin + V)), a[u].lineCoordinates.y1 = d, a[u].lineCoordinates.y2 = d, a[u].bounds = {
                                x1: o,
                                y1: r + (a[u].margin + V),
                                x2: h,
                                y2: d,
                                width: h - o,
                                height: D
                            }, a[u].title && (a[u]._titleTextBlock.maxWidth = 0 < a[u].titleMaxWidth && a[u].titleMaxWidth < a[u].lineCoordinates.width ? a[u].titleMaxWidth : a[u].lineCoordinates.width), V += b[u] + a[u].margin);
                        if (t && 0 < t.length)
                            for (u = 0; u < t.length; u++) {
                                if (Y = t[u]._labels && 0 < t[u]._labels.length ? t[u]._labels[0].textBlock.fontSize / 2 : 0, o = Math.round(n.x1 + s), r = a && 0 < a.length ? Math.round(a[0] ? a[0].lineCoordinates.y2 : n.y1 < Math.max(Y, 10) ? Math.max(Y, 10) : n.y1) : n.y1 < Math.max(Y, 10) ? Math.max(Y, 10) : n.y1, h = Math.round(n.x1 + z + s), d = i && 0 < i.length ? Math.round(i[0] ? i[0].lineCoordinates.y1 : n.y2 - W > x.height - Math.max(Y, 10) ? x.height - Math.max(Y, 10) : n.y2 - W) : n.y2 > x.height - Math.max(Y, 10) ? x.height - Math.max(Y, 10) : n.y2, i && 0 < i.length)
                                    for (Y = 0; Y < i.length; Y++) i[Y] && i[Y].labelAutoFit && (h = 0 > i[Y].labelAngle ? Math.max(h, w) : 0 === i[Y].labelAngle ? Math.max(h, w / 2) : h, o = 0 > i[Y].labelAngle || 0 === i[Y].labelAngle ? h - z : o);
                                if (a && 0 < a.length)
                                    for (Y = 0; Y < a.length; Y++) a[Y] && a[Y].labelAutoFit && (o = (h = a[Y].lineCoordinates.x1) - z);
                                t[u].lineCoordinates = {
                                    x1: h - L,
                                    y1: r,
                                    x2: h - L,
                                    y2: d,
                                    height: Math.abs(d - r)
                                }, t[u].bounds = {
                                    x1: h - (B[u] + L),
                                    y1: r,
                                    x2: h,
                                    y2: d,
                                    width: h - o,
                                    height: d - r
                                }, t[u].title && (t[u]._titleTextBlock.maxWidth = 0 < t[u].titleMaxWidth && t[u].titleMaxWidth < t[u].lineCoordinates.height ? t[u].titleMaxWidth : t[u].lineCoordinates.height), t[u].calculateValueToPixelConversionParameters(), t[u].calculateBreaksSizeInValues(), L += B[u] + t[u].margin
                            }
                        if (e && 0 < e.length)
                            for (u = 0; u < e.length; u++) {
                                if (Y = e[u]._labels && 0 < e[u]._labels.length ? e[u]._labels[0].textBlock.fontSize / 2 : 0, o = Math.round(n.x1 - s), r = a && 0 < a.length ? Math.round(a[0] ? a[0].lineCoordinates.y2 : n.y1 < Math.max(Y, 10) ? Math.max(Y, 10) : n.y1) : n.y1 < Math.max(Y, 10) ? Math.max(Y, 10) : n.y1, h = Math.round(n.x2 - O - X), d = i && 0 < i.length ? Math.round(i[0] ? i[0].lineCoordinates.y1 : n.y2 - W > x.height - Math.max(Y, 10) ? x.height - Math.max(Y, 10) : n.y2 - W) : n.y2 > x.height - Math.max(Y, 10) ? x.height - Math.max(Y, 10) : n.y2, i && 0 < i.length)
                                    for (Y = 0; Y < i.length; Y++) i[Y] && i[Y].labelAutoFit && (h = 0 > i[Y].labelAngle ? Math.max(h, w) : 0 === i[Y].labelAngle ? Math.max(h, w / 2) : h, o = 0 > i[Y].labelAngle || 0 === i[Y].labelAngle ? h - O : o);
                                if (a && 0 < a.length)
                                    for (Y = 0; Y < a.length; Y++) a[Y] && a[Y].labelAutoFit && (o = (h = a[Y].lineCoordinates.x2) - O);
                                e[u].lineCoordinates = {
                                    x1: h + I,
                                    y1: r,
                                    x2: h + I,
                                    y2: d,
                                    height: Math.abs(d - r)
                                }, e[u].bounds = {
                                    x1: o,
                                    y1: r,
                                    x2: h + T[u] + I,
                                    y2: d,
                                    width: h - o,
                                    height: d - r
                                }, e[u].title && (e[u]._titleTextBlock.maxWidth = 0 < e[u].titleMaxWidth && e[u].titleMaxWidth < e[u].lineCoordinates.height ? e[u].titleMaxWidth : e[u].lineCoordinates.height), e[u].calculateValueToPixelConversionParameters(), e[u].calculateBreaksSizeInValues(), I += T[u] + e[u].margin
                            }
                        for (u = 0; u < p.length; u++) "axisY" === p[u].type && (p[u].calculateValueToPixelConversionParameters(), p[u].calculateBreaksSizeInValues());
                        if (0 < g) {
                            if (t && 0 < t.length)
                                for (u = 0; u < t.length; u++) m = F[g - 1][u] === F[g][u];
                            else m = !0;
                            if (e && 0 < e.length)
                                for (u = 0; u < e.length; u++) v = A[g - 1][u] === A[g][u];
                            else v = !0;
                            if (i && 0 < i.length)
                                for (u = 0; u < i.length; u++) f = y[g - 1][u] === y[g][u];
                            else f = !0;
                            if (a && 0 < a.length)
                                for (u = 0; u < a.length; u++) k = P[g - 1][u] === P[g][u];
                            else k = !0
                        }
                        if (m && v && f && k) break;
                        g++
                    }
                    if (i && 0 < i.length)
                        for (u = 0; u < i.length; u++) i[u].calculateStripLinesThicknessInValues(), i[u].calculateBreaksInPixels();
                    if (a && 0 < a.length)
                        for (u = 0; u < a.length; u++) a[u].calculateStripLinesThicknessInValues(), a[u].calculateBreaksInPixels();
                    if (t && 0 < t.length)
                        for (u = 0; u < t.length; u++) t[u].calculateStripLinesThicknessInValues(), t[u].calculateBreaksInPixels();
                    if (e && 0 < e.length)
                        for (u = 0; u < e.length; u++) e[u].calculateStripLinesThicknessInValues(), e[u].calculateBreaksInPixels()
                }
        }, W.render = function(t, e, i, a, s) {
            var n = t[0] ? t[0].chart : e[0].chart;
            s = n.ctx;
            var o = n._axes;
            if (n.alignVerticalAxes && n.alignVerticalAxes(), s.save(), s.beginPath(), t[0] && s.rect(5, t[0].bounds.y1, t[0].chart.width - 10, t[0].bounds.height), e[0] && s.rect(5, e[e.length - 1].bounds.y1, e[0].chart.width - 10, e[0].bounds.height), s.clip(), t && 0 < t.length)
                for (var l = 0; l < t.length; l++) t[l].renderLabelsTicksAndTitle();
            if (e && 0 < e.length)
                for (l = 0; l < e.length; l++) e[l].renderLabelsTicksAndTitle();
            if (s.restore(), i && 0 < i.length)
                for (l = 0; l < i.length; l++) i[l].renderLabelsTicksAndTitle();
            if (a && 0 < a.length)
                for (l = 0; l < a.length; l++) a[l].renderLabelsTicksAndTitle();
            if (n.preparePlotArea(), n = n.plotArea, s.save(), s.beginPath(), s.rect(n.x1, n.y1, Math.abs(n.x2 - n.x1), Math.abs(n.y2 - n.y1)), s.clip(), t && 0 < t.length)
                for (l = 0; l < o.length; l++) o[l].renderStripLinesOfThicknessType("value");
            if (e && 0 < e.length)
                for (l = 0; l < e.length; l++) e[l].renderStripLinesOfThicknessType("value");
            if (i && 0 < i.length)
                for (l = 0; l < i.length; l++) i[l].renderStripLinesOfThicknessType("value");
            if (a && 0 < a.length)
                for (l = 0; l < a.length; l++) a[l].renderStripLinesOfThicknessType("value");
            if (t && 0 < t.length)
                for (l = 0; l < t.length; l++) t[l].renderInterlacedColors();
            if (e && 0 < e.length)
                for (l = 0; l < e.length; l++) e[l].renderInterlacedColors();
            if (i && 0 < i.length)
                for (l = 0; l < i.length; l++) i[l].renderInterlacedColors();
            if (a && 0 < a.length)
                for (l = 0; l < a.length; l++) a[l].renderInterlacedColors();
            if (s.restore(), t && 0 < t.length)
                for (l = 0; l < t.length; l++) t[l].renderGrid(), D && (t[l].createMask(), t[l].renderBreaksBackground());
            if (e && 0 < e.length)
                for (l = 0; l < e.length; l++) e[l].renderGrid(), D && (e[l].createMask(), e[l].renderBreaksBackground());
            if (i && 0 < i.length)
                for (l = 0; l < i.length; l++) i[l].renderGrid(), D && (i[l].createMask(), i[l].renderBreaksBackground());
            if (a && 0 < a.length)
                for (l = 0; l < a.length; l++) a[l].renderGrid(), D && (a[l].createMask(), a[l].renderBreaksBackground());
            if (t && 0 < t.length)
                for (l = 0; l < t.length; l++) t[l].renderAxisLine();
            if (e && 0 < e.length)
                for (l = 0; l < e.length; l++) e[l].renderAxisLine();
            if (i && 0 < i.length)
                for (l = 0; l < i.length; l++) i[l].renderAxisLine();
            if (a && 0 < a.length)
                for (l = 0; l < a.length; l++) a[l].renderAxisLine();
            if (t && 0 < t.length)
                for (l = 0; l < t.length; l++) t[l].renderStripLinesOfThicknessType("pixel");
            if (e && 0 < e.length)
                for (l = 0; l < e.length; l++) e[l].renderStripLinesOfThicknessType("pixel");
            if (i && 0 < i.length)
                for (l = 0; l < i.length; l++) i[l].renderStripLinesOfThicknessType("pixel");
            if (a && 0 < a.length)
                for (l = 0; l < a.length; l++) a[l].renderStripLinesOfThicknessType("pixel")
        }, W.prototype.calculateStripLinesThicknessInValues = function() {
            for (var t = 0; t < this.stripLines.length; t++)
                if (null !== this.stripLines[t].startValue && null !== this.stripLines[t].endValue) {
                    var e = Math.min(this.stripLines[t].startValue, this.stripLines[t].endValue),
                        i = Math.max(this.stripLines[t].startValue, this.stripLines[t].endValue);
                    e = this.getApparentDifference(e, i);
                    this.stripLines[t].value = this.logarithmic ? this.stripLines[t].value * Math.sqrt(Math.log(this.stripLines[t].endValue / this.stripLines[t].startValue) / Math.log(e)) : this.stripLines[t].value + (Math.abs(this.stripLines[t].endValue - this.stripLines[t].startValue) - e) / 2, this.stripLines[t].thickness = e, this.stripLines[t]._thicknessType = "value"
                }
        }, W.prototype.calculateBreaksSizeInValues = function() {
            for (var t, e = "left" === this._position || "right" === this._position ? this.lineCoordinates.height || this.chart.height : this.lineCoordinates.width || this.chart.width, i = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [], a = this.conversionParameters.pixelPerUnit || e / (this.logarithmic ? this.conversionParameters.maximum / this.conversionParameters.minimum : this.conversionParameters.maximum - this.conversionParameters.minimum), s = this.scaleBreaks && !l(this.scaleBreaks.options.spacing), n = 0; n < i.length; n++) t = s || !l(i[n].options.spacing), i[n].spacing = F(i[n].spacing, e, 8, t ? .1 * e : 8, t ? 0 : 3) << 0, i[n].size = 0 > i[n].spacing ? 0 : Math.abs(i[n].spacing / a), this.logarithmic && (i[n].size = Math.pow(this.logarithmBase, i[n].size))
        }, W.prototype.calculateBreaksInPixels = function() {
            if (!(this.scaleBreaks && 0 >= this.scaleBreaks._appliedBreaks.length)) {
                var t = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
                t.length && (this.scaleBreaks.firstBreakIndex = this.scaleBreaks.lastBreakIndex = null);
                for (var e = 0; e < t.length && !(t[e].startValue > this.conversionParameters.maximum); e++) t[e].endValue < this.conversionParameters.minimum || (l(this.scaleBreaks.firstBreakIndex) && (this.scaleBreaks.firstBreakIndex = e), t[e].startValue >= this.conversionParameters.minimum && (t[e].startPixel = this.convertValueToPixel(t[e].startValue), this.scaleBreaks.lastBreakIndex = e), t[e].endValue <= this.conversionParameters.maximum && (t[e].endPixel = this.convertValueToPixel(t[e].endValue)))
            }
        }, W.prototype.renderLabelsTicksAndTitle = function() {
            var t = this,
                e = !1,
                i = 0,
                a = 0,
                s = 1,
                n = 0;
            if (0 !== this.labelAngle && 360 !== this.labelAngle && (s = 1.2), void 0 === this.options.interval) {
                if ("bottom" === this._position || "top" === this._position)
                    if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                        i = [], s = 0 !== this.labelAngle && 360 !== this.labelAngle ? 1 : 1.2;
                        for (var o, l = this.viewportMaximum, r = this.lineCoordinates.width / Math.log(this.range), h = this._labels.length - 1; 0 <= h && !((x = this._labels[h]).position < this.viewportMinimum); h--) x.position > this.viewportMaximum || !(h === this._labels.length - 1 || o < Math.log(l / x.position) * r / s) || (i.push(x), l = x.position, o = x.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + x.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                        this._labels = i
                    } else {
                        for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || (i += o = x.textBlock.width * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + x.textBlock.height * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                        i > this.lineCoordinates.width * s && this.labelAutoFit && (e = !0)
                    }
                if ("left" === this._position || "right" === this._position)
                    if (this.logarithmic && !this.equidistantInterval && this.labelAutoFit) {
                        var d;
                        for (i = [], l = this.viewportMaximum, r = this.lineCoordinates.height / Math.log(this.range), h = this._labels.length - 1; 0 <= h && !((x = this._labels[h]).position < this.viewportMinimum); h--) x.position > this.viewportMaximum || !(h === this._labels.length - 1 || d < Math.log(l / x.position) * r) || (i.push(x), l = x.position, d = x.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + x.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                        this._labels = i
                    } else {
                        for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || (a += d = x.textBlock.height * Math.abs(Math.cos(Math.PI / 180 * this.labelAngle)) + x.textBlock.width * Math.abs(Math.sin(Math.PI / 180 * this.labelAngle)));
                        a > this.lineCoordinates.height * s && this.labelAutoFit && (e = !0)
                    }
            }
            this.logarithmic && !this.equidistantInterval && this.labelAutoFit && this._labels.sort(function(t, e) {
                return t.position - e.position
            });
            var x, c;
            h = 0;
            if ("bottom" === this._position) {
                for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || x.position > this.viewportMaximum || e && 0 != n++ % 2 && this.labelAutoFit || (c = this.getPixelCoordinatesOnAxis(x.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, a = 1 == this.ctx.lineWidth % 2 ? .5 + (c.x << 0) : c.x << 0, this.ctx.beginPath(), this.ctx.moveTo(a, c.y << 0), this.ctx.lineTo(a, c.y + this.tickLength << 0), this.ctx.stroke()), 0 === x.textBlock.angle ? (c.x -= x.textBlock.width / 2, c.y = "inside" === this.labelPlacement ? c.y - (this.tickLength + x.textBlock.fontSize / 2) : c.y + this.tickLength + x.textBlock.fontSize / 2) : (c.x = "inside" === this.labelPlacement ? 0 > this.labelAngle ? c.x : c.x - x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : c.x - (0 > this.labelAngle ? x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), c.y = "inside" === this.labelPlacement ? 0 > this.labelAngle ? c.y - this.tickLength - 5 : c.y - this.tickLength - Math.abs(x.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + 5) : c.y + this.tickLength + Math.abs(0 > this.labelAngle ? x.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5)), x.textBlock.x = c.x, x.textBlock.y = c.y);
                "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
                    for (h = 0; h < t._labels.length; h++)
                        if (!((x = t._labels[h]).position < t.viewportMinimum || x.position > t.viewportMaximum || e && 0 != n++ % 2 && t.labelAutoFit) && (c = t.getPixelCoordinatesOnAxis(x.position), t.tickThickness)) {
                            t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor;
                            var i = 1 == t.ctx.lineWidth % 2 ? .5 + (c.x << 0) : c.x << 0;
                            t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(i, c.y << 0), t.ctx.lineTo(i, c.y - t.tickLength << 0), t.ctx.stroke(), t.ctx.restore()
                        }
                }, this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y2 - this._titleTextBlock.height - 3, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
            } else if ("top" === this._position) {
                for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || x.position > this.viewportMaximum || e && 0 != n++ % 2 && this.labelAutoFit || (c = this.getPixelCoordinatesOnAxis(x.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, a = 1 == this.ctx.lineWidth % 2 ? .5 + (c.x << 0) : c.x << 0, this.ctx.beginPath(), this.ctx.moveTo(a, c.y << 0), this.ctx.lineTo(a, c.y - this.tickLength << 0), this.ctx.stroke()), 0 === x.textBlock.angle ? (c.x -= x.textBlock.width / 2, c.y = "inside" === this.labelPlacement ? c.y + this.labelFontSize / 2 + this.tickLength + 5 : c.y - (this.tickLength + x.textBlock.height - x.textBlock.fontSize / 2)) : (c.x = "inside" === this.labelPlacement ? 0 < this.labelAngle ? c.x : c.x - x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : c.x + (x.textBlock.height - this.tickLength - this.labelFontSize) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), c.y = "inside" === this.labelPlacement ? 0 < this.labelAngle ? c.y + this.tickLength + 5 : c.y - x.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength + 5 : c.y - (this.tickLength + ((x.textBlock.height - x.textBlock.fontSize / 2) * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? x.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))), x.textBlock.x = c.x, x.textBlock.y = c.y);
                "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
                    for (h = 0; h < t._labels.length; h++)
                        if (!((x = t._labels[h]).position < t.viewportMinimum || x.position > t.viewportMaximum || e && 0 != n++ % 2 && t.labelAutoFit) && (c = t.getPixelCoordinatesOnAxis(x.position), t.tickThickness)) {
                            t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor;
                            var i = 1 == this.ctx.lineWidth % 2 ? .5 + (c.x << 0) : c.x << 0;
                            t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(i, c.y << 0), t.ctx.lineTo(i, c.y + t.tickLength << 0), t.ctx.stroke(), t.ctx.restore()
                        }
                }, this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.lineCoordinates.x1 + this.lineCoordinates.width / 2 - this._titleTextBlock.width / 2, this._titleTextBlock.y = this.bounds.y1 + 1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
            } else if ("left" === this._position) {
                for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || x.position > this.viewportMaximum || e && 0 != n++ % 2 && this.labelAutoFit || (c = this.getPixelCoordinatesOnAxis(x.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, a = 1 == this.ctx.lineWidth % 2 ? .5 + (c.y << 0) : c.y << 0, this.ctx.beginPath(), this.ctx.moveTo(c.x << 0, a), this.ctx.lineTo(c.x - this.tickLength << 0, a), this.ctx.stroke()), 0 === this.labelAngle ? (x.textBlock.y = c.y, x.textBlock.x = "inside" === this.labelPlacement ? c.x + this.tickLength + 5 : c.x - x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5) : (x.textBlock.y = "inside" === this.labelPlacement ? c.y : c.y - x.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), x.textBlock.x = "inside" === this.labelPlacement ? c.x + this.tickLength + 5 : 0 < this.labelAngle ? c.x - x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : c.x - x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (x.textBlock.height - x.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength));
                "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
                    for (h = 0; h < t._labels.length; h++)
                        if (!((x = t._labels[h]).position < t.viewportMinimum || x.position > t.viewportMaximum || e && 0 != n++ % 2 && t.labelAutoFit) && (c = t.getPixelCoordinatesOnAxis(x.position), t.tickThickness)) {
                            t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor;
                            var i = 1 == t.ctx.lineWidth % 2 ? .5 + (c.y << 0) : c.y << 0;
                            t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(c.x << 0, i), t.ctx.lineTo(c.x + t.tickLength << 0, i), t.ctx.stroke(), t.ctx.restore()
                        }
                }, this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x1 + 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 + this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
            } else if ("right" === this._position) {
                for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || x.position > this.viewportMaximum || e && 0 != n++ % 2 && this.labelAutoFit || (c = this.getPixelCoordinatesOnAxis(x.position), this.tickThickness && "inside" != this.labelPlacement && (this.ctx.lineWidth = this.tickThickness, this.ctx.strokeStyle = this.tickColor, a = 1 == this.ctx.lineWidth % 2 ? .5 + (c.y << 0) : c.y << 0, this.ctx.beginPath(), this.ctx.moveTo(c.x << 0, a), this.ctx.lineTo(c.x + this.tickLength << 0, a), this.ctx.stroke()), 0 === this.labelAngle ? (x.textBlock.y = c.y, x.textBlock.x = "inside" === this.labelPlacement ? c.x - x.textBlock.width - this.tickLength - 5 : c.x + this.tickLength + 5) : (x.textBlock.y = "inside" === this.labelPlacement ? c.y - x.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0 > this.labelAngle ? c.y : c.y - (x.textBlock.height - x.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), x.textBlock.x = "inside" === this.labelPlacement ? c.x - x.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : 0 < this.labelAngle ? c.x + (x.textBlock.height - x.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : c.x + this.tickLength + 5));
                "inside" === this.labelPlacement && this.chart.addEventListener("dataAnimationIterationEnd", function() {
                    for (h = 0; h < t._labels.length; h++)
                        if (!((x = t._labels[h]).position < t.viewportMinimum || x.position > t.viewportMaximum || e && 0 != n++ % 2 && t.labelAutoFit) && (c = t.getPixelCoordinatesOnAxis(x.position), t.tickThickness)) {
                            t.ctx.lineWidth = t.tickThickness, t.ctx.strokeStyle = t.tickColor;
                            var i = 1 == t.ctx.lineWidth % 2 ? .5 + (c.y << 0) : c.y << 0;
                            t.ctx.save(), t.ctx.beginPath(), t.ctx.moveTo(c.x << 0, i), t.ctx.lineTo(c.x - t.tickLength << 0, i), t.ctx.stroke(), t.ctx.restore()
                        }
                }, this), this.title && (this._titleTextBlock.measureText(), this._titleTextBlock.x = this.bounds.x2 - 1, this._titleTextBlock.y = this.lineCoordinates.height / 2 - this._titleTextBlock.width / 2 + this.lineCoordinates.y1, this.titleMaxWidth = this._titleTextBlock.maxWidth, this._titleTextBlock.render(!0))
            }
            if (n = 0, "inside" === this.labelPlacement) this.chart.addEventListener("dataAnimationIterationEnd", function() {
                for (h = 0; h < t._labels.length; h++)(x = t._labels[h]).position < t.viewportMinimum || x.position > t.viewportMaximum || e && 0 != n++ % 2 && t.labelAutoFit || (t.ctx.save(), t.ctx.beginPath(), x.textBlock.render(!0), t.ctx.restore())
            }, this);
            else
                for (h = 0; h < this._labels.length; h++)(x = this._labels[h]).position < this.viewportMinimum || x.position > this.viewportMaximum || e && 0 != n++ % 2 && this.labelAutoFit || x.textBlock.render(!0)
        }, W.prototype.renderInterlacedColors = function() {
            var t, e, i = this.chart.plotArea.ctx,
                a = this.chart.plotArea,
                s = 0;
            if (t = !0, "bottom" !== this._position && "top" !== this._position || !this.interlacedColor) {
                if (("left" === this._position || "right" === this._position) && this.interlacedColor)
                    for (i.fillStyle = this.interlacedColor, s = 0; s < this._labels.length; s++) t ? (e = this.getPixelCoordinatesOnAxis(this._labels[s].position), t = s + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[s + 1].position), i.fillRect(a.x1, Math.min(e.y, t.y), Math.abs(a.x1 - a.x2), Math.abs(t.y - e.y)), t = !1) : t = !0
            } else
                for (i.fillStyle = this.interlacedColor, s = 0; s < this._labels.length; s++) t ? (t = this.getPixelCoordinatesOnAxis(this._labels[s].position), e = s + 1 > this._labels.length - 1 ? this.getPixelCoordinatesOnAxis(this.viewportMaximum) : this.getPixelCoordinatesOnAxis(this._labels[s + 1].position), i.fillRect(Math.min(e.x, t.x), a.y1, Math.abs(e.x - t.x), Math.abs(a.y1 - a.y2)), t = !1) : t = !0;
            i.beginPath()
        }, W.prototype.renderStripLinesOfThicknessType = function(t) {
            if (this.stripLines && 0 < this.stripLines.length && t) {
                var e, i = this,
                    a = 0,
                    s = 0,
                    n = !1,
                    o = !1,
                    r = [],
                    h = [];
                for (o = !1, a = 0; a < this.stripLines.length; a++) {
                    var d = this.stripLines[a];
                    d._thicknessType === t && ("pixel" === t && (d.value < this.viewportMinimum || d.value > this.viewportMaximum || l(d.value) || isNaN(this.range)) || r.push(d))
                }
                for (a = 0; a < this._stripLineLabels.length; a++)
                    if (d = this.stripLines[a], !((e = this._stripLineLabels[a]).position < this.viewportMinimum || e.position > this.viewportMaximum || isNaN(this.range))) {
                        if (t = this.getPixelCoordinatesOnAxis(e.position), "outside" === e.stripLine.labelPlacement)
                            if (d && (this.ctx.strokeStyle = d.color, "pixel" === d._thicknessType && (this.ctx.lineWidth = d.thickness)), "bottom" === this._position) {
                                var x = 1 == this.ctx.lineWidth % 2 ? .5 + (t.x << 0) : t.x << 0;
                                this.ctx.beginPath(), this.ctx.moveTo(x, t.y << 0), this.ctx.lineTo(x, t.y + this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (t.x -= e.textBlock.width / 2, t.y += this.tickLength + e.textBlock.fontSize / 2) : (t.x -= 0 > this.labelAngle ? e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0, t.y += this.tickLength + Math.abs(0 > this.labelAngle ? e.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) - 5 : 5))
                            } else "top" === this._position ? (x = 1 == this.ctx.lineWidth % 2 ? .5 + (t.x << 0) : t.x << 0, this.ctx.beginPath(), this.ctx.moveTo(x, t.y << 0), this.ctx.lineTo(x, t.y - this.tickLength << 0), this.ctx.stroke(), 0 === this.labelAngle ? (t.x -= e.textBlock.width / 2, t.y -= this.tickLength + e.textBlock.height) : (t.x += (e.textBlock.height - this.tickLength - this.labelFontSize / 2) * Math.sin(Math.PI / 180 * this.labelAngle) - (0 < this.labelAngle ? e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) : 0), t.y -= this.tickLength + (e.textBlock.height * Math.cos(Math.PI / 180 * this.labelAngle) + (0 < this.labelAngle ? e.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle) : 0)))) : "left" === this._position ? (x = 1 == this.ctx.lineWidth % 2 ? .5 + (t.y << 0) : t.y << 0, this.ctx.beginPath(), this.ctx.moveTo(t.x << 0, x), this.ctx.lineTo(t.x - this.tickLength << 0, x), this.ctx.stroke(), 0 === this.labelAngle ? t.x = t.x - e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : (t.y -= e.textBlock.width * Math.sin(Math.PI / 180 * this.labelAngle), t.x = 0 < this.labelAngle ? t.x - e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) - this.tickLength - 5 : t.x - e.textBlock.width * Math.cos(Math.PI / 180 * this.labelAngle) + (e.textBlock.height - e.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) - this.tickLength)) : "right" === this._position && (x = 1 == this.ctx.lineWidth % 2 ? .5 + (t.y << 0) : t.y << 0, this.ctx.beginPath(), this.ctx.moveTo(t.x << 0, x), this.ctx.lineTo(t.x + this.tickLength << 0, x), this.ctx.stroke(), 0 === this.labelAngle ? t.x = t.x + this.tickLength + 5 : (t.y = 0 > this.labelAngle ? t.y : t.y - (e.textBlock.height - e.textBlock.fontSize / 2 - 5) * Math.cos(Math.PI / 180 * this.labelAngle), t.x = 0 < this.labelAngle ? t.x + (e.textBlock.height - e.textBlock.fontSize / 2 - 5) * Math.sin(Math.PI / 180 * this.labelAngle) + this.tickLength : t.x + this.tickLength + 5));
                        else e.textBlock.angle = -90, "bottom" === this._position ? (e.textBlock.maxWidth = this.options.stripLines[a].labelMaxWidth ? this.options.stripLines[a].labelMaxWidth : this.chart.plotArea.height - 3, e.textBlock.measureText(), t.x - e.textBlock.height > this.chart.plotArea.x1 ? l(d.startValue) ? t.x -= e.textBlock.height - e.textBlock.fontSize / 2 : t.x -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3 : (e.textBlock.angle = 90, l(d.startValue) ? t.x += e.textBlock.height - e.textBlock.fontSize / 2 : t.x += e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3), t.y = -90 === e.textBlock.angle ? "near" === e.stripLine.labelAlign ? this.chart.plotArea.y2 - 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + e.textBlock.width) / 2 : this.chart.plotArea.y1 + e.textBlock.width + 3 : "near" === e.stripLine.labelAlign ? this.chart.plotArea.y2 - e.textBlock.width - 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - e.textBlock.width) / 2 : this.chart.plotArea.y1 + 3) : "top" === this._position ? (e.textBlock.maxWidth = this.options.stripLines[a].labelMaxWidth ? this.options.stripLines[a].labelMaxWidth : this.chart.plotArea.height - 3, e.textBlock.measureText(), t.x - e.textBlock.height > this.chart.plotArea.x1 ? l(d.startValue) ? t.x -= e.textBlock.height - e.textBlock.fontSize / 2 : t.x -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3 : (e.textBlock.angle = 90, l(d.startValue) ? t.x += e.textBlock.height - e.textBlock.fontSize / 2 : t.x += e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3), t.y = -90 === e.textBlock.angle ? "near" === e.stripLine.labelAlign ? this.chart.plotArea.y1 + e.textBlock.width + 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 + e.textBlock.width) / 2 : this.chart.plotArea.y2 - 3 : "near" === e.stripLine.labelAlign ? this.chart.plotArea.y1 + 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.y2 + this.chart.plotArea.y1 - e.textBlock.width) / 2 : this.chart.plotArea.y2 - e.textBlock.width - 3) : "left" === this._position ? (e.textBlock.maxWidth = this.options.stripLines[a].labelMaxWidth ? this.options.stripLines[a].labelMaxWidth : this.chart.plotArea.width - 3, e.textBlock.angle = 0, e.textBlock.measureText(), t.y - e.textBlock.height > this.chart.plotArea.y1 ? l(d.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize + 3 : t.y - e.textBlock.height < this.chart.plotArea.y2 ? t.y += e.textBlock.fontSize / 2 + 3 : l(d.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize + 3, t.x = "near" === e.stripLine.labelAlign ? this.chart.plotArea.x1 + 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - e.textBlock.width / 2 : this.chart.plotArea.x2 - e.textBlock.width - 3) : "right" === this._position && (e.textBlock.maxWidth = this.options.stripLines[a].labelMaxWidth ? this.options.stripLines[a].labelMaxWidth : this.chart.plotArea.width - 3, e.textBlock.angle = 0, e.textBlock.measureText(), t.y - +e.textBlock.height > this.chart.plotArea.y1 ? l(d.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 - 3 : t.y - e.textBlock.height < this.chart.plotArea.y2 ? t.y += e.textBlock.fontSize / 2 + 3 : l(d.startValue) ? t.y -= e.textBlock.height - e.textBlock.fontSize / 2 : t.y -= e.textBlock.height / 2 - e.textBlock.fontSize / 2 + 3, t.x = "near" === e.stripLine.labelAlign ? this.chart.plotArea.x2 - e.textBlock.width - 3 : "center" === e.stripLine.labelAlign ? (this.chart.plotArea.x2 + this.chart.plotArea.x1) / 2 - e.textBlock.width / 2 : this.chart.plotArea.x1 + 3);
                        e.textBlock.x = t.x, e.textBlock.y = t.y, h.push(e)
                    }
                if (!o) {
                    for (o = !1, this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), a = 0; a < r.length; a++)(d = r[a]).showOnTop ? n || (n = !0, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                        for (this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip(), s = 0; s < r.length; s++)(d = r[s]).showOnTop && d.render();
                        this.ctx.restore()
                    }, d)) : d.render();
                    for (a = 0; a < h.length; a++)(e = h[a]).stripLine.showOnTop ? o || (o = !0, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                        for (s = 0; s < h.length; s++) "inside" === (e = h[s]).stripLine.labelPlacement && e.stripLine.showOnTop && (i.ctx.save(), i.ctx.beginPath(), i.ctx.rect(i.chart.plotArea.x1, i.chart.plotArea.y1, i.chart.plotArea.width, i.chart.plotArea.height), i.ctx.clip(), e.textBlock.render(!0), i.ctx.restore())
                    }, e.textBlock)) : "inside" === e.stripLine.labelPlacement && e.textBlock.render(!0);
                    this.ctx.restore(), o = !0
                }
                if (o)
                    for (o = !1, a = 0; a < h.length; a++)(e = h[a]).stripLine.showOnTop ? o || (o = !0, this.chart.addEventListener("dataAnimationIterationEnd", function() {
                        for (s = 0; s < h.length; s++) "outside" === (e = h[s]).stripLine.labelPlacement && e.stripLine.showOnTop && e.textBlock.render(!0)
                    }, e.textBlock)) : "outside" === e.stripLine.labelPlacement && e.textBlock.render(!0)
            }
        }, W.prototype.renderBreaksBackground = function() {
            this.chart._breaksCanvas && this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length && this.maskCanvas && (this.chart._breaksCanvasCtx.save(), this.chart._breaksCanvasCtx.beginPath(), this.chart._breaksCanvasCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.chart._breaksCanvasCtx.clip(), this.chart._breaksCanvasCtx.drawImage(this.maskCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx.restore())
        }, W.prototype.createMask = function() {
            if (this.scaleBreaks && 0 < this.scaleBreaks._appliedBreaks.length) {
                var t = this.scaleBreaks._appliedBreaks;
                D ? (this.maskCanvas = m(this.chart.width, this.chart.height), this.maskCtx = this.maskCanvas.getContext("2d")) : (this.maskCanvas = this.chart.plotArea.canvas, this.maskCtx = this.chart.plotArea.ctx), this.maskCtx.save(), this.maskCtx.beginPath(), this.maskCtx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.maskCtx.clip();
                for (var e = 0; e < t.length; e++) t[e].endValue < this.viewportMinimum || t[e].startValue > this.viewportMaximum || isNaN(this.range) || t[e].render(this.maskCtx);
                this.maskCtx.restore()
            }
        }, W.prototype.renderCrosshair = function(t, e) {
            this.crosshair.render(t, e)
        }, W.prototype.renderGrid = function() {
            if (this.gridThickness && 0 < this.gridThickness) {
                var t = this.chart.ctx;
                t.save();
                var e, i = this.chart.plotArea;
                if (t.lineWidth = this.gridThickness, t.strokeStyle = this.gridColor, t.setLineDash && t.setLineDash(d(this.gridDashType, this.gridThickness)), "bottom" === this._position || "top" === this._position)
                    for (a = 0; a < this._labels.length; a++) this._labels[a].position < this.viewportMinimum || this._labels[a].position > this.viewportMaximum || this._labels[a].breaksLabelType || (t.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[a].position), e = 1 == t.lineWidth % 2 ? .5 + (e.x << 0) : e.x << 0, t.moveTo(e, i.y1 << 0), t.lineTo(e, i.y2 << 0), t.stroke());
                else if ("left" === this._position || "right" === this._position)
                    for (var a = 0; a < this._labels.length; a++) this._labels[a].position < this.viewportMinimum || this._labels[a].position > this.viewportMaximum || this._labels[a].breaksLabelType || (t.beginPath(), e = this.getPixelCoordinatesOnAxis(this._labels[a].position), e = 1 == t.lineWidth % 2 ? .5 + (e.y << 0) : e.y << 0, t.moveTo(i.x1 << 0, e), t.lineTo(i.x2 << 0, e), t.stroke());
                t.restore()
            }
        }, W.prototype.renderAxisLine = function() {
            var t, e, i = this.chart.ctx,
                a = D ? this.chart._preRenderCtx : i,
                s = Math.ceil(this.tickThickness / (this.reversed ? -2 : 2)),
                n = Math.ceil(this.tickThickness / (this.reversed ? 2 : -2));
            if (a.save(), "bottom" === this._position || "top" === this._position) {
                if (this.lineThickness) {
                    this.reversed ? (t = this.lineCoordinates.x2, e = this.lineCoordinates.x1) : (t = this.lineCoordinates.x1, e = this.lineCoordinates.x2), a.lineWidth = this.lineThickness, a.strokeStyle = this.lineColor ? this.lineColor : "black", a.setLineDash && a.setLineDash(d(this.lineDashType, this.lineThickness));
                    var o = 1 == this.lineThickness % 2 ? .5 + (this.lineCoordinates.y1 << 0) : this.lineCoordinates.y1 << 0;
                    if (a.beginPath(), this.scaleBreaks && !l(this.scaleBreaks.firstBreakIndex))
                        if (l(this.scaleBreaks.lastBreakIndex)) t = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + n;
                        else
                            for (var r = this.scaleBreaks.firstBreakIndex; r <= this.scaleBreaks.lastBreakIndex; r++) a.moveTo(t, o), a.lineTo(this.scaleBreaks._appliedBreaks[r].startPixel + s, o), t = this.scaleBreaks._appliedBreaks[r].endPixel + n;
                    t && (a.moveTo(t, o), a.lineTo(e, o)), a.stroke()
                }
            } else if (("left" === this._position || "right" === this._position) && this.lineThickness) {
                if (this.reversed ? (t = this.lineCoordinates.y1, e = this.lineCoordinates.y2) : (t = this.lineCoordinates.y2, e = this.lineCoordinates.y1), a.lineWidth = this.lineThickness, a.strokeStyle = this.lineColor, a.setLineDash && a.setLineDash(d(this.lineDashType, this.lineThickness)), o = 1 == this.lineThickness % 2 ? .5 + (this.lineCoordinates.x1 << 0) : this.lineCoordinates.x1 << 0, a.beginPath(), this.scaleBreaks && !l(this.scaleBreaks.firstBreakIndex))
                    if (l(this.scaleBreaks.lastBreakIndex)) t = this.scaleBreaks._appliedBreaks[this.scaleBreaks.firstBreakIndex].endPixel + s;
                    else
                        for (r = this.scaleBreaks.firstBreakIndex; r <= this.scaleBreaks.lastBreakIndex; r++) a.moveTo(o, t), a.lineTo(o, this.scaleBreaks._appliedBreaks[r].startPixel + n), t = this.scaleBreaks._appliedBreaks[r].endPixel + s;
                t && (a.moveTo(o, t), a.lineTo(o, e)), a.stroke()
            }
            D && (i.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), this.chart._breaksCanvasCtx && this.chart._breaksCanvasCtx.drawImage(this.chart._preRenderCanvas, 0, 0, this.chart.width, this.chart.height), a.clearRect(0, 0, this.chart.width, this.chart.height)), a.restore()
        }, W.prototype.getPixelCoordinatesOnAxis = function(t) {
            var e = {};
            return "bottom" !== this._position && "top" !== this._position || (e.x = this.convertValueToPixel(t), e.y = this.lineCoordinates.y1), "left" !== this._position && "right" !== this._position || (e.y = this.convertValueToPixel(t), e.x = this.lineCoordinates.x2), e
        }, W.prototype.convertPixelToValue = function(t) {
            if (void 0 === t) return null;
            var e, i = 0,
                a = 0,
                s = (i = !0, this.scaleBreaks ? this.scaleBreaks._appliedBreaks : []);
            a = "number" == typeof t ? t : "left" === this._position || "right" === this._position ? t.y : t.x;
            if (this.logarithmic) {
                if (t = e = Math.pow(this.logarithmBase, (a - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit), a <= this.conversionParameters.reference == ("left" === this._position || "right" === this._position) !== this.reversed) {
                    for (a = 0; a < s.length; a++)
                        if (!(s[a].endValue < this.conversionParameters.minimum))
                            if (i)
                                if (s[a].startValue < this.conversionParameters.minimum) {
                                    if (1 < s[a].size && this.conversionParameters.minimum * Math.pow(s[a].endValue / s[a].startValue, Math.log(e) / Math.log(s[a].size)) < s[a].endValue) {
                                        t = Math.pow(s[a].endValue / s[a].startValue, Math.log(e) / Math.log(s[a].size));
                                        break
                                    }
                                    t *= s[a].endValue / this.conversionParameters.minimum / Math.pow(s[a].size, Math.log(s[a].endValue / this.conversionParameters.minimum) / Math.log(s[a].endValue / s[a].startValue)), e /= Math.pow(s[a].size, Math.log(s[a].endValue / this.conversionParameters.minimum) / Math.log(s[a].endValue / s[a].startValue)), i = !1
                                } else {
                                    if (!(e > s[a].startValue / this.conversionParameters.minimum)) break;
                                    if ((e /= s[a].startValue / this.conversionParameters.minimum) < s[a].size) {
                                        t *= Math.pow(s[a].endValue / s[a].startValue, 1 === s[a].size ? 1 : Math.log(e) / Math.log(s[a].size)) / e;
                                        break
                                    }
                                    t *= s[a].endValue / s[a].startValue / s[a].size, e /= s[a].size, i = !1
                                } else {
                        if (!(e > s[a].startValue / s[a - 1].endValue)) break;
                        if ((e /= s[a].startValue / s[a - 1].endValue) < s[a].size) {
                            t *= Math.pow(s[a].endValue / s[a].startValue, 1 === s[a].size ? 1 : Math.log(e) / Math.log(s[a].size)) / e;
                            break
                        }
                        t *= s[a].endValue / s[a].startValue / s[a].size, e /= s[a].size
                    }
                } else
                    for (a = s.length - 1; 0 <= a; a--)
                        if (!(s[a].startValue > this.conversionParameters.minimum))
                            if (i)
                                if (s[a].endValue > this.conversionParameters.minimum) {
                                    if (1 < s[a].size && this.conversionParameters.minimum * Math.pow(s[a].endValue / s[a].startValue, Math.log(e) / Math.log(s[a].size)) > s[a].startValue) {
                                        t = Math.pow(s[a].endValue / s[a].startValue, Math.log(e) / Math.log(s[a].size));
                                        break
                                    }
                                    t *= s[a].startValue / this.conversionParameters.minimum * Math.pow(s[a].size, Math.log(s[a].startValue / this.conversionParameters.minimum) / Math.log(s[a].endValue / s[a].startValue)) * e, e *= Math.pow(s[a].size, Math.log(this.conversionParameters.minimum / s[a].startValue) / Math.log(s[a].endValue / s[a].startValue)), i = !1
                                } else {
                                    if (!(e < s[a].endValue / this.conversionParameters.minimum)) break;
                                    if ((e /= s[a].endValue / this.conversionParameters.minimum) > 1 / s[a].size) {
                                        t *= Math.pow(s[a].endValue / s[a].startValue, 1 >= s[a].size ? 1 : Math.log(e) / Math.log(s[a].size)) * e;
                                        break
                                    }
                                    t /= s[a].endValue / s[a].startValue / s[a].size, e *= s[a].size, i = !1
                                } else {
                    if (!(e < s[a].endValue / s[a + 1].startValue)) break;
                    if ((e /= s[a].endValue / s[a + 1].startValue) > 1 / s[a].size) {
                        t *= Math.pow(s[a].endValue / s[a].startValue, 1 >= s[a].size ? 1 : Math.log(e) / Math.log(s[a].size)) * e;
                        break
                    }
                    t /= s[a].endValue / s[a].startValue / s[a].size, e *= s[a].size
                }
                i = t * this.viewportMinimum
            } else {
                if (t = e = (a - this.conversionParameters.reference) / this.conversionParameters.pixelPerUnit, a <= this.conversionParameters.reference == ("left" === this._position || "right" === this._position) !== this.reversed) {
                    for (a = 0; a < s.length; a++)
                        if (!(s[a].endValue < this.conversionParameters.minimum))
                            if (i)
                                if (s[a].startValue < this.conversionParameters.minimum) {
                                    if (s[a].size && this.conversionParameters.minimum + e * (s[a].endValue - s[a].startValue) / s[a].size < s[a].endValue) {
                                        t = 0 >= s[a].size ? 0 : e * (s[a].endValue - s[a].startValue) / s[a].size;
                                        break
                                    }
                                    t += s[a].endValue - this.conversionParameters.minimum - s[a].size * (s[a].endValue - this.conversionParameters.minimum) / (s[a].endValue - s[a].startValue), e -= s[a].size * (s[a].endValue - this.conversionParameters.minimum) / (s[a].endValue - s[a].startValue), i = !1
                                } else {
                                    if (!(e > s[a].startValue - this.conversionParameters.minimum)) break;
                                    if ((e -= s[a].startValue - this.conversionParameters.minimum) < s[a].size) {
                                        t += (s[a].endValue - s[a].startValue) * (0 === s[a].size ? 1 : e / s[a].size) - e;
                                        break
                                    }
                                    t += s[a].endValue - s[a].startValue - s[a].size, e -= s[a].size, i = !1
                                } else {
                        if (!(e > s[a].startValue - s[a - 1].endValue)) break;
                        if ((e -= s[a].startValue - s[a - 1].endValue) < s[a].size) {
                            t += (s[a].endValue - s[a].startValue) * (0 === s[a].size ? 1 : e / s[a].size) - e;
                            break
                        }
                        t += s[a].endValue - s[a].startValue - s[a].size, e -= s[a].size
                    }
                } else
                    for (a = s.length - 1; 0 <= a; a--)
                        if (!(s[a].startValue > this.conversionParameters.minimum))
                            if (i)
                                if (s[a].endValue > this.conversionParameters.minimum) {
                                    if (s[a].size && this.conversionParameters.minimum + e * (s[a].endValue - s[a].startValue) / s[a].size > s[a].startValue) {
                                        t = 0 >= s[a].size ? 0 : e * (s[a].endValue - s[a].startValue) / s[a].size;
                                        break
                                    }
                                    t += s[a].startValue - this.conversionParameters.minimum + s[a].size * (this.conversionParameters.minimum - s[a].startValue) / (s[a].endValue - s[a].startValue), e += s[a].size * (this.conversionParameters.minimum - s[a].startValue) / (s[a].endValue - s[a].startValue), i = !1
                                } else {
                                    if (!(e < s[a].endValue - this.conversionParameters.minimum)) break;
                                    if ((e -= s[a].endValue - this.conversionParameters.minimum) > -1 * s[a].size) {
                                        t += (s[a].endValue - s[a].startValue) * (0 === s[a].size ? 1 : e / s[a].size) + e;
                                        break
                                    }
                                    t -= s[a].endValue - s[a].startValue - s[a].size, e += s[a].size, i = !1
                                } else {
                    if (!(e < s[a].endValue - s[a + 1].startValue)) break;
                    if ((e -= s[a].endValue - s[a + 1].startValue) > -1 * s[a].size) {
                        t += (s[a].endValue - s[a].startValue) * (0 === s[a].size ? 1 : e / s[a].size) + e;
                        break
                    }
                    t -= s[a].endValue - s[a].startValue - s[a].size, e += s[a].size
                }
                i = this.conversionParameters.minimum + t
            }
            return i
        }, W.prototype.convertValueToPixel = function(t) {
            return t = this.getApparentDifference(this.conversionParameters.minimum, t, t), this.logarithmic ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * Math.log(t / this.conversionParameters.minimum) / this.conversionParameters.lnLogarithmBase + .5 << 0 : "axisX" === this.type ? this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (t - this.conversionParameters.minimum) + .5 << 0 : this.conversionParameters.reference + this.conversionParameters.pixelPerUnit * (t - this.conversionParameters.minimum) + .5
        }, W.prototype.getApparentDifference = function(t, e, i, a) {
            var s = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            if (this.logarithmic) {
                i = l(i) ? e / t : i;
                for (var n = 0; n < s.length && !(e < s[n].startValue); n++) t > s[n].endValue || (t <= s[n].startValue && e >= s[n].endValue ? i = i / s[n].endValue * s[n].startValue * s[n].size : t >= s[n].startValue && e >= s[n].endValue ? i = i / s[n].endValue * t * Math.pow(s[n].size, Math.log(s[n].endValue / t) / Math.log(s[n].endValue / s[n].startValue)) : t <= s[n].startValue && e <= s[n].endValue ? i = i / e * s[n].startValue * Math.pow(s[n].size, Math.log(e / s[n].startValue) / Math.log(s[n].endValue / s[n].startValue)) : !a && t > s[n].startValue && e < s[n].endValue && (i = t * Math.pow(s[n].size, Math.log(e / t) / Math.log(s[n].endValue / s[n].startValue))))
            } else
                for (i = l(i) ? Math.abs(e - t) : i, n = 0; n < s.length && !(e < s[n].startValue); n++) t > s[n].endValue || (t <= s[n].startValue && e >= s[n].endValue ? i = i - s[n].endValue + s[n].startValue + s[n].size : t > s[n].startValue && e >= s[n].endValue ? i = i - s[n].endValue + t + s[n].size * (s[n].endValue - t) / (s[n].endValue - s[n].startValue) : t <= s[n].startValue && e < s[n].endValue ? i = i - e + s[n].startValue + s[n].size * (e - s[n].startValue) / (s[n].endValue - s[n].startValue) : !a && t > s[n].startValue && e < s[n].endValue && (i = t + s[n].size * (e - t) / (s[n].endValue - s[n].startValue)));
            return i
        }, W.prototype.setViewPortRange = function(t, e) {
            this.sessionVariables.newViewportMinimum = this.viewportMinimum = Math.min(t, e), this.sessionVariables.newViewportMaximum = this.viewportMaximum = Math.max(t, e)
        }, W.prototype.getXValueAt = function(t) {
            if (!t) return null;
            var e = null;
            return "left" === this._position ? e = this.convertPixelToValue(t.y) : "bottom" === this._position && (e = this.convertPixelToValue(t.x)), e
        }, W.prototype.calculateValueToPixelConversionParameters = function(t) {
            t = this.scaleBreaks ? this.scaleBreaks._appliedBreaks : [];
            var e = {
                    pixelPerUnit: null,
                    minimum: null,
                    reference: null
                },
                i = this.lineCoordinates.width,
                a = this.lineCoordinates.height;
            i = "bottom" === this._position || "top" === this._position ? i : a, a = Math.abs(this.range);
            if (this.logarithmic)
                for (var s = 0; s < t.length && !(this.viewportMaximum < t[s].startValue); s++) this.viewportMinimum > t[s].endValue || (this.viewportMinimum >= t[s].startValue && this.viewportMaximum <= t[s].endValue ? i = 0 : this.viewportMinimum <= t[s].startValue && this.viewportMaximum >= t[s].endValue ? (a = a / t[s].endValue * t[s].startValue, i = 0 < t[s].spacing.toString().indexOf("%") ? i * (1 - parseFloat(t[s].spacing) / 100) : i - Math.min(t[s].spacing, .1 * i)) : this.viewportMinimum > t[s].startValue && this.viewportMaximum >= t[s].endValue ? (a = a / t[s].endValue * this.viewportMinimum, i = 0 < t[s].spacing.toString().indexOf("%") ? i * (1 - parseFloat(t[s].spacing) / 100 * Math.log(t[s].endValue / this.viewportMinimum) / Math.log(t[s].endValue / t[s].startValue)) : i - Math.min(t[s].spacing, .1 * i) * Math.log(t[s].endValue / this.viewportMinimum) / Math.log(t[s].endValue / t[s].startValue)) : this.viewportMinimum <= t[s].startValue && this.viewportMaximum < t[s].endValue && (a = a / this.viewportMaximum * t[s].startValue, i = 0 < t[s].spacing.toString().indexOf("%") ? i * (1 - parseFloat(t[s].spacing) / 100 * Math.log(this.viewportMaximum / t[s].startValue) / Math.log(t[s].endValue / t[s].startValue)) : i - Math.min(t[s].spacing, .1 * i) * Math.log(this.viewportMaximum / t[s].startValue) / Math.log(t[s].endValue / t[s].startValue)));
            else
                for (s = 0; s < t.length && !(this.viewportMaximum < t[s].startValue); s++) this.viewportMinimum > t[s].endValue || (this.viewportMinimum >= t[s].startValue && this.viewportMaximum <= t[s].endValue ? i = 0 : this.viewportMinimum <= t[s].startValue && this.viewportMaximum >= t[s].endValue ? (a = a - t[s].endValue + t[s].startValue, i = 0 < t[s].spacing.toString().indexOf("%") ? i * (1 - parseFloat(t[s].spacing) / 100) : i - Math.min(t[s].spacing, .1 * i)) : this.viewportMinimum > t[s].startValue && this.viewportMaximum >= t[s].endValue ? (a = a - t[s].endValue + this.viewportMinimum, i = 0 < t[s].spacing.toString().indexOf("%") ? i * (1 - parseFloat(t[s].spacing) / 100 * (t[s].endValue - this.viewportMinimum) / (t[s].endValue - t[s].startValue)) : i - Math.min(t[s].spacing, .1 * i) * (t[s].endValue - this.viewportMinimum) / (t[s].endValue - t[s].startValue)) : this.viewportMinimum <= t[s].startValue && this.viewportMaximum < t[s].endValue && (a = a - this.viewportMaximum + t[s].startValue, i = 0 < t[s].spacing.toString().indexOf("%") ? i * (1 - parseFloat(t[s].spacing) / 100 * (this.viewportMaximum - t[s].startValue) / (t[s].endValue - t[s].startValue)) : i - Math.min(t[s].spacing, .1 * i) * (this.viewportMaximum - t[s].startValue) / (t[s].endValue - t[s].startValue)));
            e.minimum = this.viewportMinimum, e.maximum = this.viewportMaximum, e.range = a, "bottom" !== this._position && "top" !== this._position || (this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? -1 : 1) * i * e.lnLogarithmBase / Math.log(Math.abs(a))) : e.pixelPerUnit = (this.reversed ? -1 : 1) * i / Math.abs(a), e.reference = this.reversed ? this.lineCoordinates.x2 : this.lineCoordinates.x1), "left" !== this._position && "right" !== this._position || (this.logarithmic ? (e.lnLogarithmBase = Math.log(this.logarithmBase), e.pixelPerUnit = (this.reversed ? 1 : -1) * i * e.lnLogarithmBase / Math.log(Math.abs(a))) : e.pixelPerUnit = (this.reversed ? 1 : -1) * i / Math.abs(a), e.reference = this.reversed ? this.lineCoordinates.y1 : this.lineCoordinates.y2), this.conversionParameters = e
        }, W.prototype.calculateAxisParameters = function() {
            if (this.logarithmic) this.calculateLogarithmicAxisParameters();
            else {
                var t = this.chart.layoutManager.getFreeSpace(),
                    e = !1,
                    i = !1;
                "bottom" === this._position || "top" === this._position ? (this.maxWidth = t.width, this.maxHeight = t.height) : (this.maxWidth = t.height, this.maxHeight = t.width);
                t = "axisX" === this.type ? "xySwapped" === this.chart.plotInfo.axisPlacement ? 62 : 70 : "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 : 40;
                var a = 4;
                "axisX" === this.type && (a = 600 > this.maxWidth ? 8 : 6);
                var s, n, o;
                t = Math.max(a, Math.floor(this.maxWidth / t)), a = 0;
                if (!l(this.options.viewportMinimum) && !l(this.options.viewportMaximum) && this.options.viewportMinimum >= this.options.viewportMaximum && (this.viewportMinimum = this.viewportMaximum = null), !l(this.options.viewportMinimum) || l(this.sessionVariables.newViewportMinimum) || isNaN(this.sessionVariables.newViewportMinimum) ? (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum) : this.viewportMinimum = this.sessionVariables.newViewportMinimum, !l(this.options.viewportMaximum) || l(this.sessionVariables.newViewportMaximum) || isNaN(this.sessionVariables.newViewportMaximum) ? (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum) : this.viewportMaximum = this.sessionVariables.newViewportMaximum, this.scaleBreaks)
                    for (a = 0; a < this.scaleBreaks._appliedBreaks.length; a++)
                        if ((!l(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[a].startValue || !l(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[a].startValue || !l(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[a].startValue) && (!l(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[a].endValue || !l(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[a].endValue || !l(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[a].endValue)) {
                            this.scaleBreaks._appliedBreaks.splice(a, 1);
                            break
                        }
                if ("axisX" === this.type) {
                    if (this.dataSeries && 0 < this.dataSeries.length)
                        for (s = 0; s < this.dataSeries.length; s++) "dateTime" === this.dataSeries[s].xValueType && (i = !0);
                    s = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 0 == (n = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax) - s && (n += a = void 0 === this.options.interval ? .4 : this.options.interval, s -= a), 1 / 0 !== this.dataInfo.minDiff ? o = this.dataInfo.minDiff : 1 < n - s ? o = .5 * Math.abs(n - s) : (o = 1, i && (e = !0))
                } else "axisY" === this.type && (s = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, n = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, isFinite(s) || isFinite(n) ? isFinite(s) ? isFinite(n) || (n = s) : s = n : (n = void 0 === this.options.interval ? -1 / 0 : this.options.interval, s = void 0 !== this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : 1 / 0), 0 === s && 0 === n ? (n += 9, s = 0) : 0 == n - s ? (n += a = Math.min(Math.abs(.01 * Math.abs(n)), 5), s -= a) : s > n ? (a = Math.min(.01 * Math.abs(this.getApparentDifference(n, s, null, !0)), 5), 0 <= n ? s = n - a : n = isFinite(s) ? s + a : 0) : (a = Math.min(.01 * Math.abs(this.getApparentDifference(s, n, null, !0)), .05), 0 !== n && (n += a), 0 !== s && (s -= a)), o = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < n - s ? .5 * Math.abs(n - s) : 1, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 0 < s && (s = 0), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 0 > n && (n = 0));
                a = this.getApparentDifference(isNaN(this.viewportMinimum) || null === this.viewportMinimum ? s : this.viewportMinimum, isNaN(this.viewportMaximum) || null === this.viewportMaximum ? n : this.viewportMaximum, null, !0), "axisX" === this.type && i ? (this.intervalType || (a / 1 <= t ? (this.interval = 1, this.intervalType = "millisecond") : a / 2 <= t ? (this.interval = 2, this.intervalType = "millisecond") : a / 5 <= t ? (this.interval = 5, this.intervalType = "millisecond") : a / 10 <= t ? (this.interval = 10, this.intervalType = "millisecond") : a / 20 <= t ? (this.interval = 20, this.intervalType = "millisecond") : a / 50 <= t ? (this.interval = 50, this.intervalType = "millisecond") : a / 100 <= t ? (this.interval = 100, this.intervalType = "millisecond") : a / 200 <= t ? (this.interval = 200, this.intervalType = "millisecond") : a / 250 <= t ? (this.interval = 250, this.intervalType = "millisecond") : a / 300 <= t ? (this.interval = 300, this.intervalType = "millisecond") : a / 400 <= t ? (this.interval = 400, this.intervalType = "millisecond") : a / 500 <= t ? (this.interval = 500, this.intervalType = "millisecond") : a / (1 * U.secondDuration) <= t ? (this.interval = 1, this.intervalType = "second") : a / (2 * U.secondDuration) <= t ? (this.interval = 2, this.intervalType = "second") : a / (5 * U.secondDuration) <= t ? (this.interval = 5, this.intervalType = "second") : a / (10 * U.secondDuration) <= t ? (this.interval = 10, this.intervalType = "second") : a / (15 * U.secondDuration) <= t ? (this.interval = 15, this.intervalType = "second") : a / (20 * U.secondDuration) <= t ? (this.interval = 20, this.intervalType = "second") : a / (30 * U.secondDuration) <= t ? (this.interval = 30, this.intervalType = "second") : a / (1 * U.minuteDuration) <= t ? (this.interval = 1, this.intervalType = "minute") : a / (2 * U.minuteDuration) <= t ? (this.interval = 2, this.intervalType = "minute") : a / (5 * U.minuteDuration) <= t ? (this.interval = 5, this.intervalType = "minute") : a / (10 * U.minuteDuration) <= t ? (this.interval = 10, this.intervalType = "minute") : a / (15 * U.minuteDuration) <= t ? (this.interval = 15, this.intervalType = "minute") : a / (20 * U.minuteDuration) <= t ? (this.interval = 20, this.intervalType = "minute") : a / (30 * U.minuteDuration) <= t ? (this.interval = 30, this.intervalType = "minute") : a / (1 * U.hourDuration) <= t ? (this.interval = 1, this.intervalType = "hour") : a / (2 * U.hourDuration) <= t ? (this.interval = 2, this.intervalType = "hour") : a / (3 * U.hourDuration) <= t ? (this.interval = 3, this.intervalType = "hour") : a / (6 * U.hourDuration) <= t ? (this.interval = 6, this.intervalType = "hour") : a / (1 * U.dayDuration) <= t ? (this.interval = 1, this.intervalType = "day") : a / (2 * U.dayDuration) <= t ? (this.interval = 2, this.intervalType = "day") : a / (4 * U.dayDuration) <= t ? (this.interval = 4, this.intervalType = "day") : a / (1 * U.weekDuration) <= t ? (this.interval = 1, this.intervalType = "week") : a / (2 * U.weekDuration) <= t ? (this.interval = 2, this.intervalType = "week") : a / (3 * U.weekDuration) <= t ? (this.interval = 3, this.intervalType = "week") : a / (1 * U.monthDuration) <= t ? (this.interval = 1, this.intervalType = "month") : a / (2 * U.monthDuration) <= t ? (this.interval = 2, this.intervalType = "month") : a / (3 * U.monthDuration) <= t ? (this.interval = 3, this.intervalType = "month") : a / (6 * U.monthDuration) <= t ? (this.interval = 6, this.intervalType = "month") : (this.interval = a / (1 * U.yearDuration) <= t ? 1 : a / (2 * U.yearDuration) <= t ? 2 : a / (4 * U.yearDuration) <= t ? 4 : Math.floor(W.getNiceNumber(a / (t - 1), !0) / U.yearDuration), this.intervalType = "year")), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = s - o / 2), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = n + o / 2), e ? this.autoValueFormatString = "MMM DD YYYY HH:mm" : "year" === this.intervalType ? this.autoValueFormatString = "YYYY" : "month" === this.intervalType ? this.autoValueFormatString = "MMM YYYY" : "week" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "day" === this.intervalType ? this.autoValueFormatString = "MMM DD YYYY" : "hour" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "minute" === this.intervalType ? this.autoValueFormatString = "hh:mm TT" : "second" === this.intervalType ? this.autoValueFormatString = "hh:mm:ss TT" : "millisecond" === this.intervalType && (this.autoValueFormatString = "fff'ms'"), this.valueFormatString || (this.valueFormatString = this.autoValueFormatString)) : (this.intervalType = "number", a = W.getNiceNumber(a, !1), this.interval = this.options && 0 < this.options.interval ? this.options.interval : W.getNiceNumber(a / (t - 1), !0), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? s - o / 2 : Math.floor(s / this.interval) * this.interval), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? n + o / 2 : Math.ceil(n / this.interval) * this.interval), 0 === this.viewportMaximum && 0 === this.viewportMinimum && (0 === this.options.viewportMinimum ? this.viewportMaximum += 10 : 0 === this.options.viewportMaximum && (this.viewportMinimum -= 10), this.options && void 0 === this.options.interval && (this.interval = W.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (t - 1), !0)))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (s = null !== this.minimum ? this.minimum : this.dataInfo.min, 0 == (n = null !== this.maximum ? this.maximum : this.dataInfo.max) - s && (n += a = void 0 === this.options.interval ? .4 : this.options.interval, s -= a), o = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < n - s ? .5 * Math.abs(n - s) : 1) : "axisY" === this.type && (s = null !== this.minimum ? this.minimum : this.dataInfo.min, n = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(s) || isFinite(n) ? 0 === s && 0 === n ? (n += 9, s = 0) : 0 == n - s ? (n += a = Math.min(Math.abs(.01 * Math.abs(n)), 5), s -= a) : s > n ? (a = Math.min(.01 * Math.abs(this.getApparentDifference(n, s, null, !0)), 5), 0 <= n ? s = n - a : n = isFinite(s) ? s + a : 0) : (a = Math.min(.01 * Math.abs(this.getApparentDifference(s, n, null, !0)), .05), 0 !== n && (n += a), 0 !== s && (s -= a)) : (n = void 0 === this.options.interval ? -1 / 0 : this.options.interval, s = void 0 !== this.options.interval || isFinite(this.dataInfo.minDiff) ? 0 : 1 / 0), o = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : 1 < n - s ? .5 * Math.abs(n - s) : 1, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 0 < s && (s = 0), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 0 > n && (n = 0)), Math.abs(this.getApparentDifference(s, n, null, !0)), "axisX" === this.type && i ? (this.valueType = "dateTime", (null === this.minimum || isNaN(this.minimum)) && (this.minimum = s - o / 2), (null === this.maximum || isNaN(this.maximum)) && (this.maximum = n + o / 2)) : (this.intervalType = this.valueType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? s - o / 2 : Math.floor(s / this.interval) * this.interval, this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? 1 / 0 : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? n + o / 2 : Math.ceil(n / this.interval) * this.interval, this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? -1 / 0 : this.sessionVariables.viewportMaximum)), 0 === this.maximum && 0 === this.minimum && (0 === this.options.minimum ? this.maximum += 10 : 0 === this.options.maximum && (this.minimum -= 10)))), l(this.sessionVariables.newViewportMinimum) && (this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum)), l(this.sessionVariables.newViewportMaximum) && (this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum)), this.range = this.viewportMaximum - this.viewportMinimum, this.intervalStartPosition = "axisX" === this.type && i ? this.getLabelStartPoint(new Date(this.viewportMinimum), this.intervalType, this.interval) : Math.floor((this.viewportMinimum + .2 * this.interval) / this.interval) * this.interval, this.valueFormatString || (this.valueFormatString = W.generateValueFormatString(this.range, 2))
            }
        }, W.prototype.calculateLogarithmicAxisParameters = function() {
            var t, e = this.chart.layoutManager.getFreeSpace(),
                i = Math.log(this.logarithmBase);
            "bottom" === this._position || "top" === this._position ? (this.maxWidth = e.width, this.maxHeight = e.height) : (this.maxWidth = e.height, this.maxHeight = e.width);
            var a, s, n, o;
            e = "axisX" === this.type ? 500 > this.maxWidth ? 7 : Math.max(7, Math.floor(this.maxWidth / 100)) : Math.max(Math.floor(this.maxWidth / 50), 3);
            if (o = 1, (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = this.minimum), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = this.maximum), this.scaleBreaks)
                for (o = 0; o < this.scaleBreaks._appliedBreaks.length; o++)
                    if ((!l(this.sessionVariables.newViewportMinimum) && this.sessionVariables.newViewportMinimum >= this.scaleBreaks._appliedBreaks[o].startValue || !l(this.options.minimum) && this.options.minimum >= this.scaleBreaks._appliedBreaks[o].startValue || !l(this.options.viewportMinimum) && this.viewportMinimum >= this.scaleBreaks._appliedBreaks[o].startValue) && (!l(this.sessionVariables.newViewportMaximum) && this.sessionVariables.newViewportMaximum <= this.scaleBreaks._appliedBreaks[o].endValue || !l(this.options.maximum) && this.options.maximum <= this.scaleBreaks._appliedBreaks[o].endValue || !l(this.options.viewportMaximum) && this.viewportMaximum <= this.scaleBreaks._appliedBreaks[o].endValue)) {
                        this.scaleBreaks._appliedBreaks.splice(o, 1);
                        break
                    }
                    "axisX" === this.type ? (a = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, 1 == (s = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax) / a && (s *= o = Math.pow(this.logarithmBase, void 0 === this.options.interval ? .4 : this.options.interval), a /= o), n = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : s / a > this.logarithmBase ? s / a * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (a = null !== this.viewportMinimum ? this.viewportMinimum : this.dataInfo.viewPortMin, s = null !== this.viewportMaximum ? this.viewportMaximum : this.dataInfo.viewPortMax, 0 >= a && !isFinite(s) ? (s = void 0 === this.options.interval ? 0 : this.options.interval, a = 1) : 0 >= a ? a = s : isFinite(s) || (s = a), 1 === a && 1 === s ? (s *= this.logarithmBase - 1 / this.logarithmBase, a = 1) : 1 == s / a ? (s *= o = Math.min(s * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), a /= o) : a > s ? (o = Math.min(a / s * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, 5)), 1 <= s ? a = s / o : s = a * o) : (o = Math.min(s / a * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== s && (s *= o), 1 !== a && (a /= o)), n = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : s / a > this.logarithmBase ? s / a * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && 1 < a && (a = 1), this.includeZero && (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && 1 > s && (s = 1)), o = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? s : this.viewportMaximum) / (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? a : this.viewportMinimum);
            var r = (isNaN(this.viewportMaximum) || null === this.viewportMaximum ? s : this.viewportMaximum) - (isNaN(this.viewportMinimum) || null === this.viewportMinimum ? a : this.viewportMinimum);
            if (this.intervalType = "number", o = Math.pow(this.logarithmBase, W.getNiceNumber(Math.abs(Math.log(o) / i), !1)), this.options && 0 < this.options.interval ? this.interval = this.options.interval : (this.interval = W.getNiceExponent(Math.log(o) / i / (e - 1), !0), t = W.getNiceNumber(r / (e - 1), !0)), (null === this.viewportMinimum || isNaN(this.viewportMinimum)) && (this.viewportMinimum = "axisX" === this.type ? a / Math.sqrt(n) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(a) / i / this.interval))), (null === this.viewportMaximum || isNaN(this.viewportMaximum)) && (this.viewportMaximum = "axisX" === this.type ? s * Math.sqrt(n) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(s) / i / this.interval))), 1 === this.viewportMaximum && 1 === this.viewportMinimum && (1 === this.options.viewportMinimum ? this.viewportMaximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.viewportMaximum && (this.viewportMinimum /= this.logarithmBase - 1 / this.logarithmBase), this.options && void 0 === this.options.interval && (this.interval = W.getNiceExponent(Math.ceil(Math.log(o) / i) / (e - 1)), t = W.getNiceNumber((this.viewportMaximum - this.viewportMinimum) / (e - 1), !0))), null !== this.minimum && null !== this.maximum || ("axisX" === this.type ? (a = null !== this.minimum ? this.minimum : this.dataInfo.min, 1 == (s = null !== this.maximum ? this.maximum : this.dataInfo.max) / a && (s *= o = Math.pow(this.logarithmBase, void 0 === this.options.interval ? .4 : this.options.interval), a /= o), n = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : s / a > this.logarithmBase ? s / a * Math.pow(this.logarithmBase, .5) : this.logarithmBase) : "axisY" === this.type && (a = null !== this.minimum ? this.minimum : this.dataInfo.min, s = null !== this.maximum ? this.maximum : this.dataInfo.max, isFinite(a) || isFinite(s) ? 1 === a && 1 === s ? (s *= this.logarithmBase, a /= this.logarithmBase) : 1 == s / a ? (s *= o = Math.pow(this.logarithmBase, this.interval), a /= o) : a > s ? (o = Math.min(a / s * .01, 5), 1 <= s ? a = s / o : s = a * o) : (o = Math.min(s / a * Math.pow(this.logarithmBase, .01), Math.pow(this.logarithmBase, .04)), 1 !== s && (s *= o), 1 !== a && (a /= o)) : (s = void 0 === this.options.interval ? 0 : this.options.interval, a = 1), n = 1 / 0 !== this.dataInfo.minDiff ? this.dataInfo.minDiff : s / a > this.logarithmBase ? s / a * Math.pow(this.logarithmBase, .5) : this.logarithmBase, this.includeZero && (null === this.minimum || isNaN(this.minimum)) && 1 < a && (a = 1), this.includeZero && (null === this.maximum || isNaN(this.maximum)) && 1 > s && (s = 1)), this.intervalType = "number", null === this.minimum && (this.minimum = "axisX" === this.type ? a / Math.sqrt(n) : Math.pow(this.logarithmBase, this.interval * Math.floor(Math.log(a) / i / this.interval)), this.minimum = Math.min(this.minimum, null === this.sessionVariables.viewportMinimum || isNaN(this.sessionVariables.viewportMinimum) ? void 0 === this.sessionVariables.newViewportMinimum ? 1 / 0 : this.sessionVariables.newViewportMinimum : this.sessionVariables.viewportMinimum)), null === this.maximum && (this.maximum = "axisX" === this.type ? s * Math.sqrt(n) : Math.pow(this.logarithmBase, this.interval * Math.ceil(Math.log(s) / i / this.interval)), this.maximum = Math.max(this.maximum, null === this.sessionVariables.viewportMaximum || isNaN(this.sessionVariables.viewportMaximum) ? void 0 === this.sessionVariables.newViewportMaximum ? 0 : this.sessionVariables.newViewportMaximum : this.sessionVariables.viewportMaximum)), 1 === this.maximum && 1 === this.minimum && (1 === this.options.minimum ? this.maximum *= this.logarithmBase - 1 / this.logarithmBase : 1 === this.options.maximum && (this.minimum /= this.logarithmBase - 1 / this.logarithmBase))), this.viewportMinimum = Math.max(this.viewportMinimum, this.minimum), this.viewportMaximum = Math.min(this.viewportMaximum, this.maximum), this.viewportMinimum > this.viewportMaximum && (!this.options.viewportMinimum && !this.options.minimum || this.options.viewportMaximum || this.options.maximum ? this.options.viewportMinimum || this.options.minimum || !this.options.viewportMaximum && !this.options.maximum || (this.viewportMinimum = this.minimum = (this.options.viewportMaximum || this.options.maximum) / Math.pow(this.logarithmBase, 2 * Math.ceil(this.interval))) : this.viewportMaximum = this.maximum = this.options.viewportMinimum || this.options.minimum), a = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (i * this.interval) + .2) * this.interval), this.range = this.viewportMaximum / this.viewportMinimum, this.noTicks = e, !this.options.interval && this.range < Math.pow(this.logarithmBase, 8 > this.viewportMaximum || 3 > e ? 2 : 3)) {
                for (i = Math.floor(this.viewportMinimum / t + .5) * t; i < this.viewportMinimum;) i += t;
                this.equidistantInterval = !1, this.intervalStartPosition = i, this.interval = t
            } else this.options.interval || (t = Math.ceil(this.interval), this.range > this.interval && (this.interval = t, a = Math.pow(this.logarithmBase, Math.floor(Math.log(this.viewportMinimum) / (i * this.interval) + .2) * this.interval))), this.equidistantInterval = !0, this.intervalStartPosition = a;
            if (!this.valueFormatString && (this.valueFormatString = "#,##0.##", 1 > this.viewportMinimum) && (i = Math.floor(Math.abs(Math.log(this.viewportMinimum) / Math.LN10)) + 2, !isNaN(i) && isFinite(i) || (i = 2), 2 < i))
                for (o = 0; o < i - 2; o++) this.valueFormatString += "#"
        }, W.generateValueFormatString = function(t, e) {
            var i = "#,##0.",
                a = e;
            1 > t && (a += Math.floor(Math.abs(Math.log(t) / Math.LN10)), isNaN(a) || !isFinite(a)) && (a = e);
            for (var s = 0; s < a; s++) i += "#";
            return i
        }, W.getNiceExponent = function(t, e) {
            var i = Math.floor(Math.log(t) / Math.LN10),
                a = t / Math.pow(10, i);
            a = 0 > i ? 1 >= a ? 1 : 5 >= a ? 5 : 10 : Math.max(Math.floor(a), 1);
            return -20 > i ? Number(a * Math.pow(10, i)) : Number((a * Math.pow(10, i)).toFixed(20))
        }, W.getNiceNumber = function(t, e) {
            var i = Math.floor(Math.log(t) / Math.LN10),
                a = t / Math.pow(10, i);
            a = e ? 1.5 > a ? 1 : 3 > a ? 2 : 7 > a ? 5 : 10 : 1 >= a ? 1 : 2 >= a ? 2 : 5 >= a ? 5 : 10;
            return -20 > i ? Number(a * Math.pow(10, i)) : Number((a * Math.pow(10, i)).toFixed(20))
        }, W.prototype.getLabelStartPoint = function() {
            var t = U[this.intervalType + "Duration"] * this.interval;
            t = new Date(Math.floor(this.viewportMinimum / t) * t);
            return "millisecond" !== this.intervalType && ("second" === this.intervalType ? 0 < t.getMilliseconds() && (t.setSeconds(t.getSeconds() + 1), t.setMilliseconds(0)) : "minute" === this.intervalType ? (0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setMinutes(t.getMinutes() + 1), t.setSeconds(0), t.setMilliseconds(0)) : "hour" === this.intervalType ? (0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setHours(t.getHours() + 1), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "day" === this.intervalType ? (0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setDate(t.getDate() + 1), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "week" === this.intervalType ? (0 < t.getDay() || 0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setDate(t.getDate() + (7 - t.getDay())), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "month" === this.intervalType ? (1 < t.getDate() || 0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setMonth(t.getMonth() + 1), t.setDate(1), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0)) : "year" === this.intervalType && (0 < t.getMonth() || 1 < t.getDate() || 0 < t.getHours() || 0 < t.getMinutes() || 0 < t.getSeconds() || 0 < t.getMilliseconds()) && (t.setFullYear(t.getFullYear() + 1), t.setMonth(0), t.setDate(1), t.setHours(0), t.setMinutes(0), t.setSeconds(0), t.setMilliseconds(0))), t
        }, t(z, f), t(X, f), X.prototype.createUserOptions = function(t) {
            if (void 0 !== t || this.options._isPlaceholder) {
                var e = 0;
                this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.options._isPlaceholder || (r(this.parent[this.optionsName]), e = this.parent.options[this.optionsName].indexOf(this.options)), this.options = void 0 === t ? {} : t, this.parent.options[this.optionsName][e] = this.options
            }
        }, X.prototype.render = function(t) {
            if (0 !== this.spacing || 0 !== this.options.lineThickness && (void 0 !== this.options.lineThickness || 0 !== this.parent.lineThickness)) {
                var e = this.ctx,
                    i = this.ctx.globalAlpha;
                this.ctx = t || this.ctx, this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(this.chart.plotArea.x1, this.chart.plotArea.y1, this.chart.plotArea.width, this.chart.plotArea.height), this.ctx.clip();
                var a, s, n, o, l, r, h = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.startValue),
                    x = this.scaleBreaks.parent.getPixelCoordinatesOnAxis(this.endValue);
                this.ctx.strokeStyle = this.lineColor, this.ctx.fillStyle = this.color, this.ctx.beginPath(), this.ctx.globalAlpha = 1, this.id, t = Math.max(this.spacing, 3);
                var c = Math.max(0, this.lineThickness);
                if (this.ctx.lineWidth = c, this.ctx.setLineDash && this.ctx.setLineDash(d(this.lineDashType, c)), "bottom" === this.scaleBreaks.parent._position || "top" === this.scaleBreaks.parent._position) {
                    if (h = 1 == c % 2 ? .5 + (h.x << 0) : h.x << 0, s = 1 == c % 2 ? .5 + (x.x << 0) : x.x << 0, "top" === this.scaleBreaks.parent._position ? (x = this.chart.plotArea.y1, n = this.chart.plotArea.y2 + c / 2 + .5 << 0) : (x = this.chart.plotArea.y2, n = this.chart.plotArea.y1 - c / 2 + .5 << 0, t *= -1), this.bounds = {
                            x1: h - c / 2,
                            y1: x,
                            x2: s + c / 2,
                            y2: n
                        }, this.ctx.moveTo(h, x), "straight" === this.type || "top" === this.scaleBreaks.parent._position && 0 >= t || "bottom" === this.scaleBreaks.parent._position && 0 <= t) this.ctx.lineTo(h, n), this.ctx.lineTo(s, n), this.ctx.lineTo(s, x);
                    else if ("wavy" === this.type) {
                        o = h, a = .5, r = (n - (l = x)) / t / 3;
                        for (var p = 0; p < r; p++) this.ctx.bezierCurveTo(o + a * t, l + t, o + a * t, l + 2 * t, o, l + 3 * t), l += 3 * t, a *= -1;
                        for (this.ctx.bezierCurveTo(o + a * t, l + t, o + a * t, l + 2 * t, o, l + 3 * t), o = s, a *= -1, this.ctx.lineTo(o, l), p = 0; p < r; p++) this.ctx.bezierCurveTo(o + a * t, l - t, o + a * t, l - 2 * t, o, l - 3 * t), l -= 3 * t, a *= -1
                    } else if ("zigzag" === this.type) {
                        for (a = -1, o = h + t, r = (n - (l = x + t)) / t / 2, p = 0; p < r; p++) this.ctx.lineTo(o, l), o += 2 * a * t, l += 2 * t, a *= -1;
                        for (this.ctx.lineTo(o, l), o += s - h, p = 0; p < r + 1; p++) this.ctx.lineTo(o, l), o += 2 * a * t, l -= 2 * t, a *= -1;
                        this.ctx.lineTo(o + a * t, l + t)
                    }
                } else if ("left" === this.scaleBreaks.parent._position || "right" === this.scaleBreaks.parent._position)
                    if (x = 1 == c % 2 ? .5 + (x.y << 0) : x.y << 0, n = 1 == c % 2 ? .5 + (h.y << 0) : h.y << 0, "left" === this.scaleBreaks.parent._position ? (h = this.chart.plotArea.x1, s = this.chart.plotArea.x2 + c / 2 + .5 << 0) : (h = this.chart.plotArea.x2, s = this.chart.plotArea.x1 - c / 2 + .5 << 0, t *= -1), this.bounds = {
                            x1: h,
                            y1: x - c / 2,
                            x2: s,
                            y2: n + c / 2
                        }, this.ctx.moveTo(h, x), "straight" === this.type || "left" === this.scaleBreaks.parent._position && 0 >= t || "right" === this.scaleBreaks.parent._position && 0 <= t) this.ctx.lineTo(s, x), this.ctx.lineTo(s, n), this.ctx.lineTo(h, n);
                    else if ("wavy" === this.type) {
                    for (l = x, a = .5, r = (s - (o = h)) / t / 3, p = 0; p < r; p++) this.ctx.bezierCurveTo(o + t, l + a * t, o + 2 * t, l + a * t, o + 3 * t, l), o += 3 * t, a *= -1;
                    for (this.ctx.bezierCurveTo(o + t, l + a * t, o + 2 * t, l + a * t, o + 3 * t, l), l = n, a *= -1, this.ctx.lineTo(o, l), p = 0; p < r; p++) this.ctx.bezierCurveTo(o - t, l + a * t, o - 2 * t, l + a * t, o - 3 * t, l), o -= 3 * t, a *= -1
                } else if ("zigzag" === this.type) {
                    for (a = 1, l = x - t, r = (s - (o = h + t)) / t / 2, p = 0; p < r; p++) this.ctx.lineTo(o, l), l += 2 * a * t, o += 2 * t, a *= -1;
                    for (this.ctx.lineTo(o, l), l += n - x, p = 0; p < r + 1; p++) this.ctx.lineTo(o, l), l += 2 * a * t, o -= 2 * t, a *= -1;
                    this.ctx.lineTo(o + t, l + a * t)
                }
                0 < c && this.ctx.stroke(), this.ctx.closePath(), this.ctx.globalAlpha = this.fillOpacity, this.ctx.globalCompositeOperation = "destination-over", this.ctx.fill(), this.ctx.restore(), this.ctx.globalAlpha = i, this.ctx = e
            }
        }, t(Y, f), Y.prototype.createUserOptions = function(t) {
            if (void 0 !== t || this.options._isPlaceholder) {
                var e = 0;
                this.parent.options._isPlaceholder && this.parent.createUserOptions(), this.options._isPlaceholder || (r(this.parent.stripLines), e = this.parent.options.stripLines.indexOf(this.options)), this.options = void 0 === t ? {} : t, this.parent.options.stripLines[e] = this.options
            }
        }, Y.prototype.render = function() {
            this.ctx.save();
            var t = this.parent.getPixelCoordinatesOnAxis(this.value),
                e = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);
            if (0 < e) {
                var i = null === this.opacity ? 1 : this.opacity;
                this.ctx.strokeStyle = this.color, this.ctx.beginPath();
                var a, s, n, o, l = this.ctx.globalAlpha;
                this.ctx.globalAlpha = i, this.id, this.ctx.lineWidth = e, this.ctx.setLineDash && this.ctx.setLineDash(d(this.lineDashType, e)), "bottom" === this.parent._position || "top" === this.parent._position ? (a = s = 1 == this.ctx.lineWidth % 2 ? .5 + (t.x << 0) : t.x << 0, n = this.chart.plotArea.y1, o = this.chart.plotArea.y2, this.bounds = {
                    x1: a - e / 2,
                    y1: n,
                    x2: s + e / 2,
                    y2: o
                }) : "left" !== this.parent._position && "right" !== this.parent._position || (n = o = 1 == this.ctx.lineWidth % 2 ? .5 + (t.y << 0) : t.y << 0, a = this.chart.plotArea.x1, s = this.chart.plotArea.x2, this.bounds = {
                    x1: a,
                    y1: n - e / 2,
                    x2: s,
                    y2: o + e / 2
                }), this.ctx.moveTo(a, n), this.ctx.lineTo(s, o), this.ctx.stroke(), this.ctx.globalAlpha = l
            }
            this.ctx.restore()
        }, t(O, f), O.prototype.render = function(t, e) {
            var i, a, s, n, o = null,
                r = o = null,
                h = "";
            if (!this.valueFormatString)
                if ("dateTime" === this.parent.valueType) this.valueFormatString = this.parent.valueFormatString;
                else {
                    var x = 0;
                    x = "xySwapped" === this.chart.plotInfo.axisPlacement ? 50 < this.parent.range ? 0 : 500 < this.chart.width && 25 > this.parent.range ? 2 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0) : 50 < this.parent.range ? 0 : Math.floor(Math.abs(Math.log(this.parent.range) / Math.LN10)) + (5 > this.parent.range ? 2 : 10 > this.parent.range ? 1 : 0);
                    this.valueFormatString = W.generateValueFormatString(this.parent.range, x)
                }
            r = null === this.opacity ? 1 : this.opacity, x = Math.abs("pixel" === this._thicknessType ? this.thickness : this.parent.conversionParameters.pixelPerUnit * this.thickness);
            var c = this.chart.overlaidCanvasCtx,
                p = c.globalAlpha;
            if (c.globalAlpha = r, c.beginPath(), c.strokeStyle = this.color, c.lineWidth = x, c.save(), this.labelFontSize = l(this.options.labelFontSize) ? this.parent.labelFontSize : this.labelFontSize, "left" === this.parent._position || "right" === this.parent._position ? (this.labelMaxWidth = l(this.options.labelMaxWidth) ? this.parent.bounds.x2 - this.parent.bounds.x1 : this.labelMaxWidth, this.labelMaxHeight = l(this.options.labelWrap) || this.labelWrap ? 3 * this.chart.height : 2 * this.labelFontSize) : "top" !== this.parent._position && "bottom" !== this.parent._position || (this.labelMaxWidth = l(this.options.labelMaxWidth) ? 3 * this.chart.width : this.labelMaxWidth, this.labelMaxHeight = l(this.options.labelWrap) || this.labelWrap ? this.parent.bounds.height : 2 * this.labelFontSize), 0 < x && c.setLineDash && c.setLineDash(d(this.lineDashType, x)), r = new M(c, {
                    x: 0,
                    y: 0,
                    padding: {
                        top: 2,
                        right: 3,
                        bottom: 2,
                        left: 4
                    },
                    backgroundColor: this.labelBackgroundColor,
                    borderColor: this.labelBorderColor,
                    borderThickness: this.labelBorderThickness,
                    cornerRadius: this.labelCornerRadius,
                    maxWidth: this.labelMaxWidth,
                    maxHeight: this.labelMaxHeight,
                    angle: this.labelAngle,
                    text: h,
                    horizontalAlign: "left",
                    fontSize: this.labelFontSize,
                    fontFamily: this.labelFontFamily,
                    fontWeight: this.labelFontWeight,
                    fontColor: this.labelFontColor,
                    fontStyle: this.labelFontStyle,
                    textBaseline: "middle"
                }), this.snapToDataPoint) {
                var u = 0;
                o = [];
                if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                    var m = null;
                    "bottom" === this.parent._position || "top" === this.parent._position ? u = this.parent.dataSeries[0].axisX.convertPixelToValue({
                        y: e
                    }) : "left" !== this.parent._position && "right" !== this.parent._position || (u = this.parent.convertPixelToValue({
                        y: e
                    }));
                    for (var g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (m.dataSeries = this.parent.dataSeries[g], null !== m.dataPoint.y && o.push(m));
                    if (m = null, 0 === o.length) return;
                    if (o.sort(function(t, e) {
                            return t.distance - e.distance
                        }), m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), g = 0, "rangeBar" === o[0].dataSeries.type || "error" === o[0].dataSeries.type) {
                        m = Math.abs(t - this.parent.convertValueToPixel(o[g].dataPoint.y[0]));
                        var b = 0;
                        for (u = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, g = u)
                    } else if ("stackedBar" === o[0].dataSeries.type) {
                        m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y));
                        var y = b = 0;
                        for (u = g = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else y += o[u].dataPoint.y, (b = Math.abs(t - this.parent.convertValueToPixel(y))) < m && (m = b, g = u)
                    } else if ("stackedBar100" === o[0].dataSeries.type) {
                        m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y));
                        var v = y = b = 0;
                        for (u = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else y += o[u].dataPoint.y, v = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, v = y / o[u].dataSeries.plotUnit.dataPointYSums[v] * 100, (b = Math.abs(t - this.parent.convertValueToPixel(v))) < m && (m = b, g = u)
                    } else
                        for (m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = g = b = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else(b = Math.abs(t - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, g = u); if (h = o[g], "bottom" === this.parent._position || "top" === this.parent._position) {
                        if (i = 0, "rangeBar" === this.parent.dataSeries[g].type || "error" === this.parent.dataSeries[g].type) {
                            for (m = Math.abs(t - this.parent.convertValueToPixel(h.dataPoint.y[0])), u = b = 0; u < h.dataPoint.y.length; u++)(b = Math.abs(t - this.parent.convertValueToPixel(h.dataPoint.y[u]))) < m && (m = b, i = u);
                            o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataPoint.y[i]) << 0) : this.parent.convertValueToPixel(h.dataPoint.y[i]) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: h.dataPoint.y[i]
                            }) : l(this.options.label) ? Z(h.dataPoint.y[i], this.valueFormatString, this.chart._cultureInfo) : this.label
                        } else if ("stackedBar" === this.parent.dataSeries[g].type) {
                            for (m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), y = b = 0, u = g; 0 <= u; u--) y += o[u].dataPoint.y, (b = Math.abs(t - this.parent.convertValueToPixel(y))) < m && (m = b, i = u);
                            o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(y) << 0) : this.parent.convertValueToPixel(y) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: h.dataPoint.y
                            }) : l(this.options.label) ? Z(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label
                        } else if ("stackedBar100" === this.parent.dataSeries[g].type) {
                            for (m = Math.abs(t - this.parent.convertValueToPixel(o[0].dataPoint.y)), v = y = b = 0, u = g; 0 <= u; u--) y += o[u].dataPoint.y, v = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, v = y / o[u].dataSeries.plotUnit.dataPointYSums[v] * 100, (b = Math.abs(t - this.parent.convertValueToPixel(v))) < m && (m = b, i = u);
                            o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(v) << 0) : this.parent.convertValueToPixel(v) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: v
                            }) : l(this.options.label) ? Z(v, this.valueFormatString, this.chart._cultureInfo) : this.label
                        } else o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataPoint.y) << 0) : this.parent.convertValueToPixel(h.dataPoint.y) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: h.dataPoint.y
                        }) : l(this.options.label) ? Z(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label;
                        i = a = o, s = this.chart.plotArea.y1, n = this.chart.plotArea.y2, this.bounds = {
                            x1: i - x / 2,
                            y1: s,
                            x2: a + x / 2,
                            y2: n
                        }, r.x = i - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 ? r.x = this.chart.bounds.x2 - r.width : r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2
                    } else if ("left" === this.parent._position || "right" === this.parent._position) {
                        if (s = n = o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataPoint.x) << 0) : this.parent.convertValueToPixel(h.dataPoint.x) << 0, i = this.chart.plotArea.x1, a = this.chart.plotArea.x2, this.bounds = {
                                x1: i,
                                y1: s - x / 2,
                                x2: a,
                                y2: n + x / 2
                            }, v = !1, this.parent.labels)
                            for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) {
                                if (!this.parent.labels[u]) {
                                    v = !1;
                                    break
                                }
                                v = !0
                            }
                        if (v) {
                            if ("axisX" === this.parent.type)
                                for (u = this.parent.convertPixelToValue({
                                        y: e
                                    }), m = null, g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: h.dataPoint.x
                                }) : l(this.options.label) ? m.dataPoint.label : this.label)
                        } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: h.dataPoint.x
                        }) : l(this.options.label) ? Q(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: h.dataPoint.x
                        }) : l(this.options.label) ? Z(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);
                        r.y = n + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x2 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2)
                    }
                } else if ("bottom" === this.parent._position || "top" === this.parent._position) {
                    for (u = this.parent.convertPixelToValue({
                            x: t
                        }), g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (m.dataSeries = this.parent.dataSeries[g], null !== m.dataPoint.y && o.push(m));
                    if (0 === o.length) return;
                    if (o.sort(function(t, e) {
                            return t.distance - e.distance
                        }), h = o[0], i = a = o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataPoint.x) << 0) : this.parent.convertValueToPixel(h.dataPoint.x) << 0, s = this.chart.plotArea.y1, n = this.chart.plotArea.y2, this.bounds = {
                            x1: i - x / 2,
                            y1: s,
                            x2: a + x / 2,
                            y2: n
                        }, v = !1, this.parent.labels)
                        for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) {
                            if (!this.parent.labels[u]) {
                                v = !1;
                                break
                            }
                            v = !0
                        }
                    if (v) {
                        if ("axisX" === this.parent.type)
                            for (u = this.parent.convertPixelToValue({
                                    x: t
                                }), m = null, g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: h.dataPoint.x
                            }) : l(this.options.label) ? m.dataPoint.label : this.label)
                    } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: h.dataPoint.x
                    }) : l(this.options.label) ? Q(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: h.dataPoint.x
                    }) : l(this.options.label) ? Z(h.dataPoint.x, this.valueFormatString, this.chart._cultureInfo) : this.label);
                    r.x = i - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 && (r.x = this.chart.bounds.x2 - r.width), r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), "bottom" === this.parent._position ? r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2 : "top" === this.parent._position && (r.y = this.parent.lineCoordinates.y1 - r.height + r.fontSize / 2 + 2)
                } else if ("left" === this.parent._position || "right" === this.parent._position) {
                    for (!l(this.parent.dataSeries) && 0 < this.parent.dataSeries.length && (u = this.parent.dataSeries[0].axisX.convertPixelToValue({
                            x: t
                        })), g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (m.dataSeries = this.parent.dataSeries[g], null !== m.dataPoint.y && o.push(m));
                    if (0 === o.length) return;
                    if (o.sort(function(t, e) {
                            return t.distance - e.distance
                        }), g = 0, "rangeColumn" === o[0].dataSeries.type || "rangeArea" === o[0].dataSeries.type || "error" === o[0].dataSeries.type || "rangeSplineArea" === o[0].dataSeries.type || "candlestick" === o[0].dataSeries.type || "ohlc" === o[0].dataSeries.type || "boxAndWhisker" === o[0].dataSeries.type)
                        for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y[0])), u = b = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, g = u);
                    else if ("stackedColumn" === o[0].dataSeries.type || "stackedArea" === o[0].dataSeries.type)
                        for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = y = b = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else y += o[u].dataPoint.y, (b = Math.abs(e - this.parent.convertValueToPixel(y))) < m && (m = b, g = u);
                    else if ("stackedColumn100" === o[0].dataSeries.type || "stackedArea100" === o[0].dataSeries.type)
                        for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = v = y = b = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else y += o[u].dataPoint.y, v = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, v = y / o[u].dataSeries.plotUnit.dataPointYSums[v] * 100, (b = Math.abs(e - this.parent.convertValueToPixel(v))) < m && (m = b, g = u);
                    else
                        for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), u = b = 0; u < o.length; u++)
                            if (o[u].dataPoint.y && o[u].dataPoint.y.length)
                                for (h = 0; h < o[u].dataPoint.y.length; h++)(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y[h]))) < m && (m = b, g = u);
                            else(b = Math.abs(e - this.parent.convertValueToPixel(o[u].dataPoint.y))) < m && (m = b, g = u); if (h = o[g], i = 0, "rangeColumn" === this.parent.dataSeries[g].type || "rangeArea" === this.parent.dataSeries[g].type || "error" === this.parent.dataSeries[g].type || "rangeSplineArea" === this.parent.dataSeries[g].type || "candlestick" === this.parent.dataSeries[g].type || "ohlc" === this.parent.dataSeries[g].type || "boxAndWhisker" === this.parent.dataSeries[g].type) {
                        for (m = Math.abs(e - this.parent.convertValueToPixel(h.dataPoint.y[0])), u = b = 0; u < h.dataPoint.y.length; u++)(b = Math.abs(e - this.parent.convertValueToPixel(h.dataPoint.y[u]))) < m && (m = b, i = u);
                        o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataPoint.y[i]) << 0) : this.parent.convertValueToPixel(h.dataPoint.y[i]) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: h.dataPoint.y[i]
                        }) : l(this.options.label) ? Z(h.dataPoint.y[i], this.valueFormatString, this.chart._cultureInfo) : this.label
                    } else if ("stackedColumn" === this.parent.dataSeries[g].type || "stackedArea" === this.parent.dataSeries[g].type) {
                        for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), y = b = 0, u = g; 0 <= u; u--) y += o[u].dataPoint.y, (b = Math.abs(e - this.parent.convertValueToPixel(y))) < m && (m = b, i = u);
                        o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(y) << 0) : this.parent.convertValueToPixel(y) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: h.dataPoint.y
                        }) : l(this.options.label) ? Z(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label
                    } else if ("stackedColumn100" === this.parent.dataSeries[g].type || "stackedArea100" === this.parent.dataSeries[g].type) {
                        for (m = Math.abs(e - this.parent.convertValueToPixel(o[0].dataPoint.y)), y = b = 0, u = g; 0 <= u; u--) y += o[u].dataPoint.y, v = o[u].dataPoint.x.getTime ? o[u].dataPoint.x.getTime() : o[u].dataPoint.x, v = y / o[u].dataSeries.plotUnit.dataPointYSums[v] * 100, (b = Math.abs(e - this.parent.convertValueToPixel(v))) < m && (m = b, i = u);
                        o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(v) << 0) : this.parent.convertValueToPixel(v) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: v
                        }) : l(this.options.label) ? Z(v, this.valueFormatString, this.chart._cultureInfo) : this.label
                    } else "waterfall" === this.parent.dataSeries[g].type ? (o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataSeries.dataPointEOs[h.index].cumulativeSum) << 0) : this.parent.convertValueToPixel(h.dataSeries.dataPointEOs[h.index].cumulativeSum) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: h.dataSeries.dataPointEOs[h.index].cumulativeSum
                    }) : l(this.options.label) ? Z(h.dataSeries.dataPointEOs[h.index].cumulativeSum, this.valueFormatString, this.chart._cultureInfo) : this.label) : (o = 1 == c.lineWidth % 2 ? .5 + (this.parent.convertValueToPixel(h.dataPoint.y) << 0) : this.parent.convertValueToPixel(h.dataPoint.y) << 0, r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: h.dataPoint.y
                    }) : l(this.options.label) ? Z(h.dataPoint.y, this.valueFormatString, this.chart._cultureInfo) : this.label);
                    s = n = o, i = this.chart.plotArea.x1, a = this.chart.plotArea.x2, this.bounds = {
                        x1: i,
                        y1: s - x / 2,
                        x2: a,
                        y2: n + x / 2
                    }, r.y = n + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x2 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2)
                }
                o = null, ("bottom" === this.parent._position || "top" === this.parent._position) && i >= this.parent.convertValueToPixel(this.parent.viewportMinimum) && a <= this.parent.convertValueToPixel(this.parent.viewportMaximum) && (0 < x && (c.moveTo(i, s), c.lineTo(a, n), c.stroke()), c.restore(), !l(r.text) && ("number" == typeof r.text.valueOf() || 0 < r.text.length) && r.render(!0)), ("left" === this.parent._position || "right" === this.parent._position) && n >= this.parent.convertValueToPixel(this.parent.viewportMaximum) && s <= this.parent.convertValueToPixel(this.parent.viewportMinimum) && (0 < x && (c.moveTo(i, s), c.lineTo(a, n), c.stroke()), c.restore(), !l(r.text) && ("number" == typeof r.text.valueOf() || 0 < r.text.length) && r.render(!0))
            } else {
                if ("bottom" === this.parent._position || "top" === this.parent._position ? (i = a = o = 1 == c.lineWidth % 2 ? .5 + (t << 0) : t << 0, s = this.chart.plotArea.y1, n = this.chart.plotArea.y2, this.bounds = {
                        x1: i - x / 2,
                        y1: s,
                        x2: a + x / 2,
                        y2: n
                    }) : "left" !== this.parent._position && "right" !== this.parent._position || (s = n = o = 1 == c.lineWidth % 2 ? .5 + (e << 0) : e << 0, i = this.chart.plotArea.x1, a = this.chart.plotArea.x2, this.bounds = {
                        x1: i,
                        y1: s - x / 2,
                        x2: a,
                        y2: n + x / 2
                    }), "xySwapped" === this.chart.plotInfo.axisPlacement)
                    if ("left" === this.parent._position || "right" === this.parent._position) {
                        if (v = !1, this.parent.labels)
                            for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) {
                                if (!this.parent.labels[u]) {
                                    v = !1;
                                    break
                                }
                                v = !0
                            }
                        if (v) {
                            if ("axisX" === this.parent.type)
                                for (u = this.parent.convertPixelToValue({
                                        y: e
                                    }), m = null, g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({
                                    chart: this.chart,
                                    axis: this.parent.options,
                                    crosshair: this.options,
                                    value: this.parent.convertPixelToValue(t)
                                }) : l(this.options.label) ? m.dataPoint.label : this.label)
                        } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: this.parent.convertPixelToValue(e)
                        }) : l(this.options.label) ? Q(this.parent.convertPixelToValue(e), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({
                            chart: this.chart,
                            axis: this.parent.options,
                            crosshair: this.options,
                            value: this.parent.convertPixelToValue(e)
                        }) : l(this.options.label) ? Z(this.parent.convertPixelToValue(e), this.valueFormatString, this.chart._cultureInfo) : this.label);
                        r.y = e + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x1 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2)
                    } else "bottom" !== this.parent._position && "top" !== this.parent._position || (r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: this.parent.convertPixelToValue(t)
                    }) : l(this.options.label) ? Z(this.parent.convertPixelToValue(t), this.valueFormatString, this.chart._cultureInfo) : this.label, r.x = i - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 && (r.x = this.chart.bounds.x2 - r.width), r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), "bottom" === this.parent._position && (r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2), "top" === this.parent._position && (r.y = this.parent.lineCoordinates.y1 - r.height + r.fontSize / 2 + 2));
                else if ("bottom" === this.parent._position || "top" === this.parent._position) {
                    if (v = !1, h = "", this.parent.labels)
                        for (o = Math.ceil(this.parent.interval), u = 0; u < this.parent.viewportMaximum; u += o) {
                            if (!this.parent.labels[u]) {
                                v = !1;
                                break
                            }
                            v = !0
                        }
                    if (v) {
                        if ("axisX" === this.parent.type)
                            for (u = this.parent.convertPixelToValue({
                                    x: t
                                }), m = null, g = 0; g < this.parent.dataSeries.length; g++)(m = this.parent.dataSeries[g].getDataPointAtX(u, !0)) && 0 <= m.index && (r.text = this.labelFormatter ? this.labelFormatter({
                                chart: this.chart,
                                axis: this.parent.options,
                                crosshair: this.options,
                                value: this.parent.convertPixelToValue(t)
                            }) : l(this.options.label) ? m.dataPoint.label : this.label)
                    } else "dateTime" === this.parent.valueType ? r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: this.parent.convertPixelToValue(t)
                    }) : l(this.options.label) ? Q(this.parent.convertPixelToValue(t), this.valueFormatString, this.chart._cultureInfo) : this.label : "number" === this.parent.valueType && (r.text = this.labelFormatter ? this.labelFormatter({
                        chart: this.chart,
                        axis: this.parent.options,
                        crosshair: this.options,
                        value: 0 < this.parent.dataSeries.length ? this.parent.convertPixelToValue(t) : ""
                    }) : l(this.options.label) ? Z(this.parent.convertPixelToValue(t), this.valueFormatString, this.chart._cultureInfo) : this.label);
                    r.x = i - r.measureText().width / 2, r.x + r.width > this.chart.bounds.x2 && (r.x = this.chart.bounds.x2 - r.width), r.x < this.chart.bounds.x1 && (r.x = this.chart.bounds.x1), "bottom" === this.parent._position ? r.y = this.parent.lineCoordinates.y2 + r.fontSize / 2 + 2 : "top" === this.parent._position && (r.y = this.parent.lineCoordinates.y1 - r.height + r.fontSize / 2 + 2)
                } else "left" !== this.parent._position && "right" !== this.parent._position || (r.text = this.labelFormatter ? this.labelFormatter({
                    chart: this.chart,
                    axis: this.parent.options,
                    crosshair: this.options,
                    value: this.parent.convertPixelToValue(e)
                }) : l(this.options.label) ? Z(this.parent.convertPixelToValue(e), this.valueFormatString, this.chart._cultureInfo) : this.label, r.y = e + r.fontSize / 2 - r.measureText().height / 2 + 2, r.y - r.fontSize / 2 < this.chart.bounds.y1 ? r.y = this.chart.bounds.y1 + r.fontSize / 2 + 2 : r.y + r.measureText().height - r.fontSize / 2 > this.chart.bounds.y2 && (r.y = this.chart.bounds.y2 - r.measureText().height + r.fontSize / 2), "left" === this.parent._position ? r.x = this.parent.lineCoordinates.x2 - r.measureText().width : "right" === this.parent._position && (r.x = this.parent.lineCoordinates.x2));
                0 < x && (c.moveTo(i, s), c.lineTo(a, n), c.stroke()), c.restore(), !l(r.text) && ("number" == typeof r.text.valueOf() || 0 < r.text.length) && r.render(!0)
            }
            c.globalAlpha = p
        }, t(R, f), R.prototype._initialize = function() {
            var t;
            this.enabled && (this.container = document.createElement("div"), this.container.setAttribute("class", "canvasjs-chart-tooltip"), this.container.style.position = "absolute", this.container.style.height = "auto", this.container.style.boxShadow = "1px 1px 2px 2px rgba(0,0,0,0.1)", this.container.style.zIndex = "1000", this.container.style.pointerEvents = "none", this.container.style.display = "none", t = '<div style=" width: auto;height: auto;min-width: 50px;', t += "line-height: auto;", t += "margin: 0px 0px 0px 0px;", t += "padding: 5px;", t += "font-family: Calibri, Arial, Georgia, serif;", t += "font-weight: normal;", t += "font-style: " + (D ? "italic;" : "normal;"), t += "font-size: 14px;", t += "color: #000000;", t += "text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.1);", t += "text-align: left;", t += "border: 2px solid gray;", t += D ? "background: rgba(255,255,255,.9);" : "background: rgb(255,255,255);", t += "text-indent: 0px;", t += "white-space: nowrap;", t += "border-radius: 5px;", t += "-moz-user-select:none;", t += "-khtml-user-select: none;", t += "-webkit-user-select: none;", t += "-ms-user-select: none;", t += "user-select: none;", D || (t += "filter: alpha(opacity = 90);", t += "filter: progid:DXImageTransform.Microsoft.Shadow(Strength=3, Direction=135, Color='#666666');"), t += '} "> Sample Tooltip</div>', this.container.innerHTML = t, this.contentDiv = this.container.firstChild, this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.chart._canvasJSContainer.appendChild(this.container))
        }, R.prototype.mouseMoveHandler = function(t, e) {
            this._lastUpdated && 4 > (new Date).getTime() - this._lastUpdated || (this._lastUpdated = (new Date).getTime(), this.chart.resetOverlayedCanvas(), this._updateToolTip(t, e))
        }, R.prototype._updateToolTip = function(t, e, i) {
            if (i = void 0 === i || i, this.container || this._initialize(), this.enabled || this.hide(), !this.chart.disableToolTip) {
                if (void 0 === t || void 0 === e) {
                    if (isNaN(this._prevX) || isNaN(this._prevY)) return;
                    t = this._prevX, e = this._prevY
                } else this._prevX = t, this._prevY = e;
                var a = null,
                    s = null,
                    n = [],
                    o = 0;
                if (this.shared && this.enabled && "none" !== this.chart.plotInfo.axisPlacement) {
                    if ("xySwapped" === this.chart.plotInfo.axisPlacement) {
                        var r = [];
                        if (this.chart.axisX)
                            for (var h = 0; h < this.chart.axisX.length; h++) {
                                o = this.chart.axisX[h].convertPixelToValue({
                                    y: e
                                });
                                var d = null;
                                for (a = 0; a < this.chart.axisX[h].dataSeries.length; a++)(d = this.chart.axisX[h].dataSeries[a].getDataPointAtX(o, i)) && 0 <= d.index && (d.dataSeries = this.chart.axisX[h].dataSeries[a], null !== d.dataPoint.y && r.push(d));
                                d = null
                            }
                        if (this.chart.axisX2)
                            for (h = 0; h < this.chart.axisX2.length; h++) {
                                for (o = this.chart.axisX2[h].convertPixelToValue({
                                        y: e
                                    }), d = null, a = 0; a < this.chart.axisX2[h].dataSeries.length; a++)(d = this.chart.axisX2[h].dataSeries[a].getDataPointAtX(o, i)) && 0 <= d.index && (d.dataSeries = this.chart.axisX2[h].dataSeries[a], null !== d.dataPoint.y && r.push(d));
                                d = null
                            }
                    } else {
                        if (r = [], this.chart.axisX)
                            for (h = 0; h < this.chart.axisX.length; h++)
                                for (o = this.chart.axisX[h].convertPixelToValue({
                                        x: t
                                    }), d = null, a = 0; a < this.chart.axisX[h].dataSeries.length; a++)(d = this.chart.axisX[h].dataSeries[a].getDataPointAtX(o, i)) && 0 <= d.index && (d.dataSeries = this.chart.axisX[h].dataSeries[a], null !== d.dataPoint.y && r.push(d));
                        if (this.chart.axisX2)
                            for (h = 0; h < this.chart.axisX2.length; h++)
                                for (o = this.chart.axisX2[h].convertPixelToValue({
                                        x: t
                                    }), d = null, a = 0; a < this.chart.axisX2[h].dataSeries.length; a++)(d = this.chart.axisX2[h].dataSeries[a].getDataPointAtX(o, i)) && 0 <= d.index && (d.dataSeries = this.chart.axisX2[h].dataSeries[a], null !== d.dataPoint.y && r.push(d))
                    }
                    if (0 === r.length) return;
                    for (r.sort(function(t, e) {
                            return t.distance - e.distance
                        }), i = r[0], a = 0; a < r.length; a++) r[a].dataPoint.x.valueOf() === i.dataPoint.x.valueOf() && n.push(r[a]);
                    r = null
                } else {
                    if (d = this.chart.getDataPointAtXY(t, e, i)) this.currentDataPointIndex = d.dataPointIndex, this.currentSeriesIndex = d.dataSeries.index;
                    else if (D)
                        if (0 < (d = c(t, e, this.chart._eventManager.ghostCtx)) && void 0 !== this.chart._eventManager.objectMap[d]) {
                            if ("legendItem" === (d = this.chart._eventManager.objectMap[d]).objectType) return;
                            this.currentSeriesIndex = d.dataSeriesIndex, this.currentDataPointIndex = 0 <= d.dataPointIndex ? d.dataPointIndex : -1
                        } else this.currentDataPointIndex = -1;
                    else this.currentDataPointIndex = -1;
                    if (0 <= this.currentSeriesIndex) {
                        if (s = this.chart.data[this.currentSeriesIndex], d = {}, 0 <= this.currentDataPointIndex) a = s.dataPoints[this.currentDataPointIndex], d.dataSeries = s, d.dataPoint = a, d.index = this.currentDataPointIndex, d.distance = Math.abs(a.x - o), "waterfall" === s.type && (d.cumulativeSumYStartValue = s.dataPointEOs[this.currentDataPointIndex].cumulativeSumYStartValue, d.cumulativeSum = s.dataPointEOs[this.currentDataPointIndex].cumulativeSum);
                        else {
                            if (!this.enabled || "line" !== s.type && "stepLine" !== s.type && "spline" !== s.type && "area" !== s.type && "stepArea" !== s.type && "splineArea" !== s.type && "stackedArea" !== s.type && "stackedArea100" !== s.type && "rangeArea" !== s.type && "rangeSplineArea" !== s.type && "candlestick" !== s.type && "ohlc" !== s.type && "boxAndWhisker" !== s.type) return;
                            o = s.axisX.convertPixelToValue({
                                x: t
                            }), (d = s.getDataPointAtX(o, i)).dataSeries = s, this.currentDataPointIndex = d.index, a = d.dataPoint
                        }
                        if (!l(d.dataPoint.y))
                            if (d.dataSeries.axisY)
                                if (0 < d.dataPoint.y.length) {
                                    for (a = i = 0; a < d.dataPoint.y.length; a++) d.dataPoint.y[a] < d.dataSeries.axisY.viewportMinimum ? i-- : d.dataPoint.y[a] > d.dataSeries.axisY.viewportMaximum && i++;
                                    i < d.dataPoint.y.length && i > -d.dataPoint.y.length && n.push(d)
                                } else "column" === s.type || "bar" === s.type ? 0 > d.dataPoint.y ? 0 > d.dataSeries.axisY.viewportMinimum && d.dataSeries.axisY.viewportMaximum >= d.dataPoint.y && n.push(d) : d.dataSeries.axisY.viewportMinimum <= d.dataPoint.y && 0 <= d.dataSeries.axisY.viewportMaximum && n.push(d) : "bubble" === s.type ? (i = this.chart._eventManager.objectMap[s.dataPointIds[d.index]].size / 2, d.dataPoint.y >= d.dataSeries.axisY.viewportMinimum - i && d.dataPoint.y <= d.dataSeries.axisY.viewportMaximum + i && n.push(d)) : "waterfall" === s.type ? (i = 0, d.cumulativeSumYStartValue < d.dataSeries.axisY.viewportMinimum ? i-- : d.cumulativeSumYStartValue > d.dataSeries.axisY.viewportMaximum && i++, d.cumulativeSum < d.dataSeries.axisY.viewportMinimum ? i-- : d.cumulativeSum > d.dataSeries.axisY.viewportMaximum && i++, 2 > i && -2 < i && n.push(d)) : (0 <= d.dataSeries.type.indexOf("100") || "stackedColumn" === s.type || "stackedBar" === s.type || d.dataPoint.y >= d.dataSeries.axisY.viewportMinimum && d.dataPoint.y <= d.dataSeries.axisY.viewportMaximum) && n.push(d);
                        else n.push(d)
                    }
                }
                if (0 < n.length && (this.highlightObjects(n), this.enabled))
                    if (i = "", null !== (i = this.getToolTipInnerHTML({
                            entries: n
                        }))) {
                        this.contentDiv.innerHTML = i, i = !1, "none" === this.container.style.display && (i = !0, this.container.style.display = "block");
                        try {
                            this.contentDiv.style.background = this.backgroundColor ? this.backgroundColor : D ? "rgba(255,255,255,.9)" : "rgb(255,255,255)", this.borderColor = "waterfall" === n[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : n[0].dataPoint.color ? n[0].dataPoint.color : 0 < n[0].dataPoint.y ? n[0].dataSeries.risingColor : n[0].dataSeries.fallingColor : "error" === n[0].dataSeries.type ? this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : n[0].dataSeries.color ? n[0].dataSeries.color : n[0].dataSeries._colorSet[s.index % n[0].dataSeries._colorSet.length] : this.contentDiv.style.borderRightColor = this.contentDiv.style.borderLeftColor = this.contentDiv.style.borderColor = this.options.borderColor ? this.options.borderColor : n[0].dataPoint.color ? n[0].dataPoint.color : n[0].dataSeries.color ? n[0].dataSeries.color : n[0].dataSeries._colorSet[n[0].index % n[0].dataSeries._colorSet.length], this.contentDiv.style.borderWidth = this.borderThickness || 0 === this.borderThickness ? this.borderThickness + "px" : "2px", this.contentDiv.style.borderRadius = this.cornerRadius || 0 === this.cornerRadius ? this.cornerRadius + "px" : "5px", this.container.style.borderRadius = this.contentDiv.style.borderRadius, this.contentDiv.style.fontSize = this.fontSize || 0 === this.fontSize ? this.fontSize + "px" : "14px", this.contentDiv.style.color = this.fontColor ? this.fontColor : "#000000", this.contentDiv.style.fontFamily = this.fontFamily ? this.fontFamily : "Calibri, Arial, Georgia, serif;", this.contentDiv.style.fontWeight = this.fontWeight ? this.fontWeight : "normal", this.contentDiv.style.fontStyle = this.fontStyle ? this.fontStyle : D ? "italic" : "normal"
                        } catch (t) {}
                        "pie" === n[0].dataSeries.type || "doughnut" === n[0].dataSeries.type || "funnel" === n[0].dataSeries.type || "pyramid" === n[0].dataSeries.type || "bar" === n[0].dataSeries.type || "rangeBar" === n[0].dataSeries.type || "stackedBar" === n[0].dataSeries.type || "stackedBar100" === n[0].dataSeries.type ? t = t - 10 - this.container.clientWidth : (t = n[0].dataSeries.axisX.convertValueToPixel(n[0].dataPoint.x) - this.container.clientWidth << 0, t -= 10), 0 > t && (t += this.container.clientWidth + 20), t + this.container.clientWidth > Math.max(this.chart.container.clientWidth, this.chart.width) && (t = Math.max(0, Math.max(this.chart.container.clientWidth, this.chart.width) - this.container.clientWidth)), 0 < (e = 10 - (e = 1 !== n.length || this.shared || "line" !== n[0].dataSeries.type && "stepLine" !== n[0].dataSeries.type && "spline" !== n[0].dataSeries.type && "area" !== n[0].dataSeries.type && "stepArea" !== n[0].dataSeries.type && "splineArea" !== n[0].dataSeries.type ? "bar" === n[0].dataSeries.type || "rangeBar" === n[0].dataSeries.type || "stackedBar" === n[0].dataSeries.type || "stackedBar100" === n[0].dataSeries.type ? n[0].dataSeries.axisX.convertValueToPixel(n[0].dataPoint.x) : e : n[0].dataSeries.axisY.convertValueToPixel(n[0].dataPoint.y))) + this.container.clientHeight + 5 && (e -= e + this.container.clientHeight + 5 - 0), this.fixMozTransitionDelay(t, e), !this.animationEnabled || i ? this.disableAnimation() : (this.enableAnimation(), this.container.style.MozTransition = this.mozContainerTransition), this.container.style.left = t + "px", this.container.style.bottom = e + "px"
                    } else this.hide(!1)
            }
        }, R.prototype.highlightObjects = function(t) {
            var e = this.chart.overlaidCanvasCtx;
            this.chart.resetOverlayedCanvas(), e.clearRect(0, 0, this.chart.width, this.chart.height), e.save();
            var i = this.chart.plotArea,
                a = 0;
            for (e.beginPath(), e.rect(i.x1, i.y1, i.x2 - i.x1, i.y2 - i.y1), e.clip(), i = 0; i < t.length; i++) {
                var s = t[i];
                if ((s = this.chart._eventManager.objectMap[s.dataSeries.dataPointIds[s.index]]) && s.objectType && "dataPoint" === s.objectType) {
                    var n = (a = this.chart.data[s.dataSeriesIndex]).dataPoints[s.dataPointIndex],
                        o = s.dataPointIndex;
                    !1 === n.highlightEnabled || !0 !== a.highlightEnabled && !0 !== n.highlightEnabled || ("line" === a.type || "stepLine" === a.type || "spline" === a.type || "scatter" === a.type || "area" === a.type || "stepArea" === a.type || "splineArea" === a.type || "stackedArea" === a.type || "stackedArea100" === a.type || "rangeArea" === a.type || "rangeSplineArea" === a.type ? ((n = a.getMarkerProperties(o, s.x1, s.y1, this.chart.overlaidCanvasCtx)).size = Math.max(1.5 * n.size << 0, 10), n.borderColor = n.borderColor || "#FFFFFF", n.borderThickness = n.borderThickness || Math.ceil(.1 * n.size), et.drawMarkers([n]), void 0 !== s.y2 && ((n = a.getMarkerProperties(o, s.x1, s.y2, this.chart.overlaidCanvasCtx)).size = Math.max(1.5 * n.size << 0, 10), n.borderColor = n.borderColor || "#FFFFFF", n.borderThickness = n.borderThickness || Math.ceil(.1 * n.size), et.drawMarkers([n]))) : "bubble" === a.type ? ((n = a.getMarkerProperties(o, s.x1, s.y1, this.chart.overlaidCanvasCtx)).size = s.size, n.color = "white", n.borderColor = "white", e.globalAlpha = .3, et.drawMarkers([n]), e.globalAlpha = 1) : "column" === a.type || "stackedColumn" === a.type || "stackedColumn100" === a.type || "bar" === a.type || "rangeBar" === a.type || "stackedBar" === a.type || "stackedBar100" === a.type || "rangeColumn" === a.type || "waterfall" === a.type ? st(e, s.x1, s.y1, s.x2, s.y2, "white", 0, null, !1, !1, !1, !1, .3) : "pie" === a.type || "doughnut" === a.type ? q(e, s.center, s.radius, "white", a.type, s.startAngle, s.endAngle, .3, s.percentInnerRadius) : "funnel" === a.type || "pyramid" === a.type ? J(e, s.funnelSection, .3, "white") : "candlestick" === a.type ? (e.globalAlpha = 1, e.strokeStyle = s.color, e.lineWidth = 2 * s.borderThickness, a = 0 == e.lineWidth % 2 ? 0 : .5, e.beginPath(), e.moveTo(s.x3 - a, Math.min(s.y2, s.y3)), e.lineTo(s.x3 - a, Math.min(s.y1, s.y4)), e.stroke(), e.beginPath(), e.moveTo(s.x3 - a, Math.max(s.y1, s.y4)), e.lineTo(s.x3 - a, Math.max(s.y2, s.y3)), e.stroke(), st(e, s.x1, Math.min(s.y1, s.y4), s.x2, Math.max(s.y1, s.y4), "transparent", 2 * s.borderThickness, s.color, !1, !1, !1, !1), e.globalAlpha = 1) : "ohlc" === a.type ? (e.globalAlpha = 1, e.strokeStyle = s.color, e.lineWidth = 2 * s.borderThickness, a = 0 == e.lineWidth % 2 ? 0 : .5, e.beginPath(), e.moveTo(s.x3 - a, s.y2), e.lineTo(s.x3 - a, s.y3), e.stroke(), e.beginPath(), e.moveTo(s.x3, s.y1), e.lineTo(s.x1, s.y1), e.stroke(), e.beginPath(), e.moveTo(s.x3, s.y4), e.lineTo(s.x2, s.y4), e.stroke(), e.globalAlpha = 1) : "boxAndWhisker" === a.type ? (e.save(), e.globalAlpha = 1, e.strokeStyle = s.stemColor, e.lineWidth = 2 * s.stemThickness, 0 < s.stemThickness && (e.beginPath(), e.moveTo(s.x3, s.y2 + s.borderThickness / 2), e.lineTo(s.x3, s.y1 + s.whiskerThickness / 2), e.stroke(), e.beginPath(), e.moveTo(s.x3, s.y4 - s.whiskerThickness / 2), e.lineTo(s.x3, s.y3 - s.borderThickness / 2), e.stroke()), e.beginPath(), st(e, s.x1 - s.borderThickness / 2, Math.max(s.y2 + s.borderThickness / 2, s.y3 + s.borderThickness / 2), s.x2 + s.borderThickness / 2, Math.min(s.y2 - s.borderThickness / 2, s.y3 - s.borderThickness / 2), "transparent", s.borderThickness, s.color, !1, !1, !1, !1), e.globalAlpha = 1, e.strokeStyle = s.whiskerColor, e.lineWidth = 2 * s.whiskerThickness, 0 < s.whiskerThickness && (e.beginPath(), e.moveTo(Math.floor(s.x3 - s.whiskerLength / 2), s.y4), e.lineTo(Math.ceil(s.x3 + s.whiskerLength / 2), s.y4), e.stroke(), e.beginPath(), e.moveTo(Math.floor(s.x3 - s.whiskerLength / 2), s.y1), e.lineTo(Math.ceil(s.x3 + s.whiskerLength / 2), s.y1), e.stroke()), e.globalAlpha = 1, e.strokeStyle = s.lineColor, e.lineWidth = 2 * s.lineThickness, 0 < s.lineThickness && (e.beginPath(), e.moveTo(s.x1, s.y5), e.lineTo(s.x2, s.y5), e.stroke()), e.restore(), e.globalAlpha = 1) : "error" === a.type && B(e, s.x1, s.y1, s.x2, s.y2, "white", s.whiskerProperties, s.stemProperties, s.isXYSwapped, .3))
                }
            }
            e.restore(), e.globalAlpha = 1, e.beginPath()
        }, R.prototype.getToolTipInnerHTML = function(t) {
            t = t.entries;
            for (var e = null, i = null, a = null, s = 0, n = "", o = !0, l = 0; l < t.length; l++)
                if (t[l].dataSeries.toolTipContent || t[l].dataPoint.toolTipContent) {
                    o = !1;
                    break
                }
            if (o && (this.content && "function" == typeof this.content || this.contentFormatter)) t = {
                chart: this.chart,
                toolTip: this.options,
                entries: t
            }, e = this.contentFormatter ? this.contentFormatter(t) : this.content(t);
            else if (this.shared && "none" !== this.chart.plotInfo.axisPlacement) {
                var r = null,
                    h = "";
                for (l = 0; l < t.length; l++) i = t[l].dataSeries, a = t[l].dataPoint, s = t[l].index, n = "", 0 === l && o && !this.content && (this.chart.axisX && 0 < this.chart.axisX.length ? h += void 0 !== this.chart.axisX[0].labels[a.x] ? this.chart.axisX[0].labels[a.x] : "{x}" : this.chart.axisX2 && 0 < this.chart.axisX2.length && (h += void 0 !== this.chart.axisX2[0].labels[a.x] ? this.chart.axisX2[0].labels[a.x] : "{x}"), h += "</br>", h = this.chart.replaceKeywordsWithValue(h, a, i, s)), null === a.toolTipContent || void 0 === a.toolTipContent && null === i.options.toolTipContent || ("line" === i.type || "stepLine" === i.type || "spline" === i.type || "area" === i.type || "stepArea" === i.type || "splineArea" === i.type || "column" === i.type || "bar" === i.type || "scatter" === i.type || "stackedColumn" === i.type || "stackedColumn100" === i.type || "stackedBar" === i.type || "stackedBar100" === i.type || "stackedArea" === i.type || "stackedArea100" === i.type || "waterfall" === i.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (n += r != i.axisXIndex ? i.axisX.title ? i.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), n += a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}", r = i.axisXIndex) : "bubble" === i.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (n += r != i.axisXIndex ? i.axisX.title ? i.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), n += a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}") : "rangeColumn" === i.type || "rangeBar" === i.type || "rangeArea" === i.type || "rangeSplineArea" === i.type || "error" === i.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (n += r != i.axisXIndex ? i.axisX.title ? i.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), n += a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span>&nbsp;&nbsp;{y[0]},&nbsp;{y[1]}") : "candlestick" === i.type || "ohlc" === i.type ? (this.chart.axisX && 1 < this.chart.axisX.length && (n += r != i.axisXIndex ? i.axisX.title ? i.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), n += a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low:&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}") : "boxAndWhisker" === i.type && (this.chart.axisX && 1 < this.chart.axisX.length && (n += r != i.axisXIndex ? i.axisX.title ? i.axisX.title + "<br/>" : "X:{axisXIndex}<br/>" : ""), n += a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>{name}:</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"), null === e && (e = ""), !0 === this.reversed ? (e = this.chart.replaceKeywordsWithValue(n, a, i, s) + e, l < t.length - 1 && (e = "</br>" + e)) : (e += this.chart.replaceKeywordsWithValue(n, a, i, s), l < t.length - 1 && (e += "</br>")));
                null !== e && (e = h + e)
            } else {
                if (i = t[0].dataSeries, a = t[0].dataPoint, s = t[0].index, null === a.toolTipContent || void 0 === a.toolTipContent && null === i.options.toolTipContent) return null;
                "line" === i.type || "stepLine" === i.type || "spline" === i.type || "area" === i.type || "stepArea" === i.type || "splineArea" === i.type || "column" === i.type || "bar" === i.type || "scatter" === i.type || "stackedColumn" === i.type || "stackedColumn100" === i.type || "stackedBar" === i.type || "stackedBar100" === i.type || "stackedArea" === i.type || "stackedArea100" === i.type || "waterfall" === i.type ? n = a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (a.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}" : "bubble" === i.type ? n = a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (a.label ? "{label}" : "{x}") + ":</span>&nbsp;&nbsp;{y}, &nbsp;&nbsp;{z}" : "pie" === i.type || "doughnut" === i.type || "funnel" === i.type || "pyramid" === i.type ? n = a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (a.name ? "{name}:</span>&nbsp;&nbsp;" : a.label ? "{label}:</span>&nbsp;&nbsp;" : "</span>") + "{y}" : "rangeColumn" === i.type || "rangeBar" === i.type || "rangeArea" === i.type || "rangeSplineArea" === i.type || "error" === i.type ? n = a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (a.label ? "{label}" : "{x}") + " :</span>&nbsp;&nbsp;{y[0]}, &nbsp;{y[1]}" : "candlestick" === i.type || "ohlc" === i.type ? n = a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (a.label ? "{label}" : "{x}") + "</span><br/>Open: &nbsp;&nbsp;{y[0]}<br/>High: &nbsp;&nbsp;&nbsp;{y[1]}<br/>Low: &nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Close: &nbsp;&nbsp;{y[3]}" : "boxAndWhisker" === i.type && (n = a.toolTipContent ? a.toolTipContent : i.toolTipContent ? i.toolTipContent : this.content && "function" != typeof this.content ? this.content : "<span style='\"" + (this.options.fontColor ? "" : "'color:{color};'") + "\"'>" + (a.label ? "{label}" : "{x}") + "</span><br/>Minimum: &nbsp;&nbsp;{y[0]}<br/>Q1: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[1]}<br/>Q2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[4]}<br/>Q3: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{y[2]}<br/>Maximum: &nbsp;{y[3]}"), null === e && (e = ""), e += this.chart.replaceKeywordsWithValue(n, a, i, s)
            }
            return e
        }, R.prototype.enableAnimation = function() {
            if (!this.container.style.WebkitTransition) {
                var t = this.getContainerTransition(this.containerTransitionDuration);
                this.container.style.WebkitTransition = t, this.container.style.MsTransition = t, this.container.style.transition = t, this.container.style.MozTransition = this.mozContainerTransition
            }
        }, R.prototype.disableAnimation = function() {
            this.container.style.WebkitTransition && (this.container.style.WebkitTransition = "", this.container.style.MozTransition = "", this.container.style.MsTransition = "", this.container.style.transition = "")
        }, R.prototype.hide = function(t) {
            this.container && (this.container.style.display = "none", this.currentSeriesIndex = -1, this._prevY = this._prevX = NaN, (void 0 === t || t) && this.chart.resetOverlayedCanvas())
        }, R.prototype.show = function(t, e, i) {
            this._updateToolTip(t, e, void 0 !== i && i)
        }, R.prototype.fixMozTransitionDelay = function(t, e) {
            if (20 < this.chart._eventManager.lastObjectId) this.mozContainerTransition = this.getContainerTransition(0);
            else {
                var i = parseFloat(this.container.style.left),
                    a = (i = isNaN(i) ? 0 : i, parseFloat(this.container.style.bottom));
                a = isNaN(a) ? 0 : a;
                10 < Math.sqrt(Math.pow(i - t, 2) + Math.pow(a - e, 2)) ? this.mozContainerTransition = this.getContainerTransition(.1) : this.mozContainerTransition = this.getContainerTransition(0)
            }
        }, R.prototype.getContainerTransition = function(t) {
            return "left " + t + "s ease-out 0s, bottom " + t + "s ease-out 0s"
        }, N.prototype.reset = function() {
            this.lastObjectId = 0, this.objectMap = [], this.rectangularRegionEventSubscriptions = [], this.previousDataPointEventObject = null, this.eventObjects = [], D && (this.ghostCtx.clearRect(0, 0, this.chart.width, this.chart.height), this.ghostCtx.beginPath())
        }, N.prototype.getNewObjectTrackingId = function() {
            return ++this.lastObjectId
        }, N.prototype.mouseEventHandler = function(t) {
            if ("mousemove" === t.type || "click" === t.type) {
                var e = [],
                    i = $(t),
                    a = null;
                if ((a = this.chart.getObjectAtXY(i.x, i.y, !1)) && void 0 !== this.objectMap[a])
                    if ("dataPoint" === (a = this.objectMap[a]).objectType) {
                        var s = this.chart.data[a.dataSeriesIndex],
                            n = s.dataPoints[a.dataPointIndex],
                            o = a.dataPointIndex;
                        a.eventParameter = {
                            x: i.x,
                            y: i.y,
                            dataPoint: n,
                            dataSeries: s.options,
                            dataPointIndex: o,
                            dataSeriesIndex: s.index,
                            chart: this.chart
                        }, a.eventContext = {
                            context: n,
                            userContext: n,
                            mouseover: "mouseover",
                            mousemove: "mousemove",
                            mouseout: "mouseout",
                            click: "click"
                        }, e.push(a), (a = this.objectMap[s.id]).eventParameter = {
                            x: i.x,
                            y: i.y,
                            dataPoint: n,
                            dataSeries: s.options,
                            dataPointIndex: o,
                            dataSeriesIndex: s.index,
                            chart: this.chart
                        }, a.eventContext = {
                            context: s,
                            userContext: s.options,
                            mouseover: "mouseover",
                            mousemove: "mousemove",
                            mouseout: "mouseout",
                            click: "click"
                        }, e.push(this.objectMap[s.id])
                    } else "legendItem" === a.objectType && (s = this.chart.data[a.dataSeriesIndex], n = null !== a.dataPointIndex ? s.dataPoints[a.dataPointIndex] : null, a.eventParameter = {
                        x: i.x,
                        y: i.y,
                        dataSeries: s.options,
                        dataPoint: n,
                        dataPointIndex: a.dataPointIndex,
                        dataSeriesIndex: a.dataSeriesIndex,
                        chart: this.chart
                    }, a.eventContext = {
                        context: this.chart.legend,
                        userContext: this.chart.legend.options,
                        mouseover: "itemmouseover",
                        mousemove: "itemmousemove",
                        mouseout: "itemmouseout",
                        click: "itemclick"
                    }, e.push(a));
                for (s = [], i = 0; i < this.mouseoveredObjectMaps.length; i++) {
                    for (n = !0, a = 0; a < e.length; a++)
                        if (e[a].id === this.mouseoveredObjectMaps[i].id) {
                            n = !1;
                            break
                        }
                    n ? this.fireEvent(this.mouseoveredObjectMaps[i], "mouseout", t) : s.push(this.mouseoveredObjectMaps[i])
                }
                for (this.mouseoveredObjectMaps = s, i = 0; i < e.length; i++) {
                    for (s = !1, a = 0; a < this.mouseoveredObjectMaps.length; a++)
                        if (e[i].id === this.mouseoveredObjectMaps[a].id) {
                            s = !0;
                            break
                        }
                    s || (this.fireEvent(e[i], "mouseover", t), this.mouseoveredObjectMaps.push(e[i])), "click" === t.type ? this.fireEvent(e[i], "click", t) : "mousemove" === t.type && this.fireEvent(e[i], "mousemove", t)
                }
            }
        }, N.prototype.fireEvent = function(t, e, i) {
            if (t && e) {
                var a = t.eventParameter,
                    s = t.eventContext,
                    n = t.eventContext.userContext;
                n && s && n[s[e]] && n[s[e]].call(n, a), "mouseout" !== e ? n.cursor && n.cursor !== i.target.style.cursor && (i.target.style.cursor = n.cursor) : (i.target.style.cursor = this.chart._defaultCursor, delete t.eventParameter, delete t.eventContext), "click" === e && "dataPoint" === t.objectType && this.chart.pieDoughnutClickHandler && this.chart.pieDoughnutClickHandler.call(this.chart.data[t.dataSeriesIndex], a), "click" === e && "dataPoint" === t.objectType && this.chart.funnelPyramidClickHandler && this.chart.funnelPyramidClickHandler.call(this.chart.data[t.dataSeriesIndex], a)
            }
        }, H.prototype.animate = function(t, e, i, a, s) {
            var n = this;
            for (this.chart.isAnimating = !0, s = s || tt.easing.linear, i && this.animations.push({
                    startTime: (new Date).getTime() + (t || 0),
                    duration: e,
                    animationCallback: i,
                    onComplete: a
                }), t = []; 0 < this.animations.length;) e = this.animations.shift(), i = (new Date).getTime(), a = 0, e.startTime <= i && (a = s(Math.min(i - e.startTime, e.duration), 0, 1, e.duration), a = Math.min(a, 1), isNaN(a) || !isFinite(a)) && (a = 1), 1 > a && t.push(e), e.animationCallback(a), 1 <= a && e.onComplete && e.onComplete();
            this.animations = t, 0 < this.animations.length ? this.animationRequestId = this.chart.requestAnimFrame.call(window, function() {
                n.animate.call(n)
            }) : this.chart.isAnimating = !1
        }, H.prototype.cancelAllAnimations = function() {
            this.animations = [], this.animationRequestId && this.chart.cancelRequestAnimFrame.call(window, this.animationRequestId), this.animationRequestId = null, this.chart.isAnimating = !1
        };
        var tt = {
                yScaleAnimation: function(t, e) {
                    if (0 !== t) {
                        var i = e.dest,
                            a = e.source.canvas,
                            s = e.animationBase;
                        i.drawImage(a, 0, 0, a.width, a.height, 0, s - s * t, i.canvas.width / at, t * i.canvas.height / at)
                    }
                },
                xScaleAnimation: function(t, e) {
                    if (0 !== t) {
                        var i = e.dest,
                            a = e.source.canvas,
                            s = e.animationBase;
                        i.drawImage(a, 0, 0, a.width, a.height, s - s * t, 0, t * i.canvas.width / at, i.canvas.height / at)
                    }
                },
                xClipAnimation: function(t, e) {
                    if (0 !== t) {
                        var i = e.dest,
                            a = e.source.canvas;
                        i.save(), 0 < t && i.drawImage(a, 0, 0, a.width * t, a.height, 0, 0, a.width * t / at, a.height / at), i.restore()
                    }
                },
                fadeInAnimation: function(t, e) {
                    if (0 !== t) {
                        var i = e.dest,
                            a = e.source.canvas;
                        i.save(), i.globalAlpha = t, i.drawImage(a, 0, 0, a.width, a.height, 0, 0, i.canvas.width / at, i.canvas.height / at), i.restore()
                    }
                },
                easing: {
                    linear: function(t, e, i, a) {
                        return i * t / a + e
                    },
                    easeOutQuad: function(t, e, i, a) {
                        return -i * (t /= a) * (t - 2) + e
                    },
                    easeOutQuart: function(t, e, i, a) {
                        return -i * ((t = t / a - 1) * t * t * t - 1) + e
                    },
                    easeInQuad: function(t, e, i, a) {
                        return i * (t /= a) * t + e
                    },
                    easeInQuart: function(t, e, i, a) {
                        return i * (t /= a) * t * t * t + e
                    }
                }
            },
            et = {
                drawMarker: function(t, e, i, a, s, n, o, l) {
                    if (i) {
                        var r = 1;
                        i.fillStyle = n || "#000000", i.strokeStyle = o || "#000000", i.lineWidth = l || 0, i.setLineDash && i.setLineDash(d("solid", l)), "circle" === a ? (i.moveTo(t, e), i.beginPath(), i.arc(t, e, s / 2, 0, 2 * Math.PI, !1), n && i.fill(), l && (o ? i.stroke() : (r = i.globalAlpha, i.globalAlpha = .15, i.strokeStyle = "black", i.stroke(), i.globalAlpha = r))) : "square" === a ? (i.beginPath(), i.rect(t - s / 2, e - s / 2, s, s), n && i.fill(), l && (o ? i.stroke() : (r = i.globalAlpha, i.globalAlpha = .15, i.strokeStyle = "black", i.stroke(), i.globalAlpha = r))) : "triangle" === a ? (i.beginPath(), i.moveTo(t - s / 2, e + s / 2), i.lineTo(t + s / 2, e + s / 2), i.lineTo(t, e - s / 2), i.closePath(), n && i.fill(), l && (o ? i.stroke() : (r = i.globalAlpha, i.globalAlpha = .15, i.strokeStyle = "black", i.stroke(), i.globalAlpha = r)), i.beginPath()) : "cross" === a && (i.strokeStyle = n, i.lineWidth = s / 4, i.beginPath(), i.moveTo(t - s / 2, e - s / 2), i.lineTo(t + s / 2, e + s / 2), i.stroke(), i.moveTo(t + s / 2, e - s / 2), i.lineTo(t - s / 2, e + s / 2), i.stroke())
                    }
                },
                drawMarkers: function(t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        et.drawMarker(i.x, i.y, i.ctx, i.type, i.size, i.color, i.borderColor, i.borderThickness)
                    }
                }
            };
        return o
    }(), lt.Chart.version = ""
}(), document.createElement("canvas").getContext || function() {
    function t(t) {
        return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
    }

    function e(t) {
        t.namespaces.g_vml_ || t.namespaces.add("g_vml_", "urn:schemas-microsoft-com:vml", "#default#VML"), t.namespaces.g_o_ || t.namespaces.add("g_o_", "urn:schemas-microsoft-com:office:office", "#default#VML"), t.styleSheets.ex_canvas_ || ((t = t.createStyleSheet()).owningElement.id = "ex_canvas_", t.cssText = "canvas{display:inline-block;overflow:hidden;text-align:left;width:300px;height:150px}")
    }

    function i(t) {
        var e = t.srcElement;
        switch (t.propertyName) {
            case "width":
                e.getContext().clearRect(), e.style.width = e.attributes.width.nodeValue + "px", e.firstChild.style.width = e.clientWidth + "px";
                break;
            case "height":
                e.getContext().clearRect(), e.style.height = e.attributes.height.nodeValue + "px", e.firstChild.style.height = e.clientHeight + "px"
        }
    }

    function a(t) {
        (t = t.srcElement).firstChild && (t.firstChild.style.width = t.clientWidth + "px", t.firstChild.style.height = t.clientHeight + "px")
    }

    function s(t, e) {
        for (var i = [
                [1, 0, 0],
                [0, 1, 0],
                [0, 0, 1]
            ], a = 0; 3 > a; a++)
            for (var s = 0; 3 > s; s++) {
                for (var n = 0, o = 0; 3 > o; o++) n += t[a][o] * e[o][s];
                i[a][s] = n
            }
        return i
    }

    function n(t, e) {
        e.fillStyle = t.fillStyle, e.lineCap = t.lineCap, e.lineJoin = t.lineJoin, e.lineWidth = t.lineWidth, e.miterLimit = t.miterLimit, e.shadowBlur = t.shadowBlur, e.shadowColor = t.shadowColor, e.shadowOffsetX = t.shadowOffsetX, e.shadowOffsetY = t.shadowOffsetY, e.strokeStyle = t.strokeStyle, e.globalAlpha = t.globalAlpha, e.font = t.font, e.textAlign = t.textAlign, e.textBaseline = t.textBaseline, e.arcScaleX_ = t.arcScaleX_, e.arcScaleY_ = t.arcScaleY_, e.lineScale_ = t.lineScale_
    }

    function o(t) {
        var e = t.indexOf("(", 3),
            i = t.indexOf(")", e + 1);
        return 4 == (e = t.substring(e + 1, i).split(",")).length && "a" == t.charAt(3) || (e[3] = 1), e
    }

    function l(t, e, i) {
        return Math.min(i, Math.max(e, t))
    }

    function r(t, e, i) {
        return 0 > i && i++, 1 < i && i--, 1 > 6 * i ? t + 6 * (e - t) * i : 1 > 2 * i ? e : 2 > 3 * i ? t + 6 * (e - t) * (2 / 3 - i) : t
    }

    function h(t) {
        if (t in I) return I[t];
        var e, i = 1;
        if ("#" == (t = String(t)).charAt(0)) e = t;
        else if (/^rgb/.test(t)) {
            i = o(t), e = "#";
            for (var a, s = 0; 3 > s; s++) a = -1 != i[s].indexOf("%") ? Math.floor(parseFloat(i[s]) / 100 * 255) : +i[s], e += B[l(a, 0, 255)];
            i = +i[3]
        } else if (/^hsl/.test(t)) {
            if (s = i = o(t), 0 > (e = parseFloat(s[0]) / 360 % 360) && e++, a = l(parseFloat(s[1]) / 100, 0, 1), s = l(parseFloat(s[2]) / 100, 0, 1), 0 == a) a = s = e = s;
            else {
                var n = .5 > s ? s * (1 + a) : s + a - s * a,
                    h = 2 * s - n;
                a = r(h, n, e + 1 / 3), s = r(h, n, e), e = r(h, n, e - 1 / 3)
            }
            e = "#" + B[Math.floor(255 * a)] + B[Math.floor(255 * s)] + B[Math.floor(255 * e)], i = i[3]
        } else e = L[t] || t;
        return I[t] = {
            color: e,
            alpha: i
        }
    }

    function d(t) {
        this.m_ = [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ], this.mStack_ = [], this.aStack_ = [], this.currentPath_ = [], this.fillStyle = this.strokeStyle = "#000", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", this.miterLimit = 1 * w, this.globalAlpha = 1, this.font = "10px sans-serif", this.textAlign = "left", this.textBaseline = "alphabetic", this.canvas = t;
        var e = "width:" + t.clientWidth + "px;height:" + t.clientHeight + "px;overflow:hidden;position:absolute",
            i = t.ownerDocument.createElement("div");
        i.style.cssText = e, t.appendChild(i), (e = i.cloneNode(!1)).style.backgroundColor = "red", e.style.filter = "alpha(opacity=0)", t.appendChild(e), this.element_ = i, this.lineScale_ = this.arcScaleY_ = this.arcScaleX_ = 1
    }

    function x(t, e, i, a) {
        t.currentPath_.push({
            type: "bezierCurveTo",
            cp1x: e.x,
            cp1y: e.y,
            cp2x: i.x,
            cp2y: i.y,
            x: a.x,
            y: a.y
        }), t.currentX_ = a.x, t.currentY_ = a.y
    }

    function c(t, e) {
        var i = (a = h(t.strokeStyle)).color,
            a = a.alpha * t.globalAlpha,
            s = t.lineScale_ * t.lineWidth;
        1 > s && (a *= s), e.push("<g_vml_:stroke", ' opacity="', a, '"', ' joinstyle="', t.lineJoin, '"', ' miterlimit="', t.miterLimit, '"', ' endcap="', W[t.lineCap] || "square", '"', ' weight="', s, 'px"', ' color="', i, '" />')
    }

    function p(t, e, i, a) {
        var s = t.fillStyle,
            n = t.arcScaleX_,
            o = t.arcScaleY_,
            l = a.x - i.x,
            r = a.y - i.y;
        if (s instanceof g) {
            var d = 0,
                x = a = 0,
                c = 0,
                p = 1;
            if ("gradient" == s.type_) {
                d = s.x1_ / n, i = s.y1_ / o;
                var m = u(t, s.x0_ / n, s.y0_ / o);
                d = u(t, d, i);
                0 > (d = 180 * Math.atan2(d.x - m.x, d.y - m.y) / Math.PI) && (d += 360), 1e-6 > d && (d = 0)
            } else a = ((m = u(t, s.x0_, s.y0_)).x - i.x) / l, x = (m.y - i.y) / r, l /= n * w, r /= o * w, p = v.max(l, r), c = 2 * s.r0_ / p, p = 2 * s.r1_ / p - c;
            (n = s.colors_).sort(function(t, e) {
                return t.offset - e.offset
            }), o = n.length, m = n[0].color, i = n[o - 1].color, l = n[0].alpha * t.globalAlpha, t = n[o - 1].alpha * t.globalAlpha;
            r = [];
            for (var y = 0; y < o; y++) {
                var f = n[y];
                r.push(f.offset * p + c + " " + f.color)
            }
            e.push('<g_vml_:fill type="', s.type_, '"', ' method="none" focus="100%"', ' color="', m, '"', ' color2="', i, '"', ' colors="', r.join(","), '"', ' opacity="', t, '"', ' g_o_:opacity2="', l, '"', ' angle="', d, '"', ' focusposition="', a, ",", x, '" />')
        } else s instanceof b ? l && r && e.push("<g_vml_:fill", ' position="', -i.x / l * n * n, ",", -i.y / r * o * o, '"', ' type="tile"', ' src="', s.src_, '" />') : (s = h(t.fillStyle), e.push('<g_vml_:fill color="', s.color, '" opacity="', s.alpha * t.globalAlpha, '" />'))
    }

    function u(t, e, i) {
        return t = t.m_, {
            x: w * (e * t[0][0] + i * t[1][0] + t[2][0]) - C,
            y: w * (e * t[0][1] + i * t[1][1] + t[2][1]) - C
        }
    }

    function m(t, e, i) {
        isFinite(e[0][0]) && isFinite(e[0][1]) && isFinite(e[1][0]) && isFinite(e[1][1]) && isFinite(e[2][0]) && isFinite(e[2][1]) && (t.m_ = e, i && (t.lineScale_ = P(T(e[0][0] * e[1][1] - e[0][1] * e[1][0]))))
    }

    function g(t) {
        this.type_ = t, this.r1_ = this.y1_ = this.x1_ = this.r0_ = this.y0_ = this.x0_ = 0, this.colors_ = []
    }

    function b(t, e) {
        if (!t || 1 != t.nodeType || "IMG" != t.tagName) throw new y("TYPE_MISMATCH_ERR");
        if ("complete" != t.readyState) throw new y("INVALID_STATE_ERR");
        switch (e) {
            case "repeat":
            case null:
            case "":
                this.repetition_ = "repeat";
                break;
            case "repeat-x":
            case "repeat-y":
            case "no-repeat":
                this.repetition_ = e;
                break;
            default:
                throw new y("SYNTAX_ERR")
        }
        this.src_ = t.src, this.width_ = t.width, this.height_ = t.height
    }

    function y(t) {
        this.code = this[t], this.message = t + ": DOM Exception " + this.code
    }
    var v = Math,
        f = v.round,
        k = v.sin,
        M = v.cos,
        T = v.abs,
        P = v.sqrt,
        w = 10,
        C = w / 2;
    navigator.userAgent.match(/MSIE ([\d.]+)?/);
    var S = Array.prototype.slice;
    e(document);
    var _ = {
        init: function(t) {
            (t = t || document).createElement("canvas"), t.attachEvent("onreadystatechange", function(t, e, i) {
                var a = S.call(arguments, 2);
                return function() {
                    return t.apply(e, a.concat(S.call(arguments)))
                }
            }(this.init_, this, t))
        },
        init_: function(t) {
            t = t.getElementsByTagName("canvas");
            for (var e = 0; e < t.length; e++) this.initElement(t[e])
        },
        initElement: function(t) {
            if (!t.getContext) {
                t.getContext = V, e(t.ownerDocument), t.innerHTML = "", t.attachEvent("onpropertychange", i), t.attachEvent("onresize", a);
                var s = t.attributes;
                s.width && s.width.specified ? t.style.width = s.width.nodeValue + "px" : t.width = t.clientWidth, s.height && s.height.specified ? t.style.height = s.height.nodeValue + "px" : t.height = t.clientHeight
            }
            return t
        }
    };
    _.init();
    for (var B = [], F = 0; 16 > F; F++)
        for (var A = 0; 16 > A; A++) B[16 * F + A] = F.toString(16) + A.toString(16);
    var L = {
            aliceblue: "#F0F8FF",
            antiquewhite: "#FAEBD7",
            aquamarine: "#7FFFD4",
            azure: "#F0FFFF",
            beige: "#F5F5DC",
            bisque: "#FFE4C4",
            black: "#000000",
            blanchedalmond: "#FFEBCD",
            blueviolet: "#8A2BE2",
            brown: "#A52A2A",
            burlywood: "#DEB887",
            cadetblue: "#5F9EA0",
            chartreuse: "#7FFF00",
            chocolate: "#D2691E",
            coral: "#FF7F50",
            cornflowerblue: "#6495ED",
            cornsilk: "#FFF8DC",
            crimson: "#DC143C",
            cyan: "#00FFFF",
            darkblue: "#00008B",
            darkcyan: "#008B8B",
            darkgoldenrod: "#B8860B",
            darkgray: "#A9A9A9",
            darkgreen: "#006400",
            darkgrey: "#A9A9A9",
            darkkhaki: "#BDB76B",
            darkmagenta: "#8B008B",
            darkolivegreen: "#556B2F",
            darkorange: "#FF8C00",
            darkorchid: "#9932CC",
            darkred: "#8B0000",
            darksalmon: "#E9967A",
            darkseagreen: "#8FBC8F",
            darkslateblue: "#483D8B",
            darkslategray: "#2F4F4F",
            darkslategrey: "#2F4F4F",
            darkturquoise: "#00CED1",
            darkviolet: "#9400D3",
            deeppink: "#FF1493",
            deepskyblue: "#00BFFF",
            dimgray: "#696969",
            dimgrey: "#696969",
            dodgerblue: "#1E90FF",
            firebrick: "#B22222",
            floralwhite: "#FFFAF0",
            forestgreen: "#228B22",
            gainsboro: "#DCDCDC",
            ghostwhite: "#F8F8FF",
            gold: "#FFD700",
            goldenrod: "#DAA520",
            grey: "#FFFFFF",
            greenyellow: "#ADFF2F",
            honeydew: "#F0FFF0",
            hotpink: "#FF69B4",
            indianred: "#CD5C5C",
            indigo: "#4B0082",
            ivory: "#FFFFF0",
            khaki: "#F0E68C",
            lavender: "#E6E6FA",
            lavenderblush: "#FFF0F5",
            lawngreen: "#7CFC00",
            lemonchiffon: "#FFFACD",
            lightblue: "#ADD8E6",
            lightcoral: "#F08080",
            lightcyan: "#E0FFFF",
            lightgoldenrodyellow: "#FAFAD2",
            lightgreen: "#90EE90",
            lightgrey: "#D3D3D3",
            lightpink: "#FFB6C1",
            lightsalmon: "#FFA07A",
            lightseagreen: "#20B2AA",
            lightskyblue: "#87CEFA",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            lightsteelblue: "#B0C4DE",
            lightyellow: "#FFFFE0",
            limegreen: "#32CD32",
            linen: "#FAF0E6",
            magenta: "#FF00FF",
            mediumaquamarine: "#66CDAA",
            mediumblue: "#0000CD",
            mediumorchid: "#BA55D3",
            mediumpurple: "#9370DB",
            mediumseagreen: "#3CB371",
            mediumslateblue: "#7B68EE",
            mediumspringgreen: "#00FA9A",
            mediumturquoise: "#48D1CC",
            mediumvioletred: "#C71585",
            midnightblue: "#191970",
            mintcream: "#F5FFFA",
            mistyrose: "#FFE4E1",
            moccasin: "#FFE4B5",
            navajowhite: "#FFDEAD",
            oldlace: "#FDF5E6",
            olivedrab: "#6B8E23",
            orange: "#FFA500",
            orangered: "#FF4500",
            orchid: "#DA70D6",
            palegoldenrod: "#EEE8AA",
            palegreen: "#98FB98",
            paleturquoise: "#AFEEEE",
            palevioletred: "#DB7093",
            papayawhip: "#FFEFD5",
            peachpuff: "#FFDAB9",
            peru: "#CD853F",
            pink: "#FFC0CB",
            plum: "#DDA0DD",
            powderblue: "#B0E0E6",
            rosybrown: "#BC8F8F",
            royalblue: "#4169E1",
            saddlebrown: "#8B4513",
            salmon: "#FA8072",
            sandybrown: "#F4A460",
            seagreen: "#2E8B57",
            seashell: "#FFF5EE",
            sienna: "#A0522D",
            skyblue: "#87CEEB",
            slateblue: "#6A5ACD",
            slategray: "#708090",
            slategrey: "#708090",
            snow: "#FFFAFA",
            springgreen: "#00FF7F",
            steelblue: "#4682B4",
            tan: "#D2B48C",
            thistle: "#D8BFD8",
            tomato: "#FF6347",
            turquoise: "#40E0D0",
            violet: "#EE82EE",
            wheat: "#F5DEB3",
            whitesmoke: "#F5F5F5",
            yellowgreen: "#9ACD32"
        },
        I = {},
        D = {},
        W = {
            butt: "flat",
            round: "round"
        };
    (F = d.prototype).clearRect = function() {
        this.textMeasureEl_ && (this.textMeasureEl_.removeNode(!0), this.textMeasureEl_ = null), this.element_.innerHTML = ""
    }, F.beginPath = function() {
        this.currentPath_ = []
    }, F.moveTo = function(t, e) {
        var i = u(this, t, e);
        this.currentPath_.push({
            type: "moveTo",
            x: i.x,
            y: i.y
        }), this.currentX_ = i.x, this.currentY_ = i.y
    }, F.lineTo = function(t, e) {
        var i = u(this, t, e);
        this.currentPath_.push({
            type: "lineTo",
            x: i.x,
            y: i.y
        }), this.currentX_ = i.x, this.currentY_ = i.y
    }, F.bezierCurveTo = function(t, e, i, a, s, n) {
        s = u(this, s, n), x(this, t = u(this, t, e), i = u(this, i, a), s)
    }, F.quadraticCurveTo = function(t, e, i, a) {
        t = u(this, t, e), i = u(this, i, a), x(this, a = {
            x: this.currentX_ + 2 / 3 * (t.x - this.currentX_),
            y: this.currentY_ + 2 / 3 * (t.y - this.currentY_)
        }, {
            x: a.x + (i.x - this.currentX_) / 3,
            y: a.y + (i.y - this.currentY_) / 3
        }, i)
    }, F.arc = function(t, e, i, a, s, n) {
        i *= w;
        var o = n ? "at" : "wa",
            l = t + M(a) * i - C,
            r = e + k(a) * i - C;
        a = t + M(s) * i - C, s = e + k(s) * i - C, l != a || n || (l += .125), t = u(this, t, e), l = u(this, l, r), a = u(this, a, s), this.currentPath_.push({
            type: o,
            x: t.x,
            y: t.y,
            radius: i,
            xStart: l.x,
            yStart: l.y,
            xEnd: a.x,
            yEnd: a.y
        })
    }, F.rect = function(t, e, i, a) {
        this.moveTo(t, e), this.lineTo(t + i, e), this.lineTo(t + i, e + a), this.lineTo(t, e + a), this.closePath()
    }, F.strokeRect = function(t, e, i, a) {
        var s = this.currentPath_;
        this.beginPath(), this.moveTo(t, e), this.lineTo(t + i, e), this.lineTo(t + i, e + a), this.lineTo(t, e + a), this.closePath(), this.stroke(), this.currentPath_ = s
    }, F.fillRect = function(t, e, i, a) {
        var s = this.currentPath_;
        this.beginPath(), this.moveTo(t, e), this.lineTo(t + i, e), this.lineTo(t + i, e + a), this.lineTo(t, e + a), this.closePath(), this.fill(), this.currentPath_ = s
    }, F.createLinearGradient = function(t, e, i, a) {
        var s = new g("gradient");
        return s.x0_ = t, s.y0_ = e, s.x1_ = i, s.y1_ = a, s
    }, F.createRadialGradient = function(t, e, i, a, s, n) {
        var o = new g("gradientradial");
        return o.x0_ = t, o.y0_ = e, o.r0_ = i, o.x1_ = a, o.y1_ = s, o.r1_ = n, o
    }, F.drawImage = function(t, e) {
        var i, a, s, n, o, l, r, h;
        s = t.runtimeStyle.width, n = t.runtimeStyle.height, t.runtimeStyle.width = "auto", t.runtimeStyle.height = "auto";
        var d = t.width,
            x = t.height;
        if (t.runtimeStyle.width = s, t.runtimeStyle.height = n, 3 == arguments.length) i = arguments[1], a = arguments[2], o = l = 0, r = s = d, h = n = x;
        else if (5 == arguments.length) i = arguments[1], a = arguments[2], s = arguments[3], n = arguments[4], o = l = 0, r = d, h = x;
        else {
            if (9 != arguments.length) throw Error("Invalid number of arguments");
            o = arguments[1], l = arguments[2], r = arguments[3], h = arguments[4], i = arguments[5], a = arguments[6], s = arguments[7], n = arguments[8]
        }
        var c = u(this, i, a),
            p = [];
        if (p.push(" <g_vml_:group", ' coordsize="', 10 * w, ",", 10 * w, '"', ' coordorigin="0,0"', ' style="width:', 10, "px;height:", 10, "px;position:absolute;"), 1 != this.m_[0][0] || this.m_[0][1] || 1 != this.m_[1][1] || this.m_[1][0]) {
            var m = [];
            m.push("M11=", this.m_[0][0], ",", "M12=", this.m_[1][0], ",", "M21=", this.m_[0][1], ",", "M22=", this.m_[1][1], ",", "Dx=", f(c.x / w), ",", "Dy=", f(c.y / w), "");
            var g = u(this, i + s, a),
                b = u(this, i, a + n);
            i = u(this, i + s, a + n), c.x = v.max(c.x, g.x, b.x, i.x), c.y = v.max(c.y, g.y, b.y, i.y), p.push("padding:0 ", f(c.x / w), "px ", f(c.y / w), "px 0;filter:progid:DXImageTransform.Microsoft.Matrix(", m.join(""), ", sizingmethod='clip');")
        } else p.push("top:", f(c.y / w), "px;left:", f(c.x / w), "px;");
        p.push(' ">', '<g_vml_:image src="', t.src, '"', ' style="width:', w * s, "px;", " height:", w * n, 'px"', ' cropleft="', o / d, '"', ' croptop="', l / x, '"', ' cropright="', (d - o - r) / d, '"', ' cropbottom="', (x - l - h) / x, '"', " />", "</g_vml_:group>"), this.element_.insertAdjacentHTML("BeforeEnd", p.join(""))
    }, F.stroke = function(t) {
        var e = [];
        e.push("<g_vml_:shape", ' filled="', !!t, '"', ' style="position:absolute;width:', 10, "px;height:", 10, 'px;"', ' coordorigin="0,0"', ' coordsize="', 10 * w, ",", 10 * w, '"', ' stroked="', !t, '"', ' path="');
        for (var i = {
                x: null,
                y: null
            }, a = {
                x: null,
                y: null
            }, s = 0; s < this.currentPath_.length; s++) {
            var n = this.currentPath_[s];
            switch (n.type) {
                case "moveTo":
                    e.push(" m ", f(n.x), ",", f(n.y));
                    break;
                case "lineTo":
                    e.push(" l ", f(n.x), ",", f(n.y));
                    break;
                case "close":
                    e.push(" x "), n = null;
                    break;
                case "bezierCurveTo":
                    e.push(" c ", f(n.cp1x), ",", f(n.cp1y), ",", f(n.cp2x), ",", f(n.cp2y), ",", f(n.x), ",", f(n.y));
                    break;
                case "at":
                case "wa":
                    e.push(" ", n.type, " ", f(n.x - this.arcScaleX_ * n.radius), ",", f(n.y - this.arcScaleY_ * n.radius), " ", f(n.x + this.arcScaleX_ * n.radius), ",", f(n.y + this.arcScaleY_ * n.radius), " ", f(n.xStart), ",", f(n.yStart), " ", f(n.xEnd), ",", f(n.yEnd))
            }
            n && ((null == i.x || n.x < i.x) && (i.x = n.x), (null == a.x || n.x > a.x) && (a.x = n.x), (null == i.y || n.y < i.y) && (i.y = n.y), (null == a.y || n.y > a.y) && (a.y = n.y))
        }
        e.push(' ">'), t ? p(this, e, i, a) : c(this, e), e.push("</g_vml_:shape>"), this.element_.insertAdjacentHTML("beforeEnd", e.join(""))
    }, F.fill = function() {
        this.stroke(!0)
    }, F.closePath = function() {
        this.currentPath_.push({
            type: "close"
        })
    }, F.save = function() {
        var t = {};
        n(this, t), this.aStack_.push(t), this.mStack_.push(this.m_), this.m_ = s([
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1]
        ], this.m_)
    }, F.restore = function() {
        this.aStack_.length && (n(this.aStack_.pop(), this), this.m_ = this.mStack_.pop())
    }, F.translate = function(t, e) {
        m(this, s([
            [1, 0, 0],
            [0, 1, 0],
            [t, e, 1]
        ], this.m_), !1)
    }, F.rotate = function(t) {
        var e = M(t);
        m(this, s([
            [e, t = k(t), 0],
            [-t, e, 0],
            [0, 0, 1]
        ], this.m_), !1)
    }, F.scale = function(t, e) {
        this.arcScaleX_ *= t, this.arcScaleY_ *= e, m(this, s([
            [t, 0, 0],
            [0, e, 0],
            [0, 0, 1]
        ], this.m_), !0)
    }, F.transform = function(t, e, i, a, n, o) {
        m(this, s([
            [t, e, 0],
            [i, a, 0],
            [n, o, 1]
        ], this.m_), !0)
    }, F.setTransform = function(t, e, i, a, s, n) {
        m(this, [
            [t, e, 0],
            [i, a, 0],
            [s, n, 1]
        ], !0)
    }, F.drawText_ = function(e, i, a, s, n) {
        var o = this.m_;
        s = 0;
        var l, r = 1e3,
            h = 0,
            d = [];
        if (l = this.font, D[l]) l = D[l];
        else {
            var x = document.createElement("div").style;
            try {
                x.font = l
            } catch (t) {}
            l = D[l] = {
                style: x.fontStyle || "normal",
                variant: x.fontVariant || "normal",
                weight: x.fontWeight || "normal",
                size: x.fontSize || 10,
                family: x.fontFamily || "sans-serif"
            }
        }
        x = l;
        var m = this.element_;
        for (var g in l = {}, x) l[g] = x[g];
        switch (g = parseFloat(m.currentStyle.fontSize), m = parseFloat(x.size), "number" == typeof x.size ? l.size = x.size : -1 != x.size.indexOf("px") ? l.size = m : -1 != x.size.indexOf("em") ? l.size = g * m : -1 != x.size.indexOf("%") ? l.size = g / 100 * m : -1 != x.size.indexOf("pt") ? l.size = m / .75 : l.size = g, l.size *= .981, g = l.style + " " + l.variant + " " + l.weight + " " + l.size + "px " + l.family, m = this.element_.currentStyle, x = this.textAlign.toLowerCase()) {
            case "left":
            case "center":
            case "right":
                break;
            case "end":
                x = "ltr" == m.direction ? "right" : "left";
                break;
            case "start":
                x = "rtl" == m.direction ? "right" : "left";
                break;
            default:
                x = "left"
        }
        switch (this.textBaseline) {
            case "hanging":
            case "top":
                h = l.size / 1.75;
                break;
            case "middle":
                break;
            default:
            case null:
            case "alphabetic":
            case "ideographic":
            case "bottom":
                h = -l.size / 2.25
        }
        switch (x) {
            case "right":
                s = 1e3, r = .05;
                break;
            case "center":
                s = r = 500
        }
        i = u(this, i + 0, a + h), d.push('<g_vml_:line from="', -s, ' 0" to="', r, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !n, '" stroked="', !!n, '" style="position:absolute;width:1px;height:1px;">'), n ? c(this, d) : p(this, d, {
            x: -s,
            y: 0
        }, {
            x: r,
            y: l.size
        }), n = o[0][0].toFixed(3) + "," + o[1][0].toFixed(3) + "," + o[0][1].toFixed(3) + "," + o[1][1].toFixed(3) + ",0,0", i = f(i.x / w) + "," + f(i.y / w), d.push('<g_vml_:skew on="t" matrix="', n, '" ', ' offset="', i, '" origin="', s, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', t(e), '" style="v-text-align:', x, ";font:", t(g), '" /></g_vml_:line>'), this.element_.insertAdjacentHTML("beforeEnd", d.join(""))
    }, F.fillText = function(t, e, i, a) {
        this.drawText_(t, e, i, a, !1)
    }, F.strokeText = function(t, e, i, a) {
        this.drawText_(t, e, i, a, !0)
    }, F.measureText = function(t) {
        this.textMeasureEl_ || (this.element_.insertAdjacentHTML("beforeEnd", '<span style="position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;"></span>'), this.textMeasureEl_ = this.element_.lastChild);
        var e = this.element_.ownerDocument;
        return this.textMeasureEl_.innerHTML = "", this.textMeasureEl_.style.font = this.font, this.textMeasureEl_.appendChild(e.createTextNode(t)), {
            width: this.textMeasureEl_.offsetWidth
        }
    }, F.clip = function() {}, F.arcTo = function() {}, F.createPattern = function(t, e) {
        return new b(t, e)
    }, g.prototype.addColorStop = function(t, e) {
        e = h(e), this.colors_.push({
            offset: t,
            color: e.color,
            alpha: e.alpha
        })
    }, (F = y.prototype = Error()).INDEX_SIZE_ERR = 1, F.DOMSTRING_SIZE_ERR = 2, F.HIERARCHY_REQUEST_ERR = 3, F.WRONG_DOCUMENT_ERR = 4, F.INVALID_CHARACTER_ERR = 5, F.NO_DATA_ALLOWED_ERR = 6, F.NO_MODIFICATION_ALLOWED_ERR = 7, F.NOT_FOUND_ERR = 8, F.NOT_SUPPORTED_ERR = 9, F.INUSE_ATTRIBUTE_ERR = 10, F.INVALID_STATE_ERR = 11, F.SYNTAX_ERR = 12, F.INVALID_MODIFICATION_ERR = 13, F.NAMESPACE_ERR = 14, F.INVALID_ACCESS_ERR = 15, F.VALIDATION_ERR = 16, F.TYPE_MISMATCH_ERR = 17, G_vmlCanvasManager = _, CanvasRenderingContext2D = d, CanvasGradient = g, CanvasPattern = b, DOMException = y
}();
/*eslint-enable*/
/*jshint ignore:end*/